<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://huyifu.github.io</id>
    <title>古月的blog</title>
    <updated>2021-04-06T10:44:31.181Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://huyifu.github.io"/>
    <link rel="self" href="https://huyifu.github.io/atom.xml"/>
    <subtitle>Nothing for nothing
</subtitle>
    <logo>https://huyifu.github.io/images/avatar.png</logo>
    <icon>https://huyifu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 古月的blog</rights>
    <entry>
        <title type="html"><![CDATA[vue学习]]></title>
        <id>https://huyifu.github.io/post/vue-xue-xi/</id>
        <link href="https://huyifu.github.io/post/vue-xue-xi/">
        </link>
        <updated>2021-04-05T10:14:41.000Z</updated>
        <content type="html"><![CDATA[<p>Vue的语法及其使用<br>
需要实例化</p>
<pre><code>var vm = new Vue({
  // 选项
})
 var vm = new Vue({
        el: '#vue_det', 进行与id为vue_det的元素进行绑定
        data: {    	//data定义属性
            site: &quot;菜鸟教程&quot;, 
            url: &quot;www.runoob.com&quot;,
            alexa: &quot;10000&quot;
        },
        methods: {  	//methods定义函数
            details: function() {
                return  this.site + &quot; - 学的不仅是技术，更是梦想！&quot;;
            }
        }
    })
    ```
html：
</code></pre>
<div id="vue_det">
    <h4>site : {{site}}</h4>
    <h4>url : {{url}}</h4>
    <h4>{{details()}}</h4>
</div>
```
通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：
```
<span v-once>这个将不会改变: {{ msg }}</span>
```
模板语法
使用 v-html 指令用于输出 html 代码：
```
 data: {
    message: '<h4>菜鸟教程</h4>'
  }
<pre><code>v-bind用于绑定数据和元素属性   v-bind:属性名=&quot; &quot;的格式简写成:属性名=&quot; &quot;
例如
</code></pre>
<p>&lt; a :class=&quot;data1&quot; :href=&quot;url&quot;&gt;click me</a><br>
data:{<br>
url:&quot;https://www.baidu.com&quot;,<br>
data1: {active:isActive} //此处为一个对象 也可以进行绑定<br>
}</p>
<pre><code>```
</code></pre>
<p>指令 (Directives) 是带有 v- 前缀的特殊 attribute。指令 attribute 的值预期是单个 JavaScript 表达式</p>
<p v-if="seen">现在你看到我了</p>
这里，v-if 指令将根据表达式 seen 的值的真假来插入/移除 <p> 元素。
<p>v-on 指令，它用于监听 DOM 事件：<br>
<a v-on:click="doSomething">...</a><br>
v-on:click =<br>
缩写<br>
@click =<br>
@[event]  =<br>
动态参数</p>
<p>计算属性  data里的computed 写入需要计算的表达式</p>
<pre><code>&lt;div id=&quot;example&quot;&gt;
  &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt;
  &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;
&lt;/div&gt;
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
</code></pre>
<p>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：<br>
v-bind:[attributeName]=&quot;url&quot;  即data中attributeName的值作为绑定的属性</p>
<h2 id="计算属性缓存-vs-方法">计算属性缓存 vs 方法</h2>
<p>vue 实例 中computed 与 methods 都可以基于某一个data进行表达式的运算</p>
<pre><code>methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('')
  }
}
</code></pre>
<p>与</p>
<pre><code>  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
</code></pre>
<h3 id="两者结果一致-但是计算属性是基于它们的响应式依赖进行缓存的">两者结果一致 但是计算属性是基于它们的响应式依赖进行缓存的</h3>
<p>意味着 如果所依赖的data没有进行更改 计算属性会立即返回之前的计算结果，而不必再次执行函数。  所有使用computed在某些时刻可以提高性能<br>
因为数据绑定 和依赖式的更新  可以不进行监听数据</p>
<pre><code>var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar'
  },
  computed: {
    fullName: function () {
      return this.firstName + ' ' + this.lastName
    }
  }
})
</code></pre>
<p>在firstName 或者 lastName 更改时候 fullName自动进行更改</p>
<p>computed  set 与get</p>
<pre><code> &lt;body&gt;
     &lt;div id=&quot;app&quot;&gt;
         {{fullName}}
     &lt;/div&gt;
    &lt;script&gt;
       var vm = new Vue({
           el: &quot;#app&quot;,
           data: {
               firstName:&quot;Ma&quot;,
               lastName:&quot;BinYan&quot;
           },
           computed:{
               fullName :{
                   get: function()
                   {return this.firstName+&quot; &quot;+this.lastName},
                  set : function(value)  //修改fullName的值时触发
                  {
                      var array = value.split(&quot; &quot;);
                       this.firstName=array[0];
                       this.lastName=array[1];
                   }
               }
           }
       })
    &lt;/script&gt;
  &lt;/body&gt;
</code></pre>
<p>侦听器<br>
虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p>
<p>绑定 HTML Class<br>
对象语法<br>
我们可以传给 v-bind:class 一个对象，以动态地切换 class：</p>
<div v-bind:class="{ active: isActive }"></div>
上面的语法表示 active 这个 class 存在与否将取决于数据 property isActive 的 truthiness。
<p>你可以在对象中传入更多字段来动态切换多个 class。此外，v-bind:class 指令也可以与普通的 class attribute 共存。当有如下模板：</p>
<div
  class="static"
  v-bind:class="{ active: isActive, 'text-danger': hasError }"
></div>
和如下 data：
<p>data: {<br>
isActive: true,<br>
hasError: false<br>
}<br>
结果渲染为：</p>
<pre><code>&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;

  &lt;style&gt;
   .styles{
      color: yellow;
  }
    &lt;/style&gt;
&lt;/head&gt;
    
  &lt;body&gt;
    &lt;div id=&quot;app&quot; &gt;
    &lt;span @click=&quot;handleClick&quot;
    :class=&quot;{styles: isActivated}&quot;&gt;XiaoMa&lt;/span&gt;
&lt;/div&gt;
     &lt;script&gt;
         var vm = new Vue({
             el:&quot;#app&quot;,
             data:{
                 isActivated : false
             },
             methods:{
              handleClick: function (){
                  this.isActivated=!this.isActivated;
              }
             }
         })
 &lt;/script&gt;
</code></pre>
<p>条件渲染<br>
v-if<br>
v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</p>
<h4 v-if="awesome">Vue is awesome!</h4>
也可以用 v-else 添加一个“else 块”：
<h4 v-if="awesome">Vue is awesome!</h4>
<h4 v-else>Oh no 😢</h4>
在 < template> 元素上使用 v-if 条件渲染分组
因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 < template> 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 < t emplate> 元素。
```
<template v-if="ok">
  <h1>Title</h1>
  <p>Paragraph 1</p>
  <p>Paragraph 2</p>
</template>
v-else-if 
<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Not A/B/C
</div>
```
<h3 id="vue-会尽可能高效地渲染元素通常会复用已有元素而不是从头开始渲染">Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。</h3>
<p>会使得某些元素直接复用 出现一些问题</p>
<pre><code>&lt;template v-if=&quot;loginType === 'username'&quot;&gt;
  &lt;label&gt;Username&lt;/label&gt;
  &lt;input placeholder=&quot;Enter your username&quot;&gt;
&lt;/template&gt;
&lt;template v-else&gt;
  &lt;label&gt;Email&lt;/label&gt;
  &lt;input placeholder=&quot;Enter your email address&quot;&gt;
&lt;/template&gt;
</code></pre>
<p>input里面的内容在切换时不会清除 因为vue在渲染时复用了另一个input<br>
解决方法—— 绑定key值<br>
:key =&quot;id&quot;  vue根据key来判断是不是相同的元素</p>
<p>v-show   保留有dom<br>
条件展示元素<br>
不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display。</p>
<h2 id="v-if-vs-v-show">v-if vs v-show</h2>
<p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>
v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>
相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。<br>
一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p>
<p>列表渲染<br>
在 v-for 里使用对象<br>
你也可以用 v-for 来遍历一个对象的 property。</p>
<pre><code>&lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt;
  &lt;li v-for=&quot;value in object&quot;&gt;
    {{ value }}
  &lt;/li&gt;
&lt;/ul&gt;
new Vue({
  el: '#v-for-object',
  data: {
    object: {
      title: 'How to do lists in Vue',
      author: 'Jane Doe',
      publishedAt: '2016-04-10'
    }
  }
})
</code></pre>
<p>结果：</p>
<p>你也可以提供第二个的参数为 property 名称 (也就是键名)：</p>
<div v-for="(value, name) in object">
  {{ name }}: {{ value }}
</div>
<p>还可以用第三个参数作为索引：</p>
<div v-for="(value, name, index) in object">
  {{ index }}. {{ name }}: {{ value }}
</div>
结果如下：
0.title: How to do lists in Vue,
1.author: Jane Doe,
2.publishedAt: 2016-04-10
<h2 id="遍历的特性">遍历的特性</h2>
<p>维护状态<br>
当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 track-by=&quot;$index&quot;。<br>
这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。<br>
为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute：</p>
<div v-for="item in items" v-bind:key="item.id">
  <!-- 内容 -->
</div>
建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。
<p>变更方法<br>
Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：<br>
push()<br>
pop()<br>
shift()<br>
unshift()<br>
splice()<br>
sort()<br>
reverse()<br>
tip：用数组下标可以来改变数据 但是不会触发视图更新</p>
<h2 id="使用ref获取dom">使用ref获取dom</h2>
<pre><code>&lt;body&gt;
    &lt;div id='app'&gt;
       &lt;div ref='hello' @click=&quot;handleClick&quot;&gt;
           click me
        此div绑定了一个ref hello
        在函数中使用this.$refs vue实例中所有的引用
        this.$refs.hello可以取到这个dom节点
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
  new Vue({
      el:'#app',
      methods: {
          handleClick : function(){
              alert(this.$refs.hello.innerHTML);
          }
      }

});
    &lt;/script&gt;
  &lt;/body&gt;

</code></pre>
<h2 id="组件的使用">组件的使用</h2>
<p>Vue.component('组件名称', {组件内容});<br>
在创建后 组件为可复用的vue实例<br>
组件作为自定义元素来使用：<br>
&lt;组件名&gt;&lt;/组件名&gt;</p>
<p>组件的注册<br>
Vue.componet 全局注册<br>
全局注册的组件可以用在其被注册之后的任何 (通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。<br>
局部注册<br>
var ComponentA = { /* ... <em>/ }<br>
var ComponentB = { /</em> ... <em>/ }<br>
var ComponentC = { /</em> ... */ }<br>
然后在 components 选项中定义你想要使用的组件：</p>
<pre><code>new Vue({
  el: '#app',
  components: {
    'component-a': ComponentA,
    'component-b': ComponentB
  }
})
</code></pre>
<p>对于 components 对象中的每个 property 来说，其 property 名就是自定义元素的名字，其 property 值就是这个组件的选项对象。</p>
<h3 id="tip局部组件的使用需要像上面那样声明-即局部组件中使用另一个需要声明">tip：局部组件的使用需要像上面那样声明  即局部组件中使用另一个需要声明</h3>
<p>var ComponentA = { /* ... */ }<br>
var ComponentB = {<br>
components: {<br>
'component-a': ComponentA<br>
},<br>
// ...<br>
}</p>
<h2 id="prop">Prop</h2>
<p>子组件设置props属性来接收父组件的数据<br>
单向数据流： 子组件不能改变父组件传来的值 父组件更新数据传给子组件的数据会进行更新<br>
如果需要更改并传给父组件可以：<br>
在子组件data中copy数据 并使用data中的数据进行传值</p>
<p>1 子局部组件创建  var a={}<br>
2 父组件在组件中声明 components:{ a : a}<br>
3 子组件在props属性中 声明好子组件需要接收到的数据 props:['data']<br>
4 在子组件调用时 利用props进行传值  <a :data= "需要传递的数据"></a><br>
5  子组件需要向父组件传值时 可以调用this.$emit(&quot;事件名&quot;,参数1) 来传值 触发自定义事件<br>
6  子组件上提前监听好了这个事件 在子组件触发这个事件开始调用处理函数 父组件里的方法进行处理<br>
7 处理完毕 父子组件相互传值成功</p>
<pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;
    &lt;title&gt;Model&lt;/title&gt;
    &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
 
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;p&gt;父子组件传值 子组件设置props属性接收数据&lt;/p&gt;
        &lt;counter :count=&quot;data1&quot; @change=&quot;handleChange&quot;&gt;&lt;/counter&gt;
        &lt;counter :count=&quot;data2&quot; @change=&quot;handleChange&quot;&gt;&lt;/counter&gt;
        &lt;p&gt;现在给父组件添加一个数据 值为两个counter的数字和 涉及子组件给父组件传值&lt;/p&gt;
        &lt;p&gt;涉及三步骤 子组件被点击触发自定义的change事件 然后父组件设置了监听属性监听了这个change事件 最后进行处理事件&lt;/p&gt;
        {{totalNum}}
    &lt;/div&gt;
    &lt;script&gt;
        var counter = {
            props:['count'],
            template:'&lt;div @click=&quot;handleClick&quot;&gt;{{number}}&lt;/div&gt;',
            methods:{
                handleClick:function(){
                    this.number++;
                    this.$emit('change',1);
                }
            },
            data:function(){
                return{
                    number: this.count
                }
            }
        }
       new Vue({
           el:'#app',
           components:{
               counter:counter
           },
            data: function(){
                return{
                    totalNum:0,
                    data1:0,
                    data2:0
                }
            },
            methods:{
                handleChange:function(value){
                  // alert(value);
                   this.totalNum+= value;
                }
            }
       }) 
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="tip-如果要子组件要传给父组件多个值">tip ： 如果要子组件要传给父组件多个值</h3>
<p>子组件： this.$emit( &quot;事件名&quot;, data1,data2)<br>
父组件： @事件名 = &quot;处理函数(arguments)&quot;  参数对象<br>
此时 data1为arguments[0]  data2为arguments[1] ...</p>
<h2 id="组件名">组件名</h2>
<p>遵循 W3C 规范中的自定义组件名 (字母全小写且必须包含一个连字符)。<br>
定义组件名的方式有两种：</p>
<h3 id="使用-kebab-case">使用 kebab-case</h3>
<p>Vue.component('my-component-name', { /* ... */ })<br>
当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 <my-component-name>。</p>
<h3 id="使用-pascalcase">使用 PascalCase</h3>
<p>Vue.component('MyComponentName', { /* ... */ })<br>
当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 <my-component-name> 和 <MyComponentName> 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。<br>
tip：最好选择一种全部使用</p>
<p>组件参数校验</p>
<pre><code>Vue.component('my-component', {
  props: {
    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: {
      type: String,
      required: true
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100
    },
    // 带有默认值的对象
    propE: {
      type: Object,
      // 对象或数组默认值必须从一个工厂函数获取
      default: function () {
        return { message: 'hello' }
      }
    },
    // 自定义验证函数  （返回一个布尔值）
    propF: {
      validator: function (value) {
        // 这个值必须匹配下列字符串中的一个
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
  }
})
</code></pre>
<h2 id="props特性与非props特性">props特性与非props特性</h2>
<ul>
<li>props特性：<br>
子组件声明了传递参数的接收<br>
传递的参数不会在dom标签中显示<br>
可以通过插值表达式或者通过this.content去取得该属性中的内容。</li>
<li>非props特性：<br>
子组件不声明从父组件接收而来的参数<br>
显示在子组件最外层DOM标签的HTML属性里面</li>
</ul>
<p>组件绑定原生事件<br>
&lt;child @handle=&quot;handleChildClick&quot;&gt;</child>  在组件上绑定事件为自定义事件<br>
template: '&lt;div @click=&quot;handleClick&quot;&gt;Click me</div>'  在模板里直接会被渲染 所以绑定原生事件  （一般在这个原生事件里可以this.$emit('handle') 触发另一个事件)<br>
代码如下：</p>
<pre><code>&lt;body&gt;
    &lt;div id=&quot;app&quot; &gt;
        &lt;child @handle=&quot;handleChildClick&quot;&gt;&lt;/child&gt;
  &lt;/div&gt;
     &lt;script&gt;
         var child = {
             template:  '&lt;div @click=&quot;handleClick&quot;&gt;Click me&lt;/div&gt;',
             methods:{
                 handleClick :function(){
                     alert('原生事件触发');
                     this.$emit('handle');
                 }
             }
         }
         new Vue({
             el:'#app',
            components:{
                child : child,
            },
            methods:{
                handleChildClick :function(){
                    alert('自定义事件触发');
                }
            }
         })
      &lt;/script&gt;
  &lt;/body&gt;
</code></pre>
<p>原生事件触发 -》 this.$emit -》 监听子组件的自定义事件接收到 -》 自定义事件触发</p>
<h2 id="直接监听子组件的原生事件">直接监听子组件的原生事件</h2>
<p>使用修饰符 .native<br>
代码如下：</p>
<pre><code>&lt;body&gt;
    &lt;div id=&quot;app&quot; &gt;
        &lt;child @click.native=&quot;handleChildClick&quot;&gt;&lt;/child&gt;
    &lt;/div&gt;
     &lt;script&gt;
         var child = {
             template:  '&lt;div&gt;Click me&lt;/div&gt;',
         }
         new Vue({
             el:'#app',
            components:{
                child : child,
            },
            methods:{
                handleChildClick :function(){
                    alert('利用修饰符直接触发原生事件');
                }
            }
         })
      &lt;/script&gt;
  &lt;/body&gt;
</code></pre>
<h2 id="非父子组件之间传值">非父子组件之间传值</h2>
<p>(Bus/总线/发布者订阅模式/观察者模式）<br>
在vue最顶部</p>
<ul>
<li>Vue.prototype.bus = new Vue();<br>
在Vue的prototype挂载了一个bus属性 这个属性是指向vue的实例 调用 Vue 或者new Vue时，每个组件都会有一个bus属性，因为以后不管是 Vue 的属性还是 Vue 的实例，都是通过 Vue 来创建的，而我在 Vue 的prototype上挂载了一个bus的属性。</li>
<li>this.bus.$emit('触发事件', data)  传递的实例</li>
<li>this.bus.$on('触发事件', msg =&gt; {console.log('回调函数执行 msg为传递的数据'})  接收的实例</li>
</ul>
<p>代码如下：</p>
<pre><code>&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;sendchild :msg=&quot;1&quot;&gt;&lt;/sendchild&gt;
        &lt;acceptchild :msg=&quot;2&quot;&gt;&lt;/acceptchild&gt;
    &lt;/div&gt;
    &lt;script&gt;
       Vue.prototype.bus = new Vue();
        var sendchild= {
            template: '&lt;div @click=&quot;handleClick&quot;&gt;{{content}}&lt;/div&gt;',
            data: function(){
                return {
                    content: this.msg
                }
            },
            methods:{
                handleClick:function (){
                    alert('send孩子开始传值,用bus属性 emit transport事件 数据为content');
                    this.bus.$emit('transport',this.content);
                },
            },
           mounted:function(){
                console.log('send孩子实例创建，监听transport事件');
                this.bus.$on('transport',msg =&gt;console.log('send孩子接收到msg数据,数据为'+msg));
           },
            props:{
                msg: Number
            },
        }
        var acceptchild= {
            data: function(){
                return {
                    content: this.msg
                }
            },
            methods:{
                handleClick:function (){
                    alert('accept孩子开始传值,用bus属性emit transport事件 数据为content');
                    this.bus.$emit('transport',this.content);
                },
            },
            mounted:function(){
                console.log('accept孩子实例创建，监听transport事件');
                this.bus.$on('transport',msg =&gt;console.log('accept孩子接收到msg数据,数据为'+msg));
           },
            props:{
                msg: Number
            },
            template: '&lt;div @click=&quot;handleClick&quot;&gt;{{content}}&lt;/div&gt;'
        }
        new Vue({
            el:'#app',
            components:{
                sendchild : sendchild,
                acceptchild: acceptchild
            }
        })
    &lt;/script&gt;
  &lt;/body&gt;
</code></pre>
<p>使用插槽 slot  ——Vue 实现了一套内容分发的 API，将<slot>元素作为承载分发内容的出口<br>
子组件设置slot占位  父组件为这个slot填充内容</p>
<pre><code>&lt;div id='app'&gt;
        &lt;!-- child组件里面写的内容会默认插值到模板里的slot标签里 --&gt;
        &lt;child&gt;
            &lt;h1&gt;DELL&lt;/h1&gt;
        &lt;/child&gt;
    &lt;/div&gt;
    &lt;script&gt;
     Vue.component('child',{
         template: `
                &lt;div&gt;
                    &lt;p&gt;firstLine&lt;/p&gt;
                    &lt;slot&gt;slot标签里面为默认内容&lt;/slot&gt;
                &lt;/div&gt;
                `
     })
     new Vue({
         el: '#app'
     })
    &lt;/script&gt;
</code></pre>
<p>显示<br>
firstLine<br>
DELL<br>
tip：如果child组件无内容 即<child></child><br>
显示<br>
firstLine<br>
slot标签里面为默认内容</p>
<p>如果想有多个插槽 使用具名插槽</p>
<pre><code>  &lt;div id='app'&gt;
        &lt;!-- child组件里面写的内容会默认插值到模板里的slot标签里 --&gt;
        &lt;child&gt;
            &lt;header slot=&quot;header&quot;&gt;Header&lt;/header&gt;
            &lt;footer slot=&quot;footer&quot;&gt;Footer&lt;/footer&gt;
        &lt;/child&gt;
    &lt;/div&gt;
    &lt;script&gt;
     Vue.component('child',{
         template: `
                &lt;div&gt;
                     &lt;slot name='header'&gt;default Header&lt;/slot&gt;
                    &lt;div class=&quot;main&quot;&gt;Main&lt;/div&gt;
                    &lt;slot name='footer'&gt;default Footer&lt;/slot&gt;
                &lt;/div&gt;
                `
     })
     new Vue({
         el: '#app'
     })
    &lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Js 执行上下文（执行环境）]]></title>
        <id>https://huyifu.github.io/post/js-zhi-xing-shang-xia-wen-zhi-xing-huan-jing/</id>
        <link href="https://huyifu.github.io/post/js-zhi-xing-shang-xia-wen-zhi-xing-huan-jing/">
        </link>
        <updated>2021-03-30T16:13:19.000Z</updated>
        <content type="html"><![CDATA[<p>引言：在兜兜转转一圈后总算是大概理清了 执行环境 this 词法环境等等概念 如果之后学习又有新的看法和解释继续修改<br>
行文思路： 执行上下文 的类型 存储方式<br>
执行上下文的生命周期 和结构<br>
结构一 es3<br>
变量对象(variable object)，this指针(this value)，作用域链(scope chain) 三部分分别讲解在执行上下文在生命周期里的变化<br>
结构二 es6<br>
词法环境组件和变量环境组件   两部分分别讲解<br>
在执行上下文在生命周期里的变化<br>
总结：</p>
<h1 id="js是解释执行的语言">JS是解释执行的语言</h1>
<p>因此代码会通过先解析后执行的方式进行运行，而这个过程JS引擎会构造出一个抽象的环境 这个环境就是执行环境(Execution Context，也称为&quot;执行上下文&quot;)</p>
<h2 id="执行上下文有三种类型">执行上下文有三种类型</h2>
<ol>
<li>全局执行上下文： 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。</li>
<li>函数执行上下文： 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。</li>
<li>Eval 函数执行上下文： 运行在 eval 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 eval 函数，所以在这里不再讨论。</li>
</ol>
<h2 id="执行上下文的存储方式">执行上下文的存储方式</h2>
<p>每一个上下文在本质上都是一种作用域层级。每个代码段开始执行的时候都会创建一个新的上下文来运行它，并且在代码退出的时候销毁掉。而这种方式其实是一种堆栈的方式<br>
在JS中，是以栈(后进先出)这种数据结构存储执行上下文的，也就是我们所说的 执行栈。<br>
执行JS代码时，JS引擎首先会创建一个全局执行上下文，并压入栈底；之后每当 调用 一个函数时，都会为该函数创建一个函数执行上下文，并压入栈。<br>
之后引擎会执行栈顶的函数，函数执行结束后，该函数执行上下文从栈中弹出；再执行下一个函数，直到全部出栈。</p>
<pre><code>function A() {
  console.log('this is A')
  function B() {
    console.log('this is B')
  }
  B()
}
A()
</code></pre>
<p>执行上下文栈<br>
调用栈依次为：<br>
[ 全局环境 ]<br>
[ 全局环境，A 执行环境 ] A()，调用 A 函数，A 执行环境入栈<br>
[ 全局环境，A 执行环境，B 执行环境 ] A 函数执行时，遇到 B()， 调用 B 函数，B 入栈<br>
[ 全局环境，A 执行环境 ] B 执行结束，出栈<br>
[ 全局环境 ] A 执行结束出栈<br>
[全局环境退出] 所有代码执行完毕 全局环境出栈<br>
关于执行栈有以下特点：</p>
<ul>
<li>JavaScript执行在单线程上，所有的代码都是排队执行。</li>
<li>一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。</li>
<li>每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。</li>
<li>浏览器的JS执行引擎总是访问栈顶的执行上下文。</li>
<li>全局上下文只有唯一的一个，它在浏览器关闭时出栈。</li>
<li>关于递归函数——即多次调用自身的函数，需要特别注意：每次递归调用自身都会创建一个新的上下文。这使得 JavaScript 运行时能够追踪递归的层级以及从递归中得到的返回值，但这也意味着每次递归都会消耗内存来创建新的上下文。</li>
</ul>
<h2 id="创建执行上下文有两个阶段1-创建阶段-和-2-执行阶段-生命周期">创建执行上下文有两个阶段：1) 创建阶段 和 2) 执行阶段。（生命周期）</h2>
<p>ps：在执行上下文出栈会有垃圾回收机制，本文不做探讨<br>
在查询大量资料后：发现执行上下文的结构有两种</p>
<h3 id="1-es3-变量对象variable-objectthis指针this-value作用域链scope-chain">1 es3： 变量对象(variable object)，this指针(this value)，作用域链(scope chain)</h3>
<h3 id="2-es6-词法环境组件和变量环境组件-伴随着let等新内容而重新定义">2 es6： 词法环境组件和变量环境组件 （伴随着let等新内容而重新定义）</h3>
<p>先来探讨es3  其中闭包和提升的原理就在这里<br>
es3 执行上下文的生命周期<br>
创建阶段： 创建变量对象 建立作用域链 确定this指针指向<br>
指行阶段： 变量对象VO 变成活动对象 AO<br>
回收阶段： 执行上下文出栈等待垃圾回收机制</p>
<h3 id="变量对象">变量对象</h3>
<p>变量对象(variable object) 是与执行上下文相关的 数据作用域(scope of data) 。<br>
它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 和函数的形参</p>
<ul>
<li>全局上下文的变量对象 (VO === this === global)</li>
</ul>
<p>只有全局上下文的变量对象允许通过VO的属性名称来间接访问(因为在全局上下文里，全局对象自身就是变量对象，稍后会详细介绍)，在其它上下文中是不能直接访问VO对象的，因为它只是内部机制的一个实现。<br>
全局对象就是全局变量对象<br>
全局对象初始创建阶段将Math、String、Date、parseInt作为自身属性，等属性初始化，同样也可以有额外创建的其它对象作为属性（其可以指向到全局对象自身）。例如，在DOM中，全局对象的window属性就可以引用全局对象自身(当然，并不是所有的具体实现都是这样)：</p>
<pre><code>global = {
  Math: &lt;...&gt;,
  String: &lt;...&gt;
  ...
  ...
  window: global //引用自身
};
</code></pre>
<p>VO(globalContext) === global;</p>
<ul>
<li>函数上下文的变量对象</li>
</ul>
<p>在函数执行上下文中，VO是不能直接访问的，此时由活动对象(activation object,缩写为AO)扮演VO的角色。<br>
活动对象是在进入函数上下文时刻被创建的，它通过函数的arguments属性初始化。arguments属性的值是Arguments对象。<br>
Arguments对象是活动对象的一个属性，它包括如下属性：<br>
callee — 指向当前函数的引用<br>
length — 真正传递的参数个数<br>
properties-indexes (字符串类型的整数) 属性的值就是函数的参数值(按参数列表从左到右排列)。 properties-indexes内部元素的个数等于arguments.length. properties-indexes 的值和实际传递进来的参数之间是共享的。<br>
以下是例子供理解：</p>
<pre><code>function foo(x, y, z) {
  // 声明的函数参数数量arguments (x, y, z)
  alert(foo.length); // 3
  // 真正传进来的参数个数(only x, y)
  alert(arguments.length); // 2
  // 参数的callee是函数自身
  alert(arguments.callee === foo); // true
  // 参数共享
  alert(x === arguments[0]); // true
  alert(x); // 10
  arguments[0] = 20;
  alert(x); // 20
  x = 30;
  alert(arguments[0]); // 30
  // 不过，没有传进来的参数z，和参数的第3个索引值是不共享的
  z = 40;
  alert(arguments[2]); // undefined
  arguments[2] = 50;
  alert(z); // 40
}
foo(10, 20);
</code></pre>
<p>两种变量对象已经解释完毕<br>
执行上下文创建阶段结束后 现在在执行上下文之前 VO的值含有：<br>
函数的所有形参(如果我们是在函数执行上下文中)<br>
由名称和对应值组成的一个变量对象的属性被创建；没有传递对应参数的话，那么由名称和undefined值组成的一种变量对象的属性也将被创建。<br>
所有函数声明(FunctionDeclaration, FD)<br>
由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建；如果变量对象已经存在相同名称的属性，则完全替换这个属性。<br>
所有变量声明(var, VariableDeclaration)<br>
由名称和对应值（undefined）组成一个变量对象的属性被创建；如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。<br>
可以来看这个例子</p>
<pre><code>function outerFun (arg1, arg2) {
    var outerV1 = 1
    var outerV2 = 2
    function innerFun1 () {
        var innerV1 = 3;
        var innerV2 = 4;
        console.log('i am innerFun1...')
    }
    function innerFun2 () {
        console.log('i am innerFun2...')
    }
    function outerV2 () {
        return 'i am outerV2'
    }
}
outerFun(1);
</code></pre>
<p>此处VO内容有三部分</p>
<ol>
<li>arguments属性 即Arguments 对象<br>
arguments:  Arguments Object<br>
这个对象属性  有<br>
arguments.length: 1 只传值了一个<br>
arguments.callee: outerFun的地址<br>
arguments[@@iterator]<br>
返回一个新的Array 迭代器 对象，该对象包含参数中每个索引的值。</li>
<li>所有变量的声明：此时为undefinde<br>
outerV1: undefined<br>
outerV2: undefined</li>
<li>所有函数的声明： 值为该函数所在内存的地址<br>
innerFun1 : innerFun1 reference  （ innerFun1 引用）<br>
innerFun2 : innerFun2 reference  （ innerFun2 引用）</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node 框架 Express学习]]></title>
        <id>https://huyifu.github.io/post/node-kuang-jia-express-xue-xi/</id>
        <link href="https://huyifu.github.io/post/node-kuang-jia-express-xue-xi/">
        </link>
        <updated>2021-03-30T08:43:15.000Z</updated>
        <summary type="html"><![CDATA[<p>Express框架<br>
提供简洁路由定义方式<br>
对HTTP请求参数 简化处理<br>
支持模板引擎<br>
提供中间件 控制HTTP请求</p>
<p>中间件<br>
一堆方法 接收请求 对请求响应  也可以交给下一个中间件继续处理<br>
两个部分组成  中间件方法和请求处理函数<br>
app.get('请求路径','处理函数')   方法express提供</p>
<p>简单的应用 将.get请求分成两个中间件进行处理<br>
next 将请求的控制权交给下一个中间件<br>
//引入express框架</p>
<pre><code>const express = require('express');
const app = express();//创建服务器
app.get('/',(req,res,next) =&gt;{
    req.addname= &quot;在请求头添加的属性&quot;;
    next();
});
app.get('/',(req,res) =&gt;{
    res.send(req.addname);
});
app.listen(3000);
console.log(&quot;网站启动 端口3000&quot;);
</code></pre>
<p>app.use   匹配所有的请求  因此如果后续要继续处理 要使用next()<br>
app.use('/某一个请求路径',(req,res,next))  可以指定某一个路径匹配的所有请求</p>
<p>中间件的应用<br>
1对页面访问某路径进行登录拦截  1 use 进行判断 如果已经登录则放行next() 2 没有登录 返回没有登录的信息<br>
2 页面维护  直接放最前面进行拦截   不设置路径则匹配所有路径<br>
3 自定义404路径  放在最后面没有匹配的路径  不设置路径则匹配所有路径</p>
<p>错误处理中间件</p>
<pre><code> thorow new Error('发生了错误'); 
app.use( (err,req,res,next) =&gt;{
	//err 为手动抛出的Error对象
	res.status(500).send(err.message); //返回 err对象的错误信息属性
} )
</code></pre>
<p>捕获异步代码错误<br>
try catch块</p>
<pre><code>const promisify = require('util').promisify
const NewreadFile = promisify('fs.readFile') 改造读取文件成返回promise对象的异步函数
app.get('/', async (req,res,next) =&gt;{
     try {
   await NewreadFile('.');
}
catch (ex){
   next(ex);	
}
})
</code></pre>
<p>捕获到错误的话 程序不会因为这个错误而终止进行—— 健壮性</p>
<p>构建模块化路由<br>
express下的Router 路由对象<br>
为这个路由对象可以匹配请求路径</p>
<pre><code>const express = require('express');
const app = express();
//创建路由对象
const home = express.Router();
app.use('/home',home);
//创建二级路由
home.use('/index',(req,res)=&gt;{
    res.send(&quot;二级路由 /home/index！&quot;);
})
app.listen(3000);
</code></pre>
<p>其中home模块 可以写在别的js中 通过导入导出进行模块的使用<br>
在主index.js 中<br>
这样创建二级路由<br>
const xx = require('')<br>
app.use('/xx路径', xx);</p>
<p>Get参数<br>
在请求函数中 使用req.query 自动将请求参数获取并转化成对象的形式<br>
app.get('/index',(req,res)=&gt;{<br>
res.send(req.query);<br>
});</p>
<p>Post 请求参数获取<br>
使用借助第三包 body-parser<br>
const bodyParser = require('body-parser');<br>
而且需要在最开始对这个模块进行配置 默认<br>
app.use(bodyParser.urlencoded( { extended: false} );</p>
<pre><code>const bodyParser = require('body-parser');
const express = require('express');
const app = express();
app.use(bodyParser.urlencoded({ extended: false}));
app.post('/index',(req,res)=&gt;{
    res.send(req.body);
});
app.listen(3000);
</code></pre>
<p>路由参数 路由里面附带数据 ——  get传递和获取参数的另一种方式</p>
]]></summary>
        <content type="html"><![CDATA[<p>Express框架<br>
提供简洁路由定义方式<br>
对HTTP请求参数 简化处理<br>
支持模板引擎<br>
提供中间件 控制HTTP请求</p>
<p>中间件<br>
一堆方法 接收请求 对请求响应  也可以交给下一个中间件继续处理<br>
两个部分组成  中间件方法和请求处理函数<br>
app.get('请求路径','处理函数')   方法express提供</p>
<p>简单的应用 将.get请求分成两个中间件进行处理<br>
next 将请求的控制权交给下一个中间件<br>
//引入express框架</p>
<pre><code>const express = require('express');
const app = express();//创建服务器
app.get('/',(req,res,next) =&gt;{
    req.addname= &quot;在请求头添加的属性&quot;;
    next();
});
app.get('/',(req,res) =&gt;{
    res.send(req.addname);
});
app.listen(3000);
console.log(&quot;网站启动 端口3000&quot;);
</code></pre>
<p>app.use   匹配所有的请求  因此如果后续要继续处理 要使用next()<br>
app.use('/某一个请求路径',(req,res,next))  可以指定某一个路径匹配的所有请求</p>
<p>中间件的应用<br>
1对页面访问某路径进行登录拦截  1 use 进行判断 如果已经登录则放行next() 2 没有登录 返回没有登录的信息<br>
2 页面维护  直接放最前面进行拦截   不设置路径则匹配所有路径<br>
3 自定义404路径  放在最后面没有匹配的路径  不设置路径则匹配所有路径</p>
<p>错误处理中间件</p>
<pre><code> thorow new Error('发生了错误'); 
app.use( (err,req,res,next) =&gt;{
	//err 为手动抛出的Error对象
	res.status(500).send(err.message); //返回 err对象的错误信息属性
} )
</code></pre>
<p>捕获异步代码错误<br>
try catch块</p>
<pre><code>const promisify = require('util').promisify
const NewreadFile = promisify('fs.readFile') 改造读取文件成返回promise对象的异步函数
app.get('/', async (req,res,next) =&gt;{
     try {
   await NewreadFile('.');
}
catch (ex){
   next(ex);	
}
})
</code></pre>
<p>捕获到错误的话 程序不会因为这个错误而终止进行—— 健壮性</p>
<p>构建模块化路由<br>
express下的Router 路由对象<br>
为这个路由对象可以匹配请求路径</p>
<pre><code>const express = require('express');
const app = express();
//创建路由对象
const home = express.Router();
app.use('/home',home);
//创建二级路由
home.use('/index',(req,res)=&gt;{
    res.send(&quot;二级路由 /home/index！&quot;);
})
app.listen(3000);
</code></pre>
<p>其中home模块 可以写在别的js中 通过导入导出进行模块的使用<br>
在主index.js 中<br>
这样创建二级路由<br>
const xx = require('')<br>
app.use('/xx路径', xx);</p>
<p>Get参数<br>
在请求函数中 使用req.query 自动将请求参数获取并转化成对象的形式<br>
app.get('/index',(req,res)=&gt;{<br>
res.send(req.query);<br>
});</p>
<p>Post 请求参数获取<br>
使用借助第三包 body-parser<br>
const bodyParser = require('body-parser');<br>
而且需要在最开始对这个模块进行配置 默认<br>
app.use(bodyParser.urlencoded( { extended: false} );</p>
<pre><code>const bodyParser = require('body-parser');
const express = require('express');
const app = express();
app.use(bodyParser.urlencoded({ extended: false}));
app.post('/index',(req,res)=&gt;{
    res.send(req.body);
});
app.listen(3000);
</code></pre>
<p>路由参数 路由里面附带数据 ——  get传递和获取参数的另一种方式</p>
<!-- more -->
<p>app.get('/find/:id/:name', (req,res)=&gt; console.log(req.params)😉 req.params为对象<br>
tip：客户端访问find路径时必须带有id name参数 否则无法获取请求<br>
http://localhost:3000/find/111/name<br>
{id:111,name:name}</p>
<p>访问静态文件<br>
使用express.static 方法<br>
app.use(express.static('放置静态文件的目录'))  客户端可直接通过路径访问到</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS 箭头函数]]></title>
        <id>https://huyifu.github.io/post/js-jian-tou-han-shu/</id>
        <link href="https://huyifu.github.io/post/js-jian-tou-han-shu/">
        </link>
        <updated>2021-03-29T12:09:30.000Z</updated>
        <content type="html"><![CDATA[<p>引言：在学习nonde 回调函数时频繁出现箭头函数 此文来详细了解箭头函数深入的特性。</p>
<h3 id="箭头函数表达式的语法比函数表达式更简洁并且没有自己的thisargumentssupernewtarget-箭头函数表达式更适用于那些本来需要匿名函数的地方并且它不能用作构造函数-因为构造函数用this指向新构建的对象">箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super，new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。因为构造函数用this指向新构建的对象。</h3>
<p>五种基础表达形式</p>
<pre><code>1. (param1, param2, …, paramN) =&gt; { statements } //标准 参数1~N 执行statements
2. (param1, param2, …, paramN) =&gt; expression // 只有一个表达式 相当于 相当于：(param1, param2, …, paramN) =&gt;{ return expression; }
3. singleParam =&gt; { statements }  //只有一个参数可不写（）
4. () =&gt;{statements}  //无参数使用（） 应用1.
5.() =&gt; expression   //无参数使用（） 应用2.
</code></pre>
<p>此外还有其他表达形式</p>
<pre><code>//加括号的函数体返回对象字面量表达式：
params =&gt; ({foo: bar})
//支持剩余参数和默认参数
(param1, param2, ...rest) =&gt; { statements }
(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; {
statements }
//同样支持参数列表解构
let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c;
f();  // 6
</code></pre>
<h3 id="箭头函数没有单独的this箭头函数不会创建自己的this它只会从自己的作用域链的上一层继承this">箭头函数没有单独的this，箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。</h3>
<p>以下为用this时候出现的一些问题</p>
<pre><code>function Counter() {
  this.num = 0;
  this.timer = setInterval(function add() {
    this.num++;
    console.log(this.num);
  }, 1000);
}
var a = new Counter();
</code></pre>
<p>输出：<br>
NaN<br>
.. 1s一个<br>
this指向window对象  this理解另一篇进行深入探讨  此处出现问题<br>
当使用箭头函数改写</p>
<pre><code>function Counter() {
  this.num = 0;
  this.timer = setInterval(()=&gt;{
      this.num++;
      console.log(num);
  },1000)
}
var a = new Counter();
</code></pre>
<p>预期输出<br>
1<br>
2<br>
..</p>
<h3 id="通过call-apply调用箭头函数">通过call、apply调用箭头函数</h3>
<p>由于箭头函数没有自己的this指针，通过call()、apply()方法调用时，第一个参数会被忽略。（箭头函数中若用了this，这个this指向包裹箭头函数的第一个普通函数的 this。）</p>
<h3 id="不绑定arguments">不绑定arguments</h3>
<p>大多数情况下，使用剩余参数是相较于arguments对象的更好选择。</p>
<h3 id="箭头函数没有prototype属性">箭头函数没有prototype属性。</h3>
<pre><code>var Foo = () =&gt; {};
console.log(Foo.prototype); // undefined
</code></pre>
<h3 id="闭包">闭包</h3>
<pre><code>// 标准的闭包函数
function A(){
      var i=0;
      return function b(){
              return (++i);
      };
};
var v=A();
v();    //1
v();    //2
//箭头函数体的闭包（ i=0 是默认参数）
var Add = (i=0) =&gt; {return (() =&gt; (++i) )};
var v = Add();
v();           //1
v();           //2
//因为仅有一个返回，return 及括号（）也可以省略
var Add = (i=0)=&gt; ()=&gt; (++i);
</code></pre>
<h2 id="总结">总结：</h2>
<ul>
<li>没有 this</li>
<li>没有 arguments</li>
<li>不能使用 new 进行调用</li>
<li>它们也没有 super</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS 回调函数]]></title>
        <id>https://huyifu.github.io/post/js-hui-diao-han-shu/</id>
        <link href="https://huyifu.github.io/post/js-hui-diao-han-shu/">
        </link>
        <updated>2021-03-29T11:06:11.000Z</updated>
        <content type="html"><![CDATA[<p>引言：在学习node中，开始大量的使用异步化编程 而异步函数与回调函数有着紧密的连接 此文来深入回调函数</p>
<h2 id="回调函数概念">回调函数概念</h2>
<p>A callback is a function that is passed as an argument to another function and is executed after its parent function has completed.</p>
<h3 id="四级水平翻译-回调函数是一个通过作为另一个函数的参数并且在父函数已经完成后执行的函数">四级水平翻译： 回调函数是一个通过作为另一个函数的参数并且在父函数已经完成后执行的函数🤧</h3>
<h3 id="自己的话来讲-回调函数是一个函数的参数并且在这个函数里可以调用这个回调函数至于这个回调函数什么时候调用-有的是可以指定调用-有的是满足特殊要求后系统自动调用">自己的话来讲： 回调函数是一个函数的参数，并且在这个函数里可以调用这个回调函数，至于这个回调函数什么时候调用 有的是可以指定调用 有的是满足特殊要求后系统自动调用</h3>
<p>以下是回调函数的一些例子 每个都有相关的理解<br>
例子一</p>
<pre><code>function addSqua(num1, num2, callback){
  var sum = num1 + num2;
  return callback(sum);
}
function squa(num){
  return num*num;
}
let num = addSqua(1, 2, squa);    
console.log(num);
//输出9  
</code></pre>
<p>以上定义了 addSqua函数 第三个参数是callback  调用时候将squa函数传值给了callback<br>
并且 在return前调用了squa函数   其实是两层函数<br>
例子二</p>
<pre><code>function doSomething(msg, callback){
    alert(msg);
    if(typeof callback == &quot;function&quot;) 
    callback();
 } 
doSomething(&quot;回调函数&quot;, function(){
    alert(&quot;匿名函数实现回调!&quot;);
 }); 
</code></pre>
<p>声明函数 doSomething  参数msg  第二个参数callback的声明在下面调用 doSometing 的时候进行<br>
这个匿名函数传值给了callback</p>
<p>例子三</p>
<pre><code>setTimeout({
  console.log(”代码执行区“);
},ms)
</code></pre>
<p>setTimeout 典型的回调函数 此处在ms毫秒后 系统自动调用这个函数 当然第一个参数也可以写成指向要执行函数的变量. 前两个例子都是自己调用.<br>
例子四（看Promise时候极具迷惑 三行代码分析起来却很多...）</p>
<pre><code>function delay(ms) {
  return new Promise(resolve =&gt; setTimeout(resolve, ms));
}
delay(3000).then(() =&gt; alert('runs after 3 seconds'));
</code></pre>
<p>delay声明区<br>
首先声明delay函数带一个参数ms<br>
返回的是一个Promise对象 其中声明了第一个参数resolve 调用setTiomeout函数的声明<br>
接收两个参数 一个是延迟ms后发生发生的resolve函数 另一个指定延迟时间<br>
delay调用区<br>
调用delay(3000) 此时将3000传值给ms 返回一个Promise对象 .then() 开始调用setTimeout函数<br>
3s后  resolve回调函数执行  箭头函数调用  无参数执行alert('runs after 3 seconds')；</p>
<h2 id="总结">总结：</h2>
<p>回调函数不是立即执行 它需要在合适的时间进行执行  与异步的理念吻合  异步：同时执行多个工作 但不能确定每个工作具体完成的时间，一般是完成单个工作后采用回调函数来进行下一步的处理。<br>
以上在主函数中的声明中 回调函数以参数形式存在  至于回调函数具体是什么函数 看传入的值来决定<br>
而它的被调用执行的时机 1自己调用 2系统调用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Es6中的Promise对象 ]]></title>
        <id>https://huyifu.github.io/post/es6-zhong-de-promise-dui-xiang/</id>
        <link href="https://huyifu.github.io/post/es6-zhong-de-promise-dui-xiang/">
        </link>
        <updated>2021-03-29T11:05:19.000Z</updated>
        <content type="html"><![CDATA[<p>引言：JS异步解决 使用Promise对象<br>
之前学习了node 大量使用Promise 虽然会用了 但是对其了解还不够深入<br>
Promise 是一个对象，它代表了一个异步操作的最终完成或者失败。</p>
<h2 id="promise对象的使用">Promise对象的使用</h2>
<p>创建：<br>
Promise 对象的构造器（constructor）语法如下：<br>
let promise = new Promise(function(resolve, reject) {<br>
//进行工作<br>
//在工作完成后进行 这个Promise对象的resolve or reject<br>
});<br>
//现在可以可以进行对这个对象的使用了<br>
这个对象有三种方法调用 then catch finally</p>
<ol>
<li>then<br>
最重要最基础的一个就是 .then。<br>
语法如下：<br>
promise.then(<br>
function(result) { /* handle a successful result <em>/ },<br>
function(error) { /</em> handle an error */ }<br>
);<br>
如果用箭头函数也可以写成<br>
promise.then(res =&gt; console.log('成功结果'), err =&gt; console.log('失败对象'));<br>
.then 的第一个参数是一个函数，该函数将在 promise resolved 后运行并接收结果。<br>
.then 的第二个参数也是一个函数，该函数将在 promise rejected 后运行并接收 error。<br>
一个实例</li>
</ol>
<pre><code>function delay(ms) {
  return new Promise(resolve =&gt; setTimeout(resolve, ms));
}
delay(3000).then(() =&gt; alert('runs after 3 seconds'));
</code></pre>
<p>返回promise对象的延时函数<br>
delay声明中 resolve作为参数  直接执行setTimeout函数 并在ms毫秒后执行 resolve()；</p>
<h2 id="promise声明的对象会立即执行">（promise声明的对象会立即执行）</h2>
<p>在delay函数开始调用 然后3s后执行回调函数  无参  即执行 function(){alert('runs after 3 seconds'));}<br>
2. catch<br>
如果我们只对 error 感兴趣，那么我们可以使用 null 作为第一个参数：.then(null, errorHandlingFunction)。或者我们也可以使用 .catch(errorHandlingFunction)<br>
promise.catch(err)<br>
let promise = new Promise((resolve, reject) =&gt; {<br>
setTimeout(() =&gt; reject(new Error(&quot;Whoops!&quot;)), 1000);<br>
});<br>
// .catch(f) 与 promise.then(null, f) 一样<br>
promise.catch(alert); // 1 秒后显示 &quot;Error: Whoops!&quot;<br>
3. finnally<br>
finally 处理程序（handler）没有参数。在 finally 中，我们不知道 promise 是否成功。没关系，因为我们的任务通常是执行“常规”的定稿程序（finalizing procedures）。<br>
finally 处理程序将结果和 error 传递给下一个处理程序。</p>
<p>由 new Promise 构造器返回的 promise 对象具有以下内部属性：<br>
state — 最初是 &quot;pending&quot;，然后在 resolve 被调用时变为 &quot;fulfilled&quot;，或者在 reject 被调用时变为 &quot;rejected&quot;。<br>
result — 最初是 undefined，然后在 resolve(value) 被调用时变为 value，或者在 reject(error) 被调用时变为 error。</p>
<h3 id="promise的state属性一旦确定无法修改">Promise的state属性一旦确定无法修改</h3>
<p>solve(1);<br>
reject(2);//此时无效</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS this的指向]]></title>
        <id>https://huyifu.github.io/post/js-this-de-zhi-xiang/</id>
        <link href="https://huyifu.github.io/post/js-this-de-zhi-xiang/">
        </link>
        <updated>2021-03-29T01:11:11.000Z</updated>
        <content type="html"><![CDATA[<p>引言：目前查找资料和自己整理的this的理解<br>
this的由来：函数可以在不同环境下执行，this用来指代当前的执行环境，因此this就是执行环境<br>
那么执行环境是什么呢</p>
<h2 id="执行环境execution-context也称为执行上下文是javascript中最为重要的一个概念-执行环境定义了变量或函数有权访问的其它数据决定了各自的行为-当javascript代码执行的时候会进入不同的执行环境这些不同的执行环境就构成了执行环境栈">执行环境(Execution Context，也称为&quot;执行上下文&quot;)是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其它数据，决定了各自的行为。当JavaScript代码执行的时候，会进入不同的执行环境，这些不同的执行环境就构成了执行环境栈。</h2>
<p>JavaScript中主要存在三种执行环境:</p>
<p>全局执行环境<br>
　　　JavaScript代码执行的默认环境。通常被默认为window对象，所有的全局变量和函数都作为window对象的属性和方法存在。当执行环境中的代码执行完毕之后，执行环境被销毁，其中的所有变量和函数也随之销毁。对于全局执行环境来说，当关闭网页或浏览器时，该环境被销毁。</p>
<p>函数执行环境<br>
　　   当执行一个JavaScript函数时，函数的环境被推入环境栈中，执行完毕之后，栈将执行环境推出，将控制权转交给之前的执行环境。</p>
<p>Eval环境<br>
　　　执行eval()函数时创建。</p>
<p>执行上下文是以栈（一种 LIFO 的数据结构）的方式被存放起来的，我们称之为执行上下文栈（Execution Context Stack）。<br>
在 JavaScript 代码开始执行时，首先进入全局环境，此时全局上下文被创建并入栈，之后当调用函数时则进入相应的函数环境，此时相应函数上下文被创建并入栈，当处于栈顶的执行上下文代码执行完毕后，则会将其出栈。</p>
<h3 id="执行环境属性重要的三种-变量对象-作用域链-this指向">执行环境属性重要的三种： 变量对象， 作用域链， this指向</h3>
<h2 id="this只在调用时才能确定this指向的对象在声明时无法确定">this只在调用时才能确定this指向的对象，在声明时无法确定</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MongoDB]]></title>
        <id>https://huyifu.github.io/post/mongodb/</id>
        <link href="https://huyifu.github.io/post/mongodb/">
        </link>
        <updated>2021-03-29T01:10:48.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js 学习]]></title>
        <id>https://huyifu.github.io/post/nodejs-xue-xi/</id>
        <link href="https://huyifu.github.io/post/nodejs-xue-xi/">
        </link>
        <updated>2021-03-22T13:24:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="node三部分">node三部分</h1>
<p>引入required模块：我们可以使用require指令来载入Node.js模块。</p>
<p>创建服务器：服务器可以监听客户端的请求，类似于Apache 、Nginx等HTTP服务器。</p>
<p>接收请求与响应请求：服务器很容易创建，客户端可以使用浏览器或终端发送HTTP请求，服务器接收请求后返回响应数据。</p>
<h3 id="nvm和npm关系">nvm和npm关系</h3>
<p>nvm：nodejs 版本管理工具。<br>
也就是说：一个 nvm 可以管理很多 node 版本和 npm 版本。<br>
nodejs：在项目开发时的所需要的代码库<br>
npm：nodejs 包管理工具。<br>
在安装的 nodejs 的时候，npm 也会跟着一起安装，它是包管理工具。<br>
nvm 管理 nodejs 和 npm 的版本<br>
npm 可以管理 nodejs 的第三方插件</p>
<h3 id="使用模块化开发的原因">使用模块化开发的原因</h3>
<p>JS 文件依赖问题<br>
a.js-&gt;b.js-&gt;c.js  c.js无法单独使用<br>
命名冲突<br>
c.js num=1 a.js num=2</p>
<h3 id="node-模块化开发规范">node 模块化开发规范</h3>
<p>一个js文件就是一个模块 模块内部变量函数默认情况下在外部无法得到<br>
模块内部使用exports对象进行成员导出 使用require方法导入其他模块<br>
另一种方式<br>
module.exports.version = version;<br>
exports是module.exports的别名 指向引用关系 指向同一个导出对象<br>
当指向不同对象 导出对象是moudule.exports对象</p>
<h2 id="系统模块">系统模块</h2>
<p>系统模块 node运行环境提供的API<br>
PS: 回调函数 （err，doc） =&gt; {}   如果成功 err是NULL 不成功是一个对象</p>
<h3 id="fs-文件操作">fs 文件操作</h3>
<p>引入 const fs = require('fs')<br>
读取<br>
fs.readFile('文件路径/文件名称',['文件编码'],callback); 【】代表可选参数<br>
写入<br>
fs.writeFile('文件路径/文件名称','数据',callback);</p>
<h3 id="path-路径操作">path 路径操作</h3>
<p>路径拼接 不同操作系统路径分隔符不统一 windows / \  Linux /<br>
const path = require('path')<br>
const finalPath = path.join('a','b','c')<br>
finalPath -&gt;  a\b\c<br>
结合<br>
const fs = require('fs');<br>
const path = require('path');<br>
TIP 使用__dirname  （两个下划线）<br>
当前js文件当前文件夹的绝对路径<br>
因此路径可以表示为  path.join(__dirname, 'xx.js')   join 会自动添加<br>
fs.readFile()</p>
<p>TIP:</p>
<h3 id="相对路径和绝对路径">相对路径和绝对路径</h3>
<p>绝大部分使用绝对路径   因为相对路径是相对的命令行工具的当前工作目录<br>
读取文件 设置文件路径 绝对路径</p>
<h2 id="第三方模块">第三方模块</h2>
<p>三方模块 两种形式<br>
以js文件存在 提供API接口  -&gt; 具体功能<br>
命令行工具形式存在 辅助项目开发</p>
<h3 id="三方模块-nodemon-命令行工具">三方模块 nodemon 命令行工具</h3>
<p>cmd 可以执行 但是vs终端无法执行？？</p>
<h3 id="nrm">nrm</h3>
<p>npm下载地址切换工具<br>
npm默认下载地址 npmjs.com<br>
国内下载地址服务器同步 npm.taobao.org<br>
查询下载地址列表 nrm ls<br>
切换npm下载地址 nrm use 下载地址</p>
<p>TIP:<br>
clear 清屏   上箭头 上一次命令 下箭头 下一次命令<br>
ctrl C 终止操作</p>
<h3 id="gulp">Gulp</h3>
<p>基于node平台开发的前端构建工具<br>
将机械化操作变成命令</p>
<p>功能<br>
HTML CSS JS 压缩合并<br>
语法转换 es6 ..less..<br>
修改文件浏览器自动刷新<br>
使用</p>
<p>1使用npm install gulp下载gulp库文件<br>
（命令行当前文件下配置好了 node_modules文件夹和package-lock.json)<br>
2在项目根目录下建立gulpfile.js文件<br>
（命名固定了）<br>
3重构项目的文件夹结构 src目录放置源代码文件 dist目录放置构建后文件<br>
4在gulpfile.js文件中编写任务.<br>
5在命令行工具中执行gulp任务</p>
<p>方法<br>
gulp.src() 获取任务要处理的文件<br>
gulp.dest() 输出文件<br>
gulp.task() 建立gulp任务<br>
gulp.watch() 监考文件变化</p>
<p>gulp.task('任务的名称',() =&gt;{<br>
}) ;</p>
<p>gulp-cli  命名行工具<br>
执行任务  项目根目录 gulp 任务名称<br>
Gulp插件<br>
gulp-htmlmin: html 文件压缩</p>
<pre><code>// html压缩任务
// html文件中代码的压缩操作
// 抽取html文件中的公共代码
const htmlmin = require('gulp-htmlmin');
const fileinClude = require('gulp-file-include');
gulp.task('htmlmin',()=&gt;{
    //*. 所有的文件
    gulp.src('./src/*.html')
        //抽取放入common文件夹
        .pipe(fileinClude())
       //压缩
      .pipe(htmlmin({collapseWhitespace: true}))
      .pipe(gulp.dest('dist'));
});
</code></pre>
<p>@@include('./common/head.html')<br>
将公共代码引入进来<br>
gulp-csso :压缩css<br>
gulp-file-include 公共文件包含<br>
.....</p>
<p>构建任务<br>
TIP 当任务取名为defult gulp命令直接运行 gulp defult<br>
gulp.task('defult',['任务一名字','任务二名字'],....)</p>
<h3 id="packagejson">package.json</h3>
<p>（1）node_modules文件夹的问题<br>
文件夹以及文件过多过碎，当我们将项目整体拷贝给别人的时候,，传输速度会很慢很慢.<br>
复杂的模块依赖关系需要被记录，确保模块的版本和当前保持一致，否则会导致当前项目运行报错<br>
（2）package.json文件的作用<br>
项目描述文件，记录了当前项目信息，例如项目名称、版本、作者、github地址、当前项目依赖了哪些第三方模块等。<br>
使用npm init -y命令生成。  -y全填默认值<br>
（3）项目依赖<br>
在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖<br>
使用npm install 包名命令下载的文件会默认被添加到 package.json 文件的 dependencies 字段中<br>
{<br>
&quot;dependencies&quot;: {<br>
&quot;jquery&quot;: &quot;^3.3.1“<br>
}<br>
}<br>
（4）开发依赖<br>
在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖<br>
使用npm install 包名 --save-dev命令将包添加到package.json文件的devDependencies字段中<br>
{<br>
&quot;devDependencies&quot;: {<br>
&quot;gulp&quot;: &quot;^3.9.1“<br>
}<br>
}<br>
5）package-lock.json文件的作用<br>
锁定包的版本，确保再次下载时不会因为包版本不同而产生问题<br>
加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作</p>
<p>npm install --production 只安装项目依赖<br>
npm install  全部</p>
<p>TIP：<br>
package.json<br>
&quot;scripts&quot;:{<br>
&quot;命令别名&quot; : &quot;命令代码&quot;<br>
}<br>
cmd 敲入 npm run 别名   即可运行</p>
<h3 id="node-模块加载机制">Node 模块加载机制</h3>
<ol>
<li>当模块拥有路径但没有后缀<br>
require方法根据模块路径查找模块，如果是完整路径，直接引入模块。<br>
如果模块后缀省略，先找同名JS文件再找同名JS文件夹<br>
如果找到了同名文件夹，找文件夹中的index.js<br>
如果文件夹中没有index.js就会去当前文件夹中的package.json文件中查找main选项中的入口文件<br>
如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到</li>
<li>模块没有路径没有后缀<br>
假设它是系统模块<br>
node_moudules文件中<br>
同名js文件<br>
同名文件夹<br>
同名文件夹里面的index.js<br>
package.json main选项的入口文件</li>
</ol>
<h3 id="node全局对象">Node全局对象</h3>
<p>Node全局对象 global  ——浏览器全局对象 window<br>
global对象里 有<br>
console.log<br>
setTimeout<br>
...<br>
等等方法</p>
<h2 id="服务器开发">服务器开发</h2>
<p>###（1）服务器端基础概念<br>
网站的组成<br>
网站应用程序主要分为两大部分：客户端和服务器端。<br>
客户端：在浏览器中运行的部分，就是用户看到并与之交互的界面程序。使用HTML、CSS、JavaScript构建。<br>
服务器端：在服务器中运行的部分，负责存储数据和处理应用逻辑。</p>
<p>Node网站服务器</p>
<p>能够提供网站访问服务的机器就是网站服务器，它能够接收客户端的请求，能够对请求做出响应。</p>
<p>IP地址<br>
互联网中设备的唯一标识。<br>
IP是Internet Protocol Address的简写，代表互联网协议地址.</p>
<p>域名<br>
由于IP地址难于记忆，所以产生了域名的概念，所谓域名就是平时上网所使用的网址。<br>
http://www.baidu.com =&gt; http://124.165.219.100/ (乱写的)<br>
虽然在地址栏中输入的是网址, 但是最终还是会将域名转换为ip才能访问到指定的网站服务器。</p>
<p>端口<br>
端口是计算机与外界通讯交流的出口，用来区分服务器电脑中提供的不同的服务。</p>
<p>URL</p>
<p>统一资源定位符，又叫URL（Uniform Resource Locator），是专为标识Internet网上资源位置而设的一种编址方式，我们平时所说的网页地址指的即是URL。</p>
<p>URL的组成</p>
<p>传输协议://服务器IP或域名:端口/资源所在位置标识<br>
tip：默认80端口 没有设置端口自动设置80端口<br>
https://me.csdn.net/wuyxinu</p>
<p>http：超文本传输协议，提供了一种发布和接收HTML页面的方法。</p>
<p>开发过程中客户端和服务器端说明</p>
<p>在开发阶段，客户端和服务器端使用同一台电脑，即开发人员电脑。</p>
<p>本机域名：localhost<br>
本地IP ：127.0.0.1<br>
###（2）创建web服务器</p>
<p>// 引用系统模块<br>
const http = require('http');<br>
// 创建web服务器<br>
const app = http.createServer();<br>
// 当客户端发送请求的时候<br>
req 请求  res返回</p>
<pre><code> app.on('request', (req, res) =&gt; {
        //  响应
       res.end('&lt;h1&gt;hi, user&lt;/h1&gt;');
 });
  // 监听3000端口
 app.listen(3000);
 console.log('服务器已启动，监听3000端口，请访问 localhost:3000')
</code></pre>
<h3 id="3http协议">(3)HTTP协议</h3>
<p>（1）HTTP协议的概念<br>
超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）规定了如何从网站服务器传输超文本到本地浏览器，它基于客户端服务器架构工作，是客户端（用户）和服务器端（网站）请求和应答的标准。<br>
（2）报文<br>
在HTTP请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，并且要遵守规定好的格式。<br>
（3）请求报文<br>
TIP: 控制台 Network 可以看到请求和相应相关信息<br>
请求方式 （Request Method）<br>
GET 请求数据<br>
POST 发送数据<br>
请求地址 （Request URL）<br>
app.on('request', (req, res) =&gt; {<br>
req.headers  // 获取请求报文<br>
req.url      // 获取请求地址<br>
req.method   // 获取请求方法<br>
});<br>
locallhost 请求<br>
favicon.ico 请求<br>
都为GET方式  浏览器访问服务器 GET默认方式请求？</p>
<pre><code> &lt;form method=&quot;post&quot; action=&quot;http://localhost:3000&quot;&gt;
    &lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt;
    &lt;/form&gt;
</code></pre>
<p>设置 post请求 提交跳转到服务器 方式POST</p>
<p>req.url  /index  /homepage ....<br>
同时/favicon.ico 请求地址同样存在<br>
默认 url '/'</p>
<p>req.headers['accept']  取值accept<br>
(4)响应报文<br>
1 HTTP状态码<br>
200 请求成功<br>
404 请求的资源没有被找到<br>
500 服务器端有错误<br>
400 客户端请求语法有错误</p>
<p>response.writeHead(statusCode, [reasonPhrase], [headers])<br>
2 内容类型<br>
text/html<br>
text/css<br>
application/javascript<br>
..</p>
<p>GET 请求参数<br>
http://localhost:3000/?name=xx&amp;age=20  （键值对）</p>
<p>内置模块<br>
url 模块 用于处理url地址<br>
url.parse（url地址，true）;<br>
parse对象里<br>
query 查询参数对象<br>
pathname  路径字符串<br>
第一个参数 解析的地址 第二个参数 是否将查询参数解析成对象<br>
应用 let params = url.parse(req.url,true).query;<br>
http://localhost:3000/?name=xx&amp;age=20  （键值对）<br>
此时 params {name:xx,age:20} 对象<br>
可以取得值 params.name  -&gt;xx ...</p>
<h3 id="server_getjs">server_GET.js</h3>
<pre><code>let http = require('http');
let url = require('url');
//创建服务器
let server = http.createServer();
//为server对象添加监听事件 事件名称为request
server.on('request', (req,res) =&gt;{
    res.writeHead(200,{
        'content-type': 'text/html;charset=utf8'
    });
    //测试http://localhost:3000/homepage?name=huyifu&amp;age=20
  let {query, pathname} = url.parse(req.url,true);
  console.log(query);
  console.log(pathname);
  //parse已经被弃用但是还能使用
  /* 还没学习怎么使用 url需要完整IP地址
  const NewUrl = new URL(req.url);
    console.log(req.url);*/
   if (pathname == '/homepage' || pathname == '/')
    res.end('&lt;h1&gt;欢迎来到首页&lt;/h1&gt;');
    else if (pathname == '/personPage')
    res.end('&lt;h1&gt;欢迎来到个人主页&lt;/h1&gt;');
    else
    res.end('Not Found');
});
//监听3000端口
server.listen(3000);
console.log('服务器已启动，监听3000端口，本地可访问');
</code></pre>
<p>使用模块querystring  处理请求参数模块<br>
方法 querystring.parse 转为对象</p>
<p>post 参数是通过事件的方式接受的<br>
POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。<br>
data 当请求参数传递时候触发data事件<br>
end 当参数传递完成时候触发end事件</p>
<h3 id="server_postjs">server_POST.js</h3>
<pre><code>let http = require('http');
let url = require('url');
let querystring = require('querystring');
var util = require('util');
http.createServer(function(req, res){
    // 定义了一个post变量，用于暂存请求体的信息
    var post = '';     
    // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中
    req.on('data', function(chunk){    
        post += chunk;
    });
    // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。
    req.on('end', function(){    
        post = querystring.parse(post);
        res.end(util.inspect(post));
    });
    res.writeHead(200, {'Content-Type': 'text/html; charset=utf8'});
    res.end('ok!');
}).listen(3000);

console.log('服务器已启动，监听3000端口，本地可访问');
</code></pre>
<p>静态资源<br>
服务器不需要任何处理的资源  像图片 文件等等<br>
动态资源<br>
相同的请求地址不同的响应资源  需要服务器进行处理</p>
<h2 id="静态资源的获取">静态资源的获取</h2>
<p>app.js<br>
需要做到在服务器上请求路径后响应对应的静态资源访问 如一个html页面<br>
（项目根目录下放public文件 里面是css js html文件）<br>
如访问http://localhost:3000/index.html?key=0<br>
1 引入模块<br>
http 服务器 url 服务器上获取请求路径 path 对路径进行处理 fs 对文件读取来进行 服务器的响应-&gt;指html文件<br>
2 服务器对象设置监听对象 在回调函数里进行处理<br>
3 获取请求路径<br>
4 将请求路径转变为服务器访问静态资源的绝对路径<br>
5 通过这个绝对路径进行读取 并响应</p>
<p>遇到的问题<br>
1.所有中文乱码2.所有图片加载不出 3需要将url '/'也导进首页 '/index'<br>
原因：<br>
编码格式没设置 导致乱码<br>
在响应的html中 进行对css .js .jpj .png 等等资源再次请求    但是文件格式没有设置 导致错误<br>
解决方法<br>
在html  head区加入<meta charset="UTF-8"><br>
引入mime模块 对请求路径解析出资源的格式 并根据格式在res.writeHead上添加上状态码和格式<br>
mime.getType(path)<br>
对url进行parse成对象 里面的pathname进行分析<br>
pathname = pathname =='/' ? '/index.html' : pathname  三元运算符进行转换</p>
<p>app.js 代码如下</p>
<pre><code>const http = require('http');
const url = require('url');
const path = require('path');
const fs = require('fs');
const mime = require('mime');
var times=1;
/*1 引入模块
http 服务器 url 服务器上获取请求路径 path 对路径进行处理 fs 对文件读取来进行 服务器的响应-&gt;指html文件
2 服务器对象设置监听对象 在回调函数里进行处理
3 获取请求路径 
4 将请求路径转变为服务器访问静态资源的绝对路径
5 通过这个绝对路径进行读取 并响应*/
//http://localhost:3000/index.html?key=0
let app = http.createServer();
app.on('request',(req,res)=&gt;{
    let request_path = req.url;
    let url_obj=url.parse(request_path,true);
    let pathname=url_obj.pathname;
    pathname = pathname  == '/' ? '/index.html':pathname;
    let realPath = path.join(__dirname,'仿写小米',pathname);
    let type = mime.getType(realPath);
    console.log(times+'次:'+realPath);
    times++;
    fs.readFile(realPath,(err,data)=&gt;{
         if (err) //若读取失败err是一个对象 bool值为true
         {
            console.log('文件读取失败,错误是：'+err);
            res.writeHead(404,{'content-type':'text/html;charset=utf8'});
            res.end('文件读取失败');
            return;
         }
            res.writeHead(200,{'content-type': type});
            res.end(data);
            //console.log(data);
    });
   //res.end('ok');
});
app.listen(3000);
console.log(&quot;服务器已经启动 3000端口&quot;);
</code></pre>
<h2 id="同步与异步">同步与异步</h2>
<p>同步API 只有当API执行完成后 才能继续执行下一个API<br>
异步API 当前API的执行不会阻塞后续代码的执行</p>
<pre><code>function getMsg (callback){
    setTimeout(function(){
        callback({
            msg: 'hello'
        });
    },2000);
}
getMsg(function (data){
    console.log(data);
});
</code></pre>
<p>1 定义了getMsg函数 参数为callback函数<br>
2 在下处执行了getMsg函数 参数为函数 声明了callback函数<br>
3 在getMsg函数里 异步API setTimeout函数 2s后执行<br>
4 此时调用callback函数 参数为一个对象<br>
5 执行callback函数 console.log 这个对象 属性msg值为 'hello'字符串</p>
<h3 id="代码执行顺序">代码执行顺序</h3>
<p>分为 同步代码执行区 异步代码执行区 回调函数队列<br>
首先会将代码分区域  同步代码执行和回调函数都是自上而下先后<br>
异步代码执行区则无法确定顺序 先执行完成的先进行回调函数执行<br>
执行顺序为先执行完所有的同步代码<br>
然后进行异步代码执行区    之后执行回调函数<br>
经典例子</p>
<pre><code>for (var i = 0; i &lt;= 5; i++) {
    setTimeout(function() {
        console.log( i );
    }, i*1000);
     console.log( ' i : ' , i );
}
console.log( i );
</code></pre>
<p>输出<br>
i:0<br>
i:1<br>
i:2<br>
i:3<br>
i:4<br>
i:5<br>
6<br>
6 0s后 之上都是瞬间输出<br>
6 1s后<br>
6 2s后<br>
6 3s后<br>
6 4s后<br>
6 5s后</p>
<p>此时还有闭包问题 将var改成let</p>
<pre><code>for (var i = 0; i &lt;= 5; i++) {
    setTimeout(function() {
        console.log( i );
    }, i*1000);
     console.log( ' i : ' , i );
}
console.log( i );
</code></pre>
<p>输出<br>
i:0<br>
i:1<br>
i:2<br>
i:3<br>
i:4<br>
i:5<br>
6<br>
0 0s后 之上都是瞬间输出<br>
1 1s后<br>
2 2s后<br>
3 3s后<br>
4 4s后<br>
5 5s后<br>
这两个例子 可以根据上文的代码执行顺序进行解释<br>
先执行同步区所有代码 然后进行异步区代码</p>
<p>node js 异步API<br>
fs<br>
事件处理函数<br>
...</p>
<p>异步API后面代码的执行依赖当前异步API的执行结果 需要确定好执行顺序<br>
在回调函数里调用回调函数<br>
导致问题 回调地狱  不易维护修改</p>
<h2 id="解决方法-promise">解决方法 Promise</h2>
<h2 id="promisejs">Promise.js</h2>
<pre><code>const fs = require('fs');
/* 回调地狱 不易维护
fs.readFile('./1.text','utf8',(err,result1)=&gt;{
     console.log(result1);
     fs.readFile('./2.text','utf8',(err,result2)=&gt;{
        console.log(result2);
        fs.readFile('./3.text','utf8',(err,result3)=&gt;{
            console.log(result3);
       });
   });
});
*/
function file1(){
    return new Promise((resolve,reject)=&gt;{
        fs.readFile('./1.text','utf8',(err,result)=&gt;{
             if (err)
             reject(err);
             else
             resolve(result);
        })
    });
}
function file2(){
    return new Promise((resolve,reject)=&gt;{
        fs.readFile('./2.text','utf8',(err,result)=&gt;{
             if (err)
             reject(err);
             else
             resolve(result);
        })
    });
}
function file3(){
    return new Promise((resolve,reject)=&gt;{
        fs.readFile('./3.text','utf8',(err,result)=&gt;{
             if (err)
             reject(err);
             else
             resolve(result);
        })
    });
}
//函数return promise对象 可以链式调用
file1().then((r1)=&gt;{
    console.log(r1);
    return file2(); //此时return f2的promise对象
})
.then((r2)=&gt;{
    console.log(r2);
    return file3();
})
.then((r3)=&gt;{
    console.log(r3);
})
</code></pre>
<h2 id="异步函数-在promise对象上进行封装">异步函数 在promise对象上进行封装</h2>
<p>是终极解决方案 使得异步代码写成同步的形式 让代码不再有回调函数的嵌套<br>
async<br>
1 在普通函数定义的前面加上async关键字 普通函数就变成了异步函数<br>
2 异步函数默认的返回值是promise对象<br>
3 异步函数内部使用throw进行错误抛出  return返回data (resolve)<br>
4 then方法   catch方法<br>
await<br>
1 只能写在异步函数中<br>
2 await promise  后面只能写promise对象<br>
3 await 暂停异步函数向下执行 直到promise对象返回结果</p>
<p>应用  fs.readFile 由于无法返回promise对象 无法使用await关键字<br>
解决方法<br>
引入util 模块的promisify方法<br>
此方法接收 需要改造的函数作为参数<br>
const fs = require('fs');<br>
const util = require('util');<br>
const NewReadFile = (util.promisify)(fs.readFile); //改造返回新的方法</p>
<h2 id="asyncfunctionjs">asyncFunction.js</h2>
<pre><code>/*async function fn(){
    return 'success and DATA:...';
    throw 'error!';
}
fn().then(data=&gt;console.log(data));
//fn().catch(error=&gt;console.log(error));
*/
const fs = require('fs');
const util = require('util');
const NewReadFile = (util.promisify)(fs.readFile); //改造返回新的方法

async function run(){
  let r1= await NewReadFile('./1.text','utf8');
  let r2= await NewReadFile('./2.text','utf8');
  let r3= await NewReadFile('./3.text','utf8');
  console.log(r1);
  console.log(r2);
  console.log(r3);
}
run();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[伪类与伪元素]]></title>
        <id>https://huyifu.github.io/post/wei-lei-yu-wei-yuan-su/</id>
        <link href="https://huyifu.github.io/post/wei-lei-yu-wei-yuan-su/">
        </link>
        <updated>2021-03-18T13:50:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是伪类">什么是伪类？</h2>
<p>——伪类是选择器的一种，它用于选择处于特定状态的元素。<br>
伪类有很多种，它们都为我们提供了基于其特征无法访问或难以访问的特征来定位元素的方法。<br>
伪类的类型：</p>
<ol>
<li>动态伪类<br>
:hover :focus :link  :visited</li>
<li>基于状态的伪类<br>
:checked可以应用于复选框（）<br>
:fullscreen 定位当前以全屏模式显示的任何元素</li>
<li>结构伪类<br>
:first-child，:last-child</li>
<li>杂项伪类<br>
:not(x)选择与选择器x不匹配的元素   :lang(language-code) 选择哪些内容采用特定语言的元素</li>
</ol>
<h2 id="什么是伪元素">什么是伪元素？</h2>
<p>——伪元素用于创建一些不在文档树中的元素，并为其添加样式。<br>
ps:利用伪元素插入的dom 在dom结构中是看不到的 不过可以在css 中看到<br>
::before/::after/::first-letter/::first-line/::selection ........</p>
<h2 id="区别">区别：</h2>
<p>伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素。<br>
有没有创建一个文档树之外的元素。</p>
<p>元素指的是 HTML 文档中的标签，它是 DOM 树的一部分。而类是元素上的一个属性，是人为规定的当前元素的一个类别。</p>
<h1 id="总结">总结：</h1>
<ul>
<li>伪类与被标记的元素是一种包含关系，类添加到了这个元素上</li>
<li>伪元素与被被标记的元素是同级关系，css最终会作用在这个创造出的伪元素的位置上</li>
</ul>
]]></content>
    </entry>
</feed>
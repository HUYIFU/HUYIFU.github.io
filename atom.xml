<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://huyifu.github.io</id>
    <title>古月的blog</title>
    <updated>2021-06-30T03:26:07.094Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://huyifu.github.io"/>
    <link rel="self" href="https://huyifu.github.io/atom.xml"/>
    <subtitle>Nothing for nothing
</subtitle>
    <logo>https://huyifu.github.io/images/avatar.png</logo>
    <icon>https://huyifu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 古月的blog</rights>
    <entry>
        <title type="html"><![CDATA[Node开发Web Server博客 Node.js+Express+Koa2+MySQL]]></title>
        <id>https://huyifu.github.io/post/node-kai-fa-web-server-bo-ke-nodejsexpresskoa2mysql/</id>
        <link href="https://huyifu.github.io/post/node-kai-fa-web-server-bo-ke-nodejsexpresskoa2mysql/">
        </link>
        <updated>2021-06-23T02:22:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="day1">Day1 :</h2>
<p>项目需求，功能了解</p>
<p>node复习：</p>
<ul>
<li>使用loadsh   ——Lodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库。<br>
内置模块化方法  （array number ....)</li>
<li>debugge</li>
<li>common js   是个模块规范</li>
</ul>
<p>从输入url到显示页面的过程:<br>
DNS 域名解析   建立TCP连接(三次握手)  发送http请求 (浏览器)<br>
server 接收到http请求  处理 返回 (服务端)<br>
client接收并处理  (浏览器)</p>
<p>get请求  (querystring) ?value1=xx&amp;value2=yy<br>
将查询字符串转化成对象   querysring.parse(url.split(&quot;?&quot;)[1]) ;</p>
<pre><code>querystring.parse(&quot;name=whitemu&amp;sex=man&amp;sex=women&quot;)
{
	name: 'whitemu',
	sex: ['man', 'women']
}

</code></pre>
<p>直接访问浏览器是get请求  (一般浏览器还会自动发一个头标的get请求)</p>
<p>post 请求<br>
安装postman  - 能模拟http请求的工具软件，支持get/post两种方式，对于程序开发人员来说提供了一种测试工具。 Postman能够保留用户的请求历史记录，方便下次请求时直接查找。</p>
<p>综合test  (使用postman测试)</p>
<pre><code>const http = require('http');
const querystring = require('querystring');
const server = http.createServer((req,res)=&gt;{
   const method = req.method;
   const url = req.url;
   const path = url.split(&quot;?&quot;)[0]  //分割出的url接口路径
   const query = querystring.parse(url.split(&quot;?&quot;)[1])  //查询字符串转成对象
   //设置返回格式 JSON
   res.setHeader('Content-type','application/json');
    //返回数据
    const resData = {
        method,
        url,
        path,
        query
    }
    if (method === 'GET'){
        res.end(JSON.stringify(resData)) //JSON是对象的字符串表达形式 这里stringfy化成字符串
    }
    if (method === 'POST'){
        let postData = '';
        req.on('data',chunk =&gt;{
            postData += chunk.toString();  //化成字符串
        })
        req.on('end',()=&gt;{
            resData.postData = postData;//赋予对象属性
            res.end(JSON.stringify(resData));
        })
    }
});
server.listen(8000);
console.log(&quot;挂载8000端口&quot;);

</code></pre>
<h1 id="原生node开始搭建项目">原生node开始搭建项目</h1>
<figure data-type="image" tabindex="1"><img src="https://huyifu.github.io/post-images/1624437988815.png" alt="" loading="lazy"></figure>
<h2 id="服务器搭建">服务器搭建</h2>
<p>接口设计：<br>
<img src="https://huyifu.github.io/post-images/1624438074970.png" alt="" loading="lazy"><br>
六个接口 五个为博客接口  一个为用户接口</p>
<p>目前的目录：<br>
<img src="https://huyifu.github.io/post-images/1624446539796.png" alt="" loading="lazy"><br>
bin文件夹下的 www.js</p>
<pre><code>//跟server技术相关的服务器代码  
const http = require('http');
const PORT = 8000; //端口
const serverHandle = require('../app.js');//引入服务器处理函数
const server = http.createServer(serverHandle);
server.listen(PORT);
console.log(&quot;挂载在&quot;+PORT+&quot;端口&quot;);
</code></pre>
<p>tip:  这里引入了app模块  在app模块里填写了具体的服务器回调函数<br>
app.js</p>
<pre><code>const handleBlogRouter = require('./src/router/blog');
const handleUserRouter = require('./src/router/user');

const serverHandle = (req,res) =&gt;{
    //(相关配置) 设置返回格式 JSON
    res.setHeader('Content-type', 'application/jaon');
    //处理blog路由
    const blogData = handleBlogRouter(req,res);
    if (blogData){
        //返回博客数据
        res.end(JSON.stringify(blogData));
        return;
    }
    //处理user路由
    const userData = handleUserRouter(req,res);
    if (userData){
        //返回user数据
        res.end(JSON.stringify(userData));
        return;
    }
    //未命中路由
    res.end(&quot;404!&quot;);
}
module.exports = serverHandle //暴露服务器处理函数
</code></pre>
<p>路由初始化 ，（blog路由接口和user路由接口）<br>
blog.js  user.js</p>
<h3 id="定义数据模型类">定义数据模型（类）</h3>
<p>新建文件夹model  resModel.js</p>
<pre><code>class BaseModel{ //class  js原型对象的语法糖
    constructor(data,message){
        if (typeof data === 'string'){ //此处兼容只传一个参
            this.message = data;
            data = null;
            message = null;
        }
        if (data){
            this.data = data;//增添data属性
        }
        if (message){
            this.message = message;//增添message属性
        }
    }
}
class SuccessModel extends BaseModel{
    constructor(data,message){
         super(data,message); //调用父类构造
         this.errno = 0;
    }
}
class ErrorModel extends BaseModel{
    constructor(data,message){
        super(data,message);
        this.errno = -1;
    }
}
module.exports = {
    SuccessModel,
    ErrorModel
}
</code></pre>
<h3 id="controller调控数据-包含所有数据相关操作">controller调控数据 包含所有数据相关操作</h3>
<p>新建对应js  blog.js  user.js</p>
<h2 id="day2-继续开发路由">Day2： 继续开发路由</h2>
<p>当前文件目录：<br>
<img src="https://huyifu.github.io/post-images/1624515858537.png" alt="" loading="lazy"><br>
目前是四层路由关系<br>
www.js（入口)  -&gt;app.js(服务器相关设置) -&gt;router blog.js/user.js(分路由处理) -&gt;controller  blog.js/user.js(数据相关操作)</p>
<h3 id="路由已经初步全部开发完成未接数据库">路由已经初步全部开发完成（未接数据库）</h3>
<p>例子：   localhost:8000/api/blog/new   新增博客接口<br>
首先app.js 处理post数据和分路由到blog.js  (用到promise先处理chunk数据流)</p>
<pre><code>const handleBlogRouter = require('./src/router/blog');
const handleUserRouter = require('./src/router/user');
const querystring = require('querystring');
//处理 postData
const getPostData = (req) =&gt; {
    const promise = new Promise((resolve, reject) =&gt; {
        //生成promise实例
        if (req.method !== 'POST') {
            resolve({});//resolve空对象 不表示出错
            return;
        }
        if (req.headers['content-type'] !== 'application/json') {
            resolve({});
            return;
        }
        let postData = '';
        req.on('data', chunk =&gt; {
            postData += chunk.toString();
        });
        req.on('end', () =&gt; {
            if (!postData) {
                resolve({});//空数据 resolve空对象
                return;
            }
            resolve(JSON.parse(postData));//resolve 数据对象
        })
    })
    return promise;
}

const serverHandle = (req, res) =&gt; {
    //(相关配置) 设置返回格式 JSON
    res.setHeader('Content-type', 'application/jaon');

    //获取path 
    const url = req.url;
    req.path = url.split('?')[0];

    //解析query
    req.query = querystring.parse(url.split('?')[1]);

    //处理postData(promise对象resolve后执行then)
    getPostData(req).then(postData =&gt; {
        req.body = postData; //将postData放入请求体中
        //处理blog路由
        const blogData = handleBlogRouter(req, res);
        if (blogData) {
            //返回博客数据
            res.end(JSON.stringify(blogData));
            return;
        }
        //处理user路由
        const userData = handleUserRouter(req, res);
        if (userData) {
            //返回user数据
            res.end(JSON.stringify(userData));
            return;
        }
        //未命中路由
        res.end(&quot;404!&quot;);
    })

}
module.exports = serverHandle //暴露服务器处理函数

</code></pre>
<p>router 下的blog.js  （引入newBlog 和 SuccessModel )</p>
<pre><code> //新增一篇博客
    if (method === 'POST' &amp;&amp; req.path === '/api/blog/new'){
        const newData = newBlog(req.body);
        return new SuccessModel(newData);
    }
</code></pre>
<p>controller 下的blog.js （暴露newBlog)</p>
<pre><code>const newBlog = (blogData = {}) =&gt;{
    console.log('newBlogData',blogData);
    return {
        id:3
    }
}
</code></pre>
<p>tip: 假数据  其中箭头函数里设置默认参数 blogData undefined就为 {} 空对象  返回</p>
<h2 id="day3-连接数据库">Day3： 连接数据库</h2>
<h3 id="数据储存">数据储存</h3>
<p>mysql 的下载和安装配置<br>
建立数据库 myblog<br>
建表<br>
1 user表<br>
id int  PK<br>
username  varchar(20)<br>
password varchar(20)<br>
realname varchar(10)<br>
2 blogs 表<br>
id int PK<br>
title varchar(50)<br>
content longtext    -&gt;长内容<br>
creatime bigint(20) -&gt;13位毫秒 bigint<br>
author varchar(20)<br>
3</p>
<p>删除 修改表 ....</p>
<p>表的curd（增删改查） 简单示例</p>
<ul>
<li>增加一行<br>
use myblog;<br>
insert into users(username,’password‘,realname) values('lisi','123','李四');</li>
<li>查询<br>
use myblog<br>
select  * from users;</li>
<li>修改<br>
use myblog<br>
update users  set   realname = 'xx' where username = 'lisi'</li>
<li>删除 （可以delete 这里用修改state字段表示 是否有效 )<br>
use myblog<br>
update users set state = 0;</li>
</ul>
<h3 id="开发环境dev-生产环境pro">开发环境dev   生产环境pro</h3>
<p>dev环境：开发环境，外部用户无法访问，开发人员使用，版本变动很大。<br>
pro环境：生产环境，面向外部用户的环境，连接上互联网即可访问的正式环境。</p>
<p>在package.json中配置 dev 和pro</p>
<pre><code>&quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;dev&quot;: &quot;cross-env NODE_ENV=dev nodemon ./bin/www.js&quot;,
    &quot;prd&quot;: &quot;cross-env NODE_ENV=production nodemon ./bin/www.js&quot;
  },
</code></pre>
<p>安装好cross-env      运行时敲入 npm run dev<br>
自动运行 nodemon ./bin/www.js 并存入NODE_ENV中<br>
在node中，有全局变量process表示的是当前的node进程。<br>
process.env包含着关于系统环境的信息，但是process.env中并不存在NODE_ENV这个东西<br>
。NODE_ENV是一个用户自定义的变量，在webpack中它的用途是判断生产环境或开发环境。</p>
<h4 id="引用时-processenvnode_env-来表示是开发环境还是生产环境">引用时 process.env.NODE_ENV 来表示是开发环境还是生产环境</h4>
<p>config db.js 代码如下</p>
<pre><code>const env = process.env.NODE_ENV //环境参数

let MYSQL_CONFIG;
if (env === 'dev'){
  //开发环境
  MYSQL_CONFIG = {
      host: 'localhost',
      user: 'root',
      password: '1234',
      port: '3306',
      database: 'myblog'
  }
}
if (env === 'production'){
  //生产环境
}

module.exports = {
    MYSQL_CONFIG
}
</code></pre>
<h2 id="day4-实现路由数据库">Day4 : 实现路由（数据库）</h2>
<h4 id="在实际调用数据库操作时引用统一的数据库配置以及sql语句执行">在实际调用数据库操作时引用统一的数据库配置以及sql语句执行</h4>
<p>db 下 mysql代码如下：</p>
<pre><code>const mysql = require('mysql');
const { MYSQL_CONFIG} = require('../config/db'); //引入配置文件
//创建连接对象
const con = mysql.createConnection(MYSQL_CONFIG);
//开始连接
con.connect();

//统一执行sql的函数
function exec(sql){
    const promise = new Promise((resolve,reject)=&gt;{
        con.query(sql, (err,result) =&gt;{
            if (err){
                reject(err);
                return;
            }
            resolve(result);
        })
    })
    return promise;
}
module.exports = {
    exec
}
</code></pre>
<p>调用exec 返回promise对象</p>
<p>例子： /api/blog/detail GET</p>
<h3 id="从内到外分析-promise对象的调用-四层">从内到外分析 Promise对象的调用 四层</h3>
<p>一   mysql    exec函数<br>
数据库连接对象con 执行查询<br>
外层包了个promise对象  在查询成功时resolve成功回调结果<br>
失败时reject失败回调结果<br>
函数返回这个promise</p>
<p>二   controller/blog   getDetail</p>
<pre><code>const getDetail = (id)=&gt;{
    const sql = `select * from blogs where id='${id}'`
    return exec(sql).then(result =&gt;{
        return result[0];
    })
}
</code></pre>
<p>在exec函数resolve时 调用then方法<br>
tip： 这里return 这个返回结果对象  自动生成一个已经resolve这个返回结果的promise对象<br>
再次把这个新生成的promise对象作为函数返回值返回出去</p>
<p>三   router/blog</p>
<pre><code> //获取一篇博客的内容
    if (method === 'GET' &amp;&amp; req.path ==='/api/blog/detail'){
        // const Detaildata = getDetail(id);
        // return new SuccessModel(Detaildata);
        const result  = getDetail(id);
        return result.then(data =&gt;{
            return new SuccessModel(data);
        })
    }
</code></pre>
<p>得到 getDetail 返回的promise对象（当生成时候就已经resolve） then方法  返回SuccessModel 实例（就是对象）  同第二层  返回一个新的promise对象（已经resolve这个实例对象）</p>
<p>四  app</p>
<pre><code>const blogResult = handleBlogRouter(req,res);
        if (blogResult){
            //返回的promise对象 resolve后自动调用then
            blogResult.then(blogData =&gt;{
                res.end(JSON.stringify(blogData));
            })
            return;
        }
</code></pre>
<p>then 方法 服务器返回JSON格式的字符串数据</p>
<h2 id="day5">Day5 :</h2>
<p>全部接口以及实现<br>
app.js</p>
<pre><code>const handleBlogRouter = require('./src/router/blog');
const handleUserRouter = require('./src/router/user');
const querystring = require('querystring');
//处理 postData
const getPostData = (req) =&gt; {
    const promise = new Promise((resolve, reject) =&gt; {
        //生成promise实例
        if (req.method !== 'POST') {
            resolve({});//resolve空对象 不表示出错
            return;
        }
        if (req.headers['content-type'] !== 'application/json') {
            resolve({});
            return;
        }
        let postData = '';
        req.on('data', chunk =&gt; {
            postData += chunk.toString();
        });
        req.on('end', () =&gt; {
            if (!postData) {
                resolve({});//空数据 resolve空对象
                return;
            }
            resolve(JSON.parse(postData));//resolve 数据对象
        })
    })
    return promise;
}

const serverHandle = (req, res) =&gt; {
    //(相关配置) 设置返回格式 JSON
    res.setHeader('Content-type', 'application/jaon');

    //获取path 
    const url = req.url;
    req.path = url.split('?')[0];

    //解析query
    req.query = querystring.parse(url.split('?')[1]);

    //处理postData(promise对象resolve后执行then)
    getPostData(req).then(postData =&gt; {
        req.body = postData; //将postData放入请求体中
        //处理blog路由
        const blogResult = handleBlogRouter(req,res);
        if (blogResult){
            //返回的promise对象 resolve后自动调用then
            blogResult.then(blogData =&gt;{
                res.end(JSON.stringify(blogData));
            })
            return;
        }
        //处理user路由
        const userResult = handleUserRouter(req,res);
        if (userResult){
            userResult.then(userData=&gt;{
                res.end(JSON.stringify(userData));
            })
            return;
        }
        //未命中路由
        res.end(&quot;404!&quot;);
    })

}
module.exports = serverHandle //暴露服务器处理函数
</code></pre>
<p>router/user.js</p>
<pre><code>const  {loginCheck} = require('../controller/user');
const { SuccessModel, ErrorModel } = require('../model/resModel');
const handleUserRouter = (req,res)=&gt;{
    const method = req.method ;
    //用户登录
    if (method === 'POST' &amp;&amp; req.path ==='/api/user/login'){
       const {username  , password} = req.body;
       const result = loginCheck(username,password);
       return result.then(data =&gt;{
           if (data.username)
           return new SuccessModel();
           else
           return new ErrorModel(&quot;登录失败&quot;);
       })
    }
}
module.exports = handleUserRouter;
</code></pre>
<p>controller/user.js</p>
<pre><code>const {exec}= require('../db/mysql');
const loginCheck = (username,password)=&gt;{
    let sql=`
    select username from users where username = '${username}' and password = '${password}'
    `;
    return exec(sql).then(rows =&gt;{
        console.log(rows);
        return rows[0] || {};
    });
}
module.exports = {
    loginCheck
};
</code></pre>
<p>router/blog.js</p>
<pre><code>const {getList,
     getDetail,
      newBlog,
      updateBlog,
      deleteBlog
} = require('../controller/blog')
const {SuccessModel, ErrorModel} = require('../model/resModel');
const handleBlogRouter = (req, res)=&gt;{
    const method = req.method;
    const id = req.query.id;
    //获取博客列表
    if (method === 'GET' &amp;&amp; req.path ==='/api/blog/list'){
        const author = req.query.author || '';
        const keyword = req.query.keyword || '';
        // const listData = getList(author,keyword);
        // return  new  SuccessModel(listData);
        const result = getList(author,keyword);
        return result.then(listData =&gt;{
            return new SuccessModel(listData);
        })
    }
    //获取一篇博客的内容
    if (method === 'GET' &amp;&amp; req.path ==='/api/blog/detail'){
        // const Detaildata = getDetail(id);
        // return new SuccessModel(Detaildata);
        const result  = getDetail(id);
        return result.then(data =&gt;{
            return new SuccessModel(data);
        })
    }
    //新增一篇博客
    if (method === 'POST' &amp;&amp; req.path === '/api/blog/new'){
        const author = 'zhangsan';
        req.body.author = author;
        const result = newBlog(req.body);
      return  result.then(data =&gt;{
           return new SuccessModel(data);
        })
    }
    //更新一篇博客
    if (method === 'POST' &amp;&amp; req.path === '/api/blog/update'){
        const result = updateBlog(id,req.body);
        return result.then(bool=&gt;{
            if (bool)
            return new SuccessModel();
            else
            return new ErrorModel(&quot;更新博客失败&quot;);
        })
    }
    //删除一篇博客
    if (method === 'POST' &amp;&amp; req.path === '/api/blog/delete'){
        const author = &quot;zhangsan&quot;;
        const result = deleteBlog(id,author,req.body);
        return result.then(bool =&gt;{
            if (bool)
            return new SuccessModel();
            else
            return new ErrorModel(&quot;删除博客失败&quot;);
        })
    }
}
module.exports = handleBlogRouter; //暴露博客接口函数
</code></pre>
<p>controller/blog.js</p>
<pre><code>const { exec } = require('../db/mysql')

const getList = (author, keyword) =&gt; {
    let sql = `select * from blogs where 1=1 `
    if (author) {
        sql += `and author='${author}'`
    }
    if (keyword) {
        sql += `and title like '%${keyword}%'`
    }
    sql += `order by creatTime desc`;
    return exec(sql);
}

const getDetail = (id) =&gt; {
    const sql = `select * from blogs where id='${id}'`
    return exec(sql).then(result =&gt; {
        return result[0];
    })
}
const newBlog = (blogData = {}) =&gt; {
    //返回新增博客插入到数据库的id
    const title = blogData.title;
    const content = blogData.content;
    const author = blogData.author;
    const creatTime = Date.now();
    const sql = `insert into blogs (title, content, creatTime, author) values(
        '${title}','${content}',${creatTime},'${author}')`;
    return  exec(sql).then(insertData =&gt;{
          return {
              id: insertData.insertId
          }
    })
}
const updateBlog = (id, blogData = {}) =&gt; {
    // console.log('updateBlog', blogData);
    // return true;
    const title = blogData.title;
    const content = blogData.content;
    const sql = `
    update blogs set title ='${title}',content = '${content}' where id = ${id}
    `;
    return exec(sql).then(updateData =&gt;{
        if (updateData.affectedRows&gt;0){
            return true;
        }
        return false;
    })
}
const deleteBlog = (id,author,blogData = {}) =&gt; {
    const sql = `delete from blogs where id='${id}' and author='${author}'`;
    return exec(sql).then(deleteData =&gt;{
        if (deleteData.affectedRows&gt;0){
            return true;
        }
        return false;
    })
}
module.exports = {
    getList,
    getDetail,
    newBlog,
    updateBlog,
    deleteBlog
}
</code></pre>
<h2 id="登录">登录</h2>
<p>核心： 登录校验&amp;登录信息储存</p>
<ul>
<li>cookie,session</li>
<li>session 写入 redis</li>
<li>开发登录功能 和前端联调（用nginx 反向代理）</li>
</ul>
<h3 id="cookie">cookie</h3>
<ul>
<li>存储在浏览器的一段字符串(最大5kb)</li>
<li>跨域不共享</li>
<li>格式：k1=v1;k2=v2; 存储结构化数据</li>
<li>每次发送http请求 将请求域的cookie 一起发送给server</li>
<li>server 可以修改cookie并返回给浏览器</li>
<li>浏览器也可以通过js修改cookie（有限制）</li>
</ul>
<h4 id="浏览器查看cookie三种方式">浏览器查看cookie三种方式</h4>
<ol>
<li>控制台查看浏览器发送的请求中带有cookie （返回带有服务器修改后的cookie）</li>
<li>Storage中的Cookies</li>
<li>js document.cookie 查看</li>
</ol>
<p>js不能删除浏览器cookie<br>
可以通过 赋值累加自定义cookie<br>
document.cookie = &quot;k1=v1&quot;;</p>
<h2 id="day6">Day6 :</h2>
<p>cookie 做限制</p>
<pre><code>if (method === 'GET' &amp;&amp; req.path ==='/api/user/login'){
        const {username  , password} = req.query;
        const result = login(username,password);
        return result.then(data =&gt;{
           if (data.username)
            {
                //操作cookie
                res.setHeader('Set-Cookie',`username=${data.username}; path=/; httpOnly; expires=${getCookieExpires()}`)
                return new SuccessModel();
            }
            
            return new ErrorModel(&quot;登录失败&quot;);
        })
     }
</code></pre>
<p>tip:<br>
path设置根路由  对域名的所有接口都生效（登录之后生成cookie）<br>
httpOnly 设置之后客户端查看不到cookie并且不能修改  提供安全性<br>
expires 设置过期时间</p>
<h3 id="session">session</h3>
<p>都放cookie的弊端：<br>
暴露敏感信息（username）...<br>
<img src="https://huyifu.github.io/post-images/1625023401214.png" alt="" loading="lazy"><br>
解决：<br>
cookie放userId  server端放置对应username</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Jquery+node+socket.io 实现聊天室]]></title>
        <id>https://huyifu.github.io/post/jquerynodesocketio-shi-xian-liao-tian-shi/</id>
        <link href="https://huyifu.github.io/post/jquerynodesocketio-shi-xian-liao-tian-shi/">
        </link>
        <updated>2021-05-29T11:42:04.000Z</updated>
        <content type="html"><![CDATA[<p>引言：做计网实验大作业，要求实现即时多人聊天，基础功能为文字传输，（图片等文件之后补充）<br>
打算用jquery node socket.io 实现  (正好学下jquery使用)</p>
<h3 id="客户端">客户端</h3>
<h3 id="服务器端">服务器端</h3>
<h4 id="jquery学习">jquery学习</h4>
<p>引入:</p>
<pre><code>&lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;
</code></pre>
<p>语法:<br>
$(selector).action()<br>
jquery语句使用以上语法  selector表示所选取的元素    action表示对元素采取的动作</p>
<pre><code>$(this).hide() - 隐藏当前元素
$(&quot;p&quot;).hide() - 隐藏所有 &lt;p&gt; 元素
$(&quot;p.test&quot;).hide() - 隐藏所有 class=&quot;test&quot; 的 &lt;p&gt; 元素
$(&quot;#test&quot;).hide() - 隐藏 id=&quot;test&quot; 的元素
</code></pre>
<p>tip:  使用文档就绪事件  jq入口函数</p>
<pre><code>$(document).ready(function(){
   // 开始写 jQuery 代码...
});
</code></pre>
<p>这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。</p>
<p>选取元素的方式:(此处选择几个常用的)</p>
<ul>
<li>$(&quot;p.pclass&quot;) 选取class为pclass的p元素</li>
<li>$(&quot;p.first&quot;) 第一个p元素</li>
<li>$(&quot;ul li:first-child&quot;) 每个ul的第一个li元素</li>
<li>$(&quot;[href]&quot;) 带有href属性的元素</li>
</ul>
<p>获得内容<br>
text() - 设置或返回所选元素的文本内容<br>
html() - 设置或返回所选元素的内容（包括 HTML 标记）<br>
val() - 设置或返回表单字段的值<br>
attr() -设置或返回属性内容的值</p>
<p>设置值:<br>
text(要设置的值)<br>
html  val  同上<br>
attr(&quot;要设置的属性的名称,像href&quot;,&quot;要设置的值,像www.hao123.com&quot;)</p>
<p>拥有回调函数:<br>
回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。</p>
<pre><code>$(&quot;#btn1&quot;).click(function(){
    $(&quot;#test1&quot;).text(function(i,origText){
        return &quot;旧文本: &quot; + origText + &quot; 新文本: Hello world! (index: &quot; + i + &quot;)&quot;; 
    });
});
</code></pre>
<p>聊天内容要使用到的:  创建元素  添加元素 删除元素</p>
<pre><code>function appendText(){
    var txt1=&quot;&lt;p&gt;文本-1。&lt;/p&gt;&quot;;              // 使用 HTML 标签创建文本
    var txt2=$(&quot;&lt;p&gt;&lt;/p&gt;&quot;).text(&quot;文本-2。&quot;);  // 使用 jQuery 创建文本
    var txt3=document.createElement(&quot;p&quot;);
    txt3.innerHTML=&quot;文本-3。&quot;;               // 使用 DOM 创建文本 text with DOM
    $(&quot;body&quot;).append(txt1,txt2,txt3);        // 追加新元素
}
</code></pre>
<p>append 加至所选元素的开头<br>
prepend加至所选元素的末尾</p>
<p>删除:<br>
remove() - 删除被选元素（及其子元素）<br>
empty() - 从被选元素中删除子元素</p>
<p>添加类</p>
<p>css方法 ——设置或者返回所选元素的样式属性<br>
返回属性(只返回第一个匹配)<br>
$(&quot;p&quot;).css(&quot;height&quot;)<br>
tip： 返回首个匹配元素的height值</p>
<p>设置属性(所有匹配)<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi mathvariant="normal">&quot;</mi><mi>p</mi><mi mathvariant="normal">&quot;</mi><mo>)</mo><mi mathvariant="normal">.</mi><mi>c</mi><mi>s</mi><mi>s</mi><mo>(</mo><mi mathvariant="normal">&quot;</mi><mi>b</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>g</mi><mi>r</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mo>−</mo><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mi mathvariant="normal">&quot;</mi><mo separator="true">,</mo><mi mathvariant="normal">&quot;</mi><mi>y</mi><mi>e</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>w</mi><mi mathvariant="normal">&quot;</mi><mo>)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">(&quot;p&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;);
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">&quot;</span><span class="mord mathdefault">p</span><span class="mord">&quot;</span><span class="mclose">)</span><span class="mord">.</span><span class="mord mathdefault">c</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord">&quot;</span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">&quot;</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">&quot;</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">&quot;</span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span>(&quot;p&quot;).css({&quot;background-color&quot;:&quot;yellow&quot;,&quot;font-size&quot;:&quot;200%&quot;});</p>
<p>jquery尺寸<br>
width() 返回content width<br>
innnerWidth() padding + content width<br>
outerWidth() border + padding + content  width<br>
outerWidth() magin + border  + padding + content width<br>
tip:  box-sizing: 两种值<br>
content-box  是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。<br>
border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px，那么这100px会包含它的border和padding，内容区的实际宽度是width减去(border + padding)的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。</p>
<p>jquery 遍历</p>
<ul>
<li>向上遍历dom  祖先<br>
parent()<br>
直接父元素<br>
parents()<br>
所有祖先元素直到文档根元素<html><br>
parentsUtil()<br>
$(&quot;span&quot;).parentsUtil(&quot;div&quot;)<br>
返回给定两个元素之间的所有祖先元素<br>
不包括两个临界点</li>
<li>向下遍历  后代<br>
children() 所有的直接子元素<br>
find() 方法返回被选元素的所有后代元素，一路向下直到最后一个后代。</li>
<li>水平遍历dom  同胞<br>
siblings() 所有同胞<br>
tip:  过滤   $(&quot;span&quot;).siblings(&quot;p&quot;)  所有p同胞<br>
next() 方法返回被选元素的下一个同胞元素。（从左到右）<br>
nextAll()  返回被选元素之后的所有同胞   （从左到右）<br>
nextUntil() 方法返回介于两个给定参数之间的所有跟随的同胞元素。<br>
nextUntil(&quot;dom1&quot;).nextUtil(&quot;dom2&quot;)    (从左到右)<br>
tip： dom1 一定要位于左  dom2 位于右<br>
prev()<br>
prevAll()<br>
prevUntil()<br>
从右至左</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS Event Loop]]></title>
        <id>https://huyifu.github.io/post/js-event-loop/</id>
        <link href="https://huyifu.github.io/post/js-event-loop/">
        </link>
        <updated>2021-05-14T08:58:23.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[intersectionObsever 实现瀑布流]]></title>
        <id>https://huyifu.github.io/post/intersectionobsever-shi-xian-pu-bu-liu/</id>
        <link href="https://huyifu.github.io/post/intersectionobsever-shi-xian-pu-bu-liu/">
        </link>
        <updated>2021-04-23T08:51:41.000Z</updated>
        <content type="html"><![CDATA[<p>引言：项目需要实现瀑布流和懒加载  使用这个交叉观察者API<br>
原因：使用传统的监听scroll会使得scroll事件密集 性能下降 ——只会触发少的次数 在元素开始出现视图或脱离视图   触发回调函数</p>
<h2 id="语法">语法</h2>
<h3 id="创建">创建</h3>
<p>var io = new IntersectionObserver(callback, option);<br>
IntersectionObserver是浏览器原生提供的构造函数，接受两个参数：callback是可见性变化时的回调函数，option是配置对象（该参数可选）。</p>
<pre><code>// 开始观察
io.observe(document.getElementById('example'));
// 停止观察
io.unobserve(element);
// 关闭观察器
io.disconnect();
上面代码中，observe的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。
io.observe(elementA);
io.observe(elementB);
</code></pre>
<p>回调函数会返回一个对象数组 ——观察了几个元素就有几个IntersectionObserverEntry对象</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[sql server]]></title>
        <id>https://huyifu.github.io/post/sql-server/</id>
        <link href="https://huyifu.github.io/post/sql-server/">
        </link>
        <updated>2021-04-18T06:58:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="创建表">创建表</h3>
<p>每列的数据类型<br>
大部分表有一个主键 主键由一列或多列组成</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Html 元素种类]]></title>
        <id>https://huyifu.github.io/post/html-yuan-su-chong-lei/</id>
        <link href="https://huyifu.github.io/post/html-yuan-su-chong-lei/">
        </link>
        <updated>2021-04-15T13:08:13.000Z</updated>
        <content type="html"><![CDATA[<p>引言：打好基础~  img行内元素 却可以设置宽高？</p>
<h2 id="三种类型-块状-行内内联-内联块状">三种类型： 块状 行内（内联）  内联块状</h2>
<ol>
<li>块状block<br>
块级元素特点：<br>
1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。<br>
2、元素的高度、宽度、行高以及顶和底边距都可设置。<br>
3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。<br>
有：div、p、h1~h6、ul、ol、li、dl、dt、dd、table、form、rticle、aside、footer、header、main、nav、section ......</li>
<li>内联inline<br>
内联元素特点：<br>
1、和其他元素都在一行上；<br>
2、元素的高度、宽度及顶部和底部边距不可设置；<br>
3、元素的宽度就是它包含的文字或图片的宽度，不可改变。<br>
有：</li>
</ol>
<pre><code>&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 在html中，&lt;span&gt;、&lt;a&gt;、&lt;label&gt;、&lt;strong&gt; 和&lt;em&gt;就是典型的内联元素（行内元素）（inline）元素。
</code></pre>
<ol start="3">
<li>内联块状 inline-block<br>
顾名思义 先是inline属性排列  内容再是block属性<br>
在CSS中通过display:inline-block对一个对象指定inline-block属性，简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。<br>
特点<br>
1 和其他元素在一行<br>
2 可以设置宽高 边距 等</li>
</ol>
<h3 id="此外还有另一种划分方式">此外还有另一种划分方式 ：</h3>
<p>因为所有块级都是可替换元素  所以这里讨论行内元素的替换元素与非替换元素</p>
<h2 id="替换元素和非替换元素">替换元素和非替换元素</h2>
<ol>
<li>替换元素（所有块级都是可替换元素）<br>
特征：可以设置宽高<br>
标签：img、input、iframe、video、embed、canvas、audio<br>
替换元素就是浏览器根据元素的标签和属性，来决定元素的具体显示内容。<br>
例如浏览器会根据<img>标签的src属性的值来读取图片信息并显示出来，而如果查看html代码，则看不到图片的实际内容；又例如根据<input>标签的type属性来决定是显示输入框，还是单选按钮等。</li>
<li>非替换元素<br>
特征：不可以设置宽高，宽高由内容决定<br>
标签：a、strong、span、code、label<br>
不可替换元素html 的大多数元素是不可替换元素，即其内容直接表现给用户端（例如浏览器）。<br>
例如： <p>段落的内容</p> 段落<p>是一个不可替换元素，文字“段落的内容”全被显示。</li>
</ol>
<h3 id="回到引言中-img-input-都是行内元素-但是实际使用中都不自觉的已经设置了宽高-而且生效了-因为这是替换元素可置换元素-可以设置宽高">回到引言中 img input 都是行内元素 但是实际使用中都不自觉的已经设置了宽高 而且生效了 因为这是替换元素（可置换元素）  可以设置宽高</h3>
<h2 id="总结">总结：</h2>
<ol>
<li>块级元素
<ol>
<li>替换（可置换）</li>
</ol>
</li>
<li>内联元素
<ol>
<li>替换（可置换）</li>
<li>非替换 （不可置换）</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BOM 学习]]></title>
        <id>https://huyifu.github.io/post/bom-xue-xi/</id>
        <link href="https://huyifu.github.io/post/bom-xue-xi/">
        </link>
        <updated>2021-04-14T11:55:34.000Z</updated>
        <content type="html"><![CDATA[<p>引言： 学习js三部分中的浏览器对象模型</p>
<h3 id="bom-对象浏览器对象模型">BOM 对象——浏览器对象模型</h3>
<p>浏览器对象模型，它是对一系列在浏览器环境中使用对象的统称，这些对象提供了访问浏览器的功能。</p>
<h3 id="bom有五大核心对象">bom有五大核心对象</h3>
<ol>
<li>window</li>
<li>location</li>
<li>navigator</li>
<li>screen</li>
<li>history</li>
</ol>
<h2 id="与dom关系">与DOM关系</h2>
<h3 id="window对象是bom对象的顶层对象">window对象是Bom对象的顶层对象</h3>
<h3 id="window对象包含">window对象包含</h3>
<ol>
<li>doucument对象</li>
<li>frames对象</li>
<li>location对象</li>
<li>navigator对象</li>
<li>screen对象</li>
<li>history对象<br>
而dom最根本的对象为document对象<br>
得出结论：</li>
</ol>
<h3 id="bom是包含dom的">BOM是包含DOM的</h3>
<p>接下来一一探究 window对象 frames对象 location对象 navigator对象 screen对象 history对象</p>
<h3 id="window对象">window对象</h3>
<p>bom的顶层对象，在浏览器中具有双重角色，1 js访问浏览器的一个接口 2 ECMAScript里的全局global对象</p>
<ul>
<li>所有在全局作用域声明的变量都会作为window对象的属性 但是直接定义的全局变量不可delete删除  因为使用var 添加的window属性名[[Configurable]] 值为false</li>
<li>窗口关系及框架 没搞框架都有自己的window对象 保存在frames中  top指向最高层的看框架，也就是浏览器窗口  ...</li>
<li>窗口位置 screenLeft  窗口相对于屏幕左边的位置  以及screenX （兼容问题） ...</li>
<li>窗口大小 页面视口大小 ： document.documentElement.clientWidth  or  document.body.clientWidth</li>
<li>导航的打开窗口   window.open(URL,frame Name) 第二个参数也可 _self _parent _top _blank</li>
<li>间歇调用 超时调用   setInterval  setTimeout</li>
<li>系统对话框 alert confirm prompt<br>
对于 setInterval  setTimeout</li>
</ul>
<h4 id="js是单线程语言这些方法看起来是异步多线程其实是在特定的时间快速执行-还是在单线程上">JS是单线程语言，这些方法看起来是异步多线程，其实是在特定的时间快速执行 （还是在单线程上）</h4>
<p>第二个参数最小标准为10 不足则自动补为10 （内置）<br>
tip：屏幕频率一般60hz，每16.7ms刷新一次<br>
累计效应：当setInterval 函数第二个参数过于小 可能会出现同时触发多次的现象</p>
<h5 id="原因-涉及js-事件的event-loop-此处简单说明">原因：（ 涉及JS 事件的event loop   此处简单说明）</h5>
<p>主线程 同步代码区   event table  异步执行区<br>
当执行setInterval（func，xx）时候  func函数会被推入event table<br>
当经过xxms之后 func函数被放入同步代码区的最底部<br>
同步代码区的执行是需要时间的（包括被放入的func函数）<br>
当推入速度过快 而执行速度很慢  同步区就会出现多个 func函数 从而出现  定时器函数触发时间并没有按照每xxms执行 甚至 同时运行两遍.....</p>
<p>tip：超时调用（setTimeout）可以用来模拟 间歇调用（SetInterval）<br>
使用递归和设置循环次数</p>
<pre><code>var num=0;
function  incrementNumber(){
    num++;
    if (num&lt;100)
    {
        setTimeout(incrementNumber,500);
    }
}
</code></pre>
<p>这样能避免后一个间歇函数在前一个提前触发 以及大部分的累计效应—— 因为在前一个超时函数真正执行时候才会把下一个超时函数放入event table</p>
<h3 id="frames对象">frames对象</h3>
<p>###location对象</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[rem JS 适配]]></title>
        <id>https://huyifu.github.io/post/rem-js-gua-pei/</id>
        <link href="https://huyifu.github.io/post/rem-js-gua-pei/">
        </link>
        <updated>2021-04-07T13:11:44.000Z</updated>
        <content type="html"><![CDATA[<p>JS如下:</p>
<pre><code>window.onload =function(){
    let htmlwidth=document.documentElement.clientWidth || document.body.clientWidth;//有些浏览器documentElement获取不到,那就使用后面的body
    console.log(htmlwidth);
    // 2.htmlDom
    let htmlDom=document.getElementsByTagName(&quot;html&quot;)[0]
    console.log(htmlDom);
    //3.设置根元素样式
    htmlDom.style.fontSize=htmlwidth/20+'px';//记住这个20是等份的意思,这样每一份是16px,即1rem=16px;
}
</code></pre>
<h3 id="现在把整个宽度为20rem份-但是出现了一个问题-出现缩放不能跟着改变-如果浏览器发生缩放-会出现一些问题">现在把整个宽度为20rem份 ，但是出现了一个问题 出现缩放不能跟着改变 如果浏览器发生缩放 会出现一些问题</h3>
<p>如果想随着页面缩放进行font-size的调整 需要用到window的监听函数<br>
EventTarget.addEventListener()；<br>
addEventListener()添加事件监听<br>
addEventListener(event, function, useCapture)<br>
（1）参数event必填，表示监听的事件，例如 click, resize等，不加前缀on的事件。<br>
（2）参数 function必填，表示事件触发后调用的函数，可以是外部定义函数，也可以是匿名函数。不带参数。<br>
（3）参数 useCapture选填，填true或者false，用于描述事件是冒泡还是捕获触发，true表示捕获，默认false表示冒泡。<br>
代码修改如下 现在是缩放等比的状态</p>
<pre><code>function gethtmlfontsize(){
    // 三个步骤:
    // 1.获取html的宽,
    let htmlwidth=document.documentElement.clientWidth || document.body.clientWidth;//有些浏览器documentElement获取不到,那就使用后面的body
    console.log(htmlwidth);
    
    // 2.htmlDom
    let htmlDom=document.getElementsByTagName(&quot;html&quot;)[0]
    console.log(htmlDom);

    //3.设置根元素样式
    htmlDom.style.fontSize=htmlwidth/20+'px';
}
// 调用一次
gethtmlfontsize();
// 添加监听事件(resize是监听的意思)
window.addEventListener('resize',gethtmlfontsize);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS px em rem及其适配方案]]></title>
        <id>https://huyifu.github.io/post/css-px-em-rem/</id>
        <link href="https://huyifu.github.io/post/css-px-em-rem/">
        </link>
        <updated>2021-04-06T13:02:02.000Z</updated>
        <content type="html"><![CDATA[<p>引言： 弄清px em rem font-size等等概念  并尝试用来进行移动端的适配</p>
<h2 id="px的概念">px的概念</h2>
<p>px为图像的最小单位。px是固定长度单位，不随其它元素的变化而变化<br>
px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。<br>
屏幕分辨率 即显示器屏幕所有的像素点之和（100 x 100） 横轴100px大小 纵轴100px大小 10000为屏幕分辨率</p>
<h3 id="此处就引出了一个问题当css都使用px作为距离的单位-不同设备的屏幕分辨率是不一致的-手机的屏幕分辨率小于电脑-在手机上打开的网页会出现问题">此处就引出了一个问题：当css都使用px作为距离的单位  不同设备的屏幕分辨率是不一致的  手机的屏幕分辨率小于电脑  在手机上打开的网页会出现问题</h3>
<h2 id="em的概念">em的概念</h2>
<p>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。一般浏览器字体大小默认为16px  即 1em=16px</p>
<ol>
<li>em的值并不是固定的；</li>
<li>em会继承父级元素的字体大小。<br>
来看下面的例子</li>
</ol>
<pre><code>.box4 {
  width: 5em;
  height: 5em;
  background-color: brown;
}
 .box3{
     width: 10em;
     height: 10em;
     background-color: rgb(54, 67, 122);
 }
 .box2{
     
     width: 15em;
     height: 15em;
     background-color:rgb(43, 39, 48);
 }
 .box1{
        width: 20em;
        height: 20em;
        background-color: blueviolet;
 }
</code></pre>
<pre><code>&lt;div class=&quot;box1&quot;&gt;
     &lt;div class=&quot;box2&quot;&gt;
       &lt;div class=&quot;box3&quot;&gt;
         &lt;div class=&quot;box4&quot;&gt;
         &lt;/div&gt;
       &lt;/div&gt;
     &lt;/div&gt;
   &lt;/div&gt;

</code></pre>
<p><img src="https://huyifu.github.io/post-images/1617765321700.png" alt="" loading="lazy"><br>
根元素html字体大小默认16px 则正方形div大小为 80 160 240 320 px<br>
当把box2 的font-size改为 20px<br>
结果box3 box4等比扩大了<br>
<img src="https://huyifu.github.io/post-images/1617765837522.png" alt="" loading="lazy"></p>
<h3 id="说明font-size的继承性-而因为em是根据当前字体的大小来确定的">说明font-size的继承性  而因为em是根据当前字体的大小来确定的</h3>
<p>div大小为 120px 200px 300px 320px<br>
em是相对当前对象中文字大小的长度单位，若当前对象中的文字大小未设置，就会从父元素中继承其大小，父元素也没有设置，就一直上溯，直到浏览器默认字体大小，然后其字体大小会继承给当前对象，归根结底，em一直是相对当前对象字体大小的，当前对象字体大小确定后，em就会确定下来（1em=当前对象字体大小px）。 ps：其实上溯也就是从根元素给子元素 子给孙 一直继承下来而已<br>
tip： 如果给当前font-size设置 em的话  会先继承父元素的font-size 然后成功设置好之后 （即em大小已经确定）再去给其他属性赋值<br>
若将上文box3 font-size改为 1.25em 则会继承box2的font-size 变成1.25倍  再给width height等属性赋值 至于box4则继续继承box3改变之后的这个font-size</p>
<h3 id="由于font-size存在这种继承性-em的大小往往需要计算-在某些情况下-设置了字体大小也会对子元素进行影响-使得使用复杂">由于font-size存在这种继承性 em的大小往往需要计算 在某些情况下 设置了字体大小也会对子元素进行影响 使得使用复杂</h3>
<h2 id="rem的概念">rem的概念</h2>
<p>rem是CSS3新增的一个相对单位（root em，根em）。使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。<br>
与em很像 只是相对的目标不一样 改成html根元素为目标后 不会再有使用em的父子层叠 使得font-size联动改变的情况 使用起来简单一些</p>
<h2 id="现在想要通过rem和媒体查询来进行移动端的适配">现在想要通过rem和媒体查询来进行移动端的适配</h2>
<p>先来了解一下基础概念</p>
<h2 id="minmax-width">min/max width</h2>
<p>max-width : 最大宽度 即如果元素width超过这个值则保持width为max-width</p>
<pre><code> .box1{
            max-width: 800px;
        }
     &lt;div class=&quot;box1&quot;&gt;一二三&lt;/div&gt;
     ```
     block独占一行 宽度为视窗宽度  如果宽度大于800px则元素width保持800px不变
min-width: 最小宽度 即如果元素width小于这个值则保持width为min-width


## 媒体查询
CSS媒体查询（CSS Media Queries）是CSS基本特性之一。它的作用就是让我们在相同的HTML基础上可以以不同的CSS实现适配各种终端的UI效果（比如，桌面端、iPad、双屏幕、折叠设备和移动手机等）。
媒体查询语法
媒体查询由一种媒体类型组成，并可包含一个或多个表达式，这些表达式可以解析为 true 或 false。
@media not|only mediatype and (expressions) {
  CSS-Code;
}
1. 如果不使用 not or  only  则mediatype 为可选 并且所有设备都可以 进行匹配
2. and为与符号 可以用and进行多个表达式的连接
3. 在表达式里为 媒体特性名称：媒体特性值 如 max-width: 900px  max-width 为特性名称 900px为具体的值 （视窗如果小于900px则为true）
### 媒体特性种类：
视窗和页面，显示媒体，颜色媒体，交互媒体特性等等。
此处主要用视窗和页面媒体特性来进行屏幕分辨率的分类
用到 width heigth orientation属性来处理
</code></pre>
<p>/* 智能手机 <em>/<br>
@media only screen and (max-width: 400px) { body { background-color: #F09A9D; } }<br>
/</em> 平板 <em>/<br>
@media only screen and (min-width: 401px) and (max-width: 960px) { body { background-color: #F5CF8E; } }<br>
/</em> PC、平板电脑 */<br>
@media only screen and (min-width: 961px) { body { background-color: #B2D6FF; } }</p>
<pre><code>上面三种情况 （tip：属性边界都包含在里面）
第一种 视窗比400px小 true
第二种 视窗大于等于401px 小于等于960px true
第三种 视窗大于等于961px true

### orientation （取向）
区分横屏竖屏
媒体特性值有两种
portrait：竖屏，屏幕视窗高度大于宽度
landscape：横屏，屏幕视窗宽度大于高度


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue学习]]></title>
        <id>https://huyifu.github.io/post/vue-xue-xi/</id>
        <link href="https://huyifu.github.io/post/vue-xue-xi/">
        </link>
        <updated>2021-04-05T10:14:41.000Z</updated>
        <content type="html"><![CDATA[<p>Vue的语法及其使用<br>
需要实例化</p>
<pre><code>var vm = new Vue({
  // 选项
})
 var vm = new Vue({
        el: '#vue_det', 进行与id为vue_det的元素进行绑定
        data: {    	//data定义属性
            site: &quot;菜鸟教程&quot;, 
            url: &quot;www.runoob.com&quot;,
            alexa: &quot;10000&quot;
        },
        methods: {  	//methods定义函数
            details: function() {
                return  this.site + &quot; - 学的不仅是技术，更是梦想！&quot;;
            }
        }
    })
    ```
html：
</code></pre>
<div id="vue_det">
    <h4>site : {{site}}</h4>
    <h4>url : {{url}}</h4>
    <h4>{{details()}}</h4>
</div>
```
通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：
```
<span v-once>这个将不会改变: {{ msg }}</span>
```
模板语法
使用 v-html 指令用于输出 html 代码：
```
 data: {
    message: '<h4>菜鸟教程</h4>'
  }
<pre><code>v-bind用于绑定数据和元素属性   v-bind:属性名=&quot; &quot;的格式简写成:属性名=&quot; &quot;
例如
</code></pre>
<p>&lt; a :class=&quot;data1&quot; :href=&quot;url&quot;&gt;click me</a><br>
data:{<br>
url:&quot;https://www.baidu.com&quot;,<br>
data1: {active:isActive} //此处为一个对象 也可以进行绑定<br>
}</p>
<pre><code>```
</code></pre>
<p>指令 (Directives) 是带有 v- 前缀的特殊 attribute。指令 attribute 的值预期是单个 JavaScript 表达式</p>
<p v-if="seen">现在你看到我了</p>
这里，v-if 指令将根据表达式 seen 的值的真假来插入/移除 <p> 元素。
<p>v-on 指令，它用于监听 DOM 事件：<br>
<a v-on:click="doSomething">...</a><br>
v-on:click =<br>
缩写<br>
@click =<br>
@[event]  =<br>
动态参数</p>
<p>计算属性  data里的computed 写入需要计算的表达式</p>
<pre><code>&lt;div id=&quot;example&quot;&gt;
  &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt;
  &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;
&lt;/div&gt;
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
</code></pre>
<p>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：<br>
v-bind:[attributeName]=&quot;url&quot;  即data中attributeName的值作为绑定的属性</p>
<h2 id="计算属性缓存-vs-方法">计算属性缓存 vs 方法</h2>
<p>vue 实例 中computed 与 methods 都可以基于某一个data进行表达式的运算</p>
<pre><code>methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('')
  }
}
</code></pre>
<p>与</p>
<pre><code>  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
</code></pre>
<h3 id="两者结果一致-但是计算属性是基于它们的响应式依赖进行缓存的">两者结果一致 但是计算属性是基于它们的响应式依赖进行缓存的</h3>
<p>意味着 如果所依赖的data没有进行更改 计算属性会立即返回之前的计算结果，而不必再次执行函数。  所有使用computed在某些时刻可以提高性能<br>
因为数据绑定 和依赖式的更新  可以不进行监听数据</p>
<pre><code>var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar'
  },
  computed: {
    fullName: function () {
      return this.firstName + ' ' + this.lastName
    }
  }
})
</code></pre>
<p>在firstName 或者 lastName 更改时候 fullName自动进行更改</p>
<p>computed  set 与get</p>
<pre><code> &lt;body&gt;
     &lt;div id=&quot;app&quot;&gt;
         {{fullName}}
     &lt;/div&gt;
    &lt;script&gt;
       var vm = new Vue({
           el: &quot;#app&quot;,
           data: {
               firstName:&quot;Ma&quot;,
               lastName:&quot;BinYan&quot;
           },
           computed:{
               fullName :{
                   get: function()
                   {return this.firstName+&quot; &quot;+this.lastName},
                  set : function(value)  //修改fullName的值时触发
                  {
                      var array = value.split(&quot; &quot;);
                       this.firstName=array[0];
                       this.lastName=array[1];
                   }
               }
           }
       })
    &lt;/script&gt;
  &lt;/body&gt;
</code></pre>
<p>侦听器<br>
虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p>
<p>绑定 HTML Class<br>
对象语法<br>
我们可以传给 v-bind:class 一个对象，以动态地切换 class：</p>
<div v-bind:class="{ active: isActive }"></div>
上面的语法表示 active 这个 class 存在与否将取决于数据 property isActive 的 truthiness。
<p>你可以在对象中传入更多字段来动态切换多个 class。此外，v-bind:class 指令也可以与普通的 class attribute 共存。当有如下模板：</p>
<div
  class="static"
  v-bind:class="{ active: isActive, 'text-danger': hasError }"
></div>
和如下 data：
<p>data: {<br>
isActive: true,<br>
hasError: false<br>
}<br>
结果渲染为：</p>
<pre><code>&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;

  &lt;style&gt;
   .styles{
      color: yellow;
  }
    &lt;/style&gt;
&lt;/head&gt;
    
  &lt;body&gt;
    &lt;div id=&quot;app&quot; &gt;
    &lt;span @click=&quot;handleClick&quot;
    :class=&quot;{styles: isActivated}&quot;&gt;XiaoMa&lt;/span&gt;
&lt;/div&gt;
     &lt;script&gt;
         var vm = new Vue({
             el:&quot;#app&quot;,
             data:{
                 isActivated : false
             },
             methods:{
              handleClick: function (){
                  this.isActivated=!this.isActivated;
              }
             }
         })
 &lt;/script&gt;
</code></pre>
<p>条件渲染<br>
v-if<br>
v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</p>
<h4 v-if="awesome">Vue is awesome!</h4>
也可以用 v-else 添加一个“else 块”：
<h4 v-if="awesome">Vue is awesome!</h4>
<h4 v-else>Oh no 😢</h4>
在 < template> 元素上使用 v-if 条件渲染分组
因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 < template> 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 < t emplate> 元素。
```
<template v-if="ok">
  <h1>Title</h1>
  <p>Paragraph 1</p>
  <p>Paragraph 2</p>
</template>
v-else-if 
<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Not A/B/C
</div>
```
<h3 id="vue-会尽可能高效地渲染元素通常会复用已有元素而不是从头开始渲染">Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。</h3>
<p>会使得某些元素直接复用 出现一些问题</p>
<pre><code>&lt;template v-if=&quot;loginType === 'username'&quot;&gt;
  &lt;label&gt;Username&lt;/label&gt;
  &lt;input placeholder=&quot;Enter your username&quot;&gt;
&lt;/template&gt;
&lt;template v-else&gt;
  &lt;label&gt;Email&lt;/label&gt;
  &lt;input placeholder=&quot;Enter your email address&quot;&gt;
&lt;/template&gt;
</code></pre>
<p>input里面的内容在切换时不会清除 因为vue在渲染时复用了另一个input<br>
解决方法—— 绑定key值<br>
:key =&quot;id&quot;  vue根据key来判断是不是相同的元素</p>
<p>v-show   保留有dom<br>
条件展示元素<br>
不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display。</p>
<h2 id="v-if-vs-v-show">v-if vs v-show</h2>
<p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>
v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>
相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。<br>
一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p>
<p>列表渲染<br>
在 v-for 里使用对象<br>
你也可以用 v-for 来遍历一个对象的 property。</p>
<pre><code>&lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt;
  &lt;li v-for=&quot;value in object&quot;&gt;
    {{ value }}
  &lt;/li&gt;
&lt;/ul&gt;
new Vue({
  el: '#v-for-object',
  data: {
    object: {
      title: 'How to do lists in Vue',
      author: 'Jane Doe',
      publishedAt: '2016-04-10'
    }
  }
})
</code></pre>
<p>结果：</p>
<p>你也可以提供第二个的参数为 property 名称 (也就是键名)：</p>
<div v-for="(value, name) in object">
  {{ name }}: {{ value }}
</div>
<p>还可以用第三个参数作为索引：</p>
<div v-for="(value, name, index) in object">
  {{ index }}. {{ name }}: {{ value }}
</div>
结果如下：
0.title: How to do lists in Vue,
1.author: Jane Doe,
2.publishedAt: 2016-04-10
<h2 id="遍历的特性">遍历的特性</h2>
<p>维护状态<br>
当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 track-by=&quot;$index&quot;。<br>
这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。<br>
为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute：</p>
<div v-for="item in items" v-bind:key="item.id">
  <!-- 内容 -->
</div>
建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。
<p>变更方法<br>
Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：<br>
push()<br>
pop()<br>
shift()<br>
unshift()<br>
splice()<br>
sort()<br>
reverse()<br>
tip：用数组下标可以来改变数据 但是不会触发视图更新</p>
<h2 id="使用ref获取dom">使用ref获取dom</h2>
<pre><code>&lt;body&gt;
    &lt;div id='app'&gt;
       &lt;div ref='hello' @click=&quot;handleClick&quot;&gt;
           click me
        此div绑定了一个ref hello
        在函数中使用this.$refs vue实例中所有的引用
        this.$refs.hello可以取到这个dom节点
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
  new Vue({
      el:'#app',
      methods: {
          handleClick : function(){
              alert(this.$refs.hello.innerHTML);
          }
      }

});
    &lt;/script&gt;
  &lt;/body&gt;

</code></pre>
<h2 id="组件的使用">组件的使用</h2>
<p>Vue.component('组件名称', {组件内容});<br>
在创建后 组件为可复用的vue实例<br>
组件作为自定义元素来使用：<br>
&lt;组件名&gt;&lt;/组件名&gt;</p>
<p>组件的注册<br>
Vue.componet 全局注册<br>
全局注册的组件可以用在其被注册之后的任何 (通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。<br>
局部注册<br>
var ComponentA = { /* ... <em>/ }<br>
var ComponentB = { /</em> ... <em>/ }<br>
var ComponentC = { /</em> ... */ }<br>
然后在 components 选项中定义你想要使用的组件：</p>
<pre><code>new Vue({
  el: '#app',
  components: {
    'component-a': ComponentA,
    'component-b': ComponentB
  }
})
</code></pre>
<p>对于 components 对象中的每个 property 来说，其 property 名就是自定义元素的名字，其 property 值就是这个组件的选项对象。</p>
<h3 id="tip局部组件的使用需要像上面那样声明-即局部组件中使用另一个需要声明">tip：局部组件的使用需要像上面那样声明  即局部组件中使用另一个需要声明</h3>
<p>var ComponentA = { /* ... */ }<br>
var ComponentB = {<br>
components: {<br>
'component-a': ComponentA<br>
},<br>
// ...<br>
}</p>
<h2 id="prop">Prop</h2>
<p>子组件设置props属性来接收父组件的数据<br>
单向数据流： 子组件不能改变父组件传来的值 父组件更新数据传给子组件的数据会进行更新<br>
如果需要更改并传给父组件可以：<br>
在子组件data中copy数据 并使用data中的数据进行传值</p>
<p>1 子局部组件创建  var a={}<br>
2 父组件在组件中声明 components:{ a : a}<br>
3 子组件在props属性中 声明好子组件需要接收到的数据 props:['data']<br>
4 在子组件调用时 利用props进行传值  <a :data= "需要传递的数据"></a><br>
5  子组件需要向父组件传值时 可以调用this.$emit(&quot;事件名&quot;,参数1) 来传值 触发自定义事件<br>
6  子组件上提前监听好了这个事件 在子组件触发这个事件开始调用处理函数 父组件里的方法进行处理<br>
7 处理完毕 父子组件相互传值成功</p>
<pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;
    &lt;title&gt;Model&lt;/title&gt;
    &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
 
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;p&gt;父子组件传值 子组件设置props属性接收数据&lt;/p&gt;
        &lt;counter :count=&quot;data1&quot; @change=&quot;handleChange&quot;&gt;&lt;/counter&gt;
        &lt;counter :count=&quot;data2&quot; @change=&quot;handleChange&quot;&gt;&lt;/counter&gt;
        &lt;p&gt;现在给父组件添加一个数据 值为两个counter的数字和 涉及子组件给父组件传值&lt;/p&gt;
        &lt;p&gt;涉及三步骤 子组件被点击触发自定义的change事件 然后父组件设置了监听属性监听了这个change事件 最后进行处理事件&lt;/p&gt;
        {{totalNum}}
    &lt;/div&gt;
    &lt;script&gt;
        var counter = {
            props:['count'],
            template:'&lt;div @click=&quot;handleClick&quot;&gt;{{number}}&lt;/div&gt;',
            methods:{
                handleClick:function(){
                    this.number++;
                    this.$emit('change',1);
                }
            },
            data:function(){
                return{
                    number: this.count
                }
            }
        }
       new Vue({
           el:'#app',
           components:{
               counter:counter
           },
            data: function(){
                return{
                    totalNum:0,
                    data1:0,
                    data2:0
                }
            },
            methods:{
                handleChange:function(value){
                  // alert(value);
                   this.totalNum+= value;
                }
            }
       }) 
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="tip-如果要子组件要传给父组件多个值">tip ： 如果要子组件要传给父组件多个值</h3>
<p>子组件： this.$emit( &quot;事件名&quot;, data1,data2)<br>
父组件： @事件名 = &quot;处理函数(arguments)&quot;  参数对象<br>
此时 data1为arguments[0]  data2为arguments[1] ...</p>
<h2 id="组件名">组件名</h2>
<p>遵循 W3C 规范中的自定义组件名 (字母全小写且必须包含一个连字符)。<br>
定义组件名的方式有两种：</p>
<h3 id="使用-kebab-case">使用 kebab-case</h3>
<p>Vue.component('my-component-name', { /* ... */ })<br>
当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 <my-component-name>。</p>
<h3 id="使用-pascalcase">使用 PascalCase</h3>
<p>Vue.component('MyComponentName', { /* ... */ })<br>
当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 <my-component-name> 和 <MyComponentName> 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。<br>
tip：最好选择一种全部使用</p>
<p>组件参数校验</p>
<pre><code>Vue.component('my-component', {
  props: {
    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: {
      type: String,
      required: true
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100
    },
    // 带有默认值的对象
    propE: {
      type: Object,
      // 对象或数组默认值必须从一个工厂函数获取
      default: function () {
        return { message: 'hello' }
      }
    },
    // 自定义验证函数  （返回一个布尔值）
    propF: {
      validator: function (value) {
        // 这个值必须匹配下列字符串中的一个
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
  }
})
</code></pre>
<h2 id="props特性与非props特性">props特性与非props特性</h2>
<ul>
<li>props特性：<br>
子组件声明了传递参数的接收<br>
传递的参数不会在dom标签中显示<br>
可以通过插值表达式或者通过this.content去取得该属性中的内容。</li>
<li>非props特性：<br>
子组件不声明从父组件接收而来的参数<br>
显示在子组件最外层DOM标签的HTML属性里面</li>
</ul>
<p>组件绑定原生事件<br>
&lt;child @handle=&quot;handleChildClick&quot;&gt;</child>  在组件上绑定事件为自定义事件<br>
template: '&lt;div @click=&quot;handleClick&quot;&gt;Click me</div>'  在模板里直接会被渲染 所以绑定原生事件  （一般在这个原生事件里可以this.$emit('handle') 触发另一个事件)<br>
代码如下：</p>
<pre><code>&lt;body&gt;
    &lt;div id=&quot;app&quot; &gt;
        &lt;child @handle=&quot;handleChildClick&quot;&gt;&lt;/child&gt;
  &lt;/div&gt;
     &lt;script&gt;
         var child = {
             template:  '&lt;div @click=&quot;handleClick&quot;&gt;Click me&lt;/div&gt;',
             methods:{
                 handleClick :function(){
                     alert('原生事件触发');
                     this.$emit('handle');
                 }
             }
         }
         new Vue({
             el:'#app',
            components:{
                child : child,
            },
            methods:{
                handleChildClick :function(){
                    alert('自定义事件触发');
                }
            }
         })
      &lt;/script&gt;
  &lt;/body&gt;
</code></pre>
<p>原生事件触发 -》 this.$emit -》 监听子组件的自定义事件接收到 -》 自定义事件触发</p>
<h2 id="直接监听子组件的原生事件">直接监听子组件的原生事件</h2>
<p>使用修饰符 .native<br>
代码如下：</p>
<pre><code>&lt;body&gt;
    &lt;div id=&quot;app&quot; &gt;
        &lt;child @click.native=&quot;handleChildClick&quot;&gt;&lt;/child&gt;
    &lt;/div&gt;
     &lt;script&gt;
         var child = {
             template:  '&lt;div&gt;Click me&lt;/div&gt;',
         }
         new Vue({
             el:'#app',
            components:{
                child : child,
            },
            methods:{
                handleChildClick :function(){
                    alert('利用修饰符直接触发原生事件');
                }
            }
         })
      &lt;/script&gt;
  &lt;/body&gt;
</code></pre>
<h2 id="非父子组件之间传值">非父子组件之间传值</h2>
<p>(Bus/总线/发布者订阅模式/观察者模式）<br>
在vue最顶部</p>
<ul>
<li>Vue.prototype.bus = new Vue();<br>
在Vue的prototype挂载了一个bus属性 这个属性是指向vue的实例 调用 Vue 或者new Vue时，每个组件都会有一个bus属性，因为以后不管是 Vue 的属性还是 Vue 的实例，都是通过 Vue 来创建的，而我在 Vue 的prototype上挂载了一个bus的属性。</li>
<li>this.bus.$emit('触发事件', data)  传递的实例</li>
<li>this.bus.$on('触发事件', msg =&gt; {console.log('回调函数执行 msg为传递的数据'})  接收的实例</li>
</ul>
<p>代码如下：</p>
<pre><code>&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;sendchild :msg=&quot;1&quot;&gt;&lt;/sendchild&gt;
        &lt;acceptchild :msg=&quot;2&quot;&gt;&lt;/acceptchild&gt;
    &lt;/div&gt;
    &lt;script&gt;
       Vue.prototype.bus = new Vue();
        var sendchild= {
            template: '&lt;div @click=&quot;handleClick&quot;&gt;{{content}}&lt;/div&gt;',
            data: function(){
                return {
                    content: this.msg
                }
            },
            methods:{
                handleClick:function (){
                    alert('send孩子开始传值,用bus属性 emit transport事件 数据为content');
                    this.bus.$emit('transport',this.content);
                },
            },
           mounted:function(){
                console.log('send孩子实例创建，监听transport事件');
                this.bus.$on('transport',msg =&gt;console.log('send孩子接收到msg数据,数据为'+msg));
           },
            props:{
                msg: Number
            },
        }
        var acceptchild= {
            data: function(){
                return {
                    content: this.msg
                }
            },
            methods:{
                handleClick:function (){
                    alert('accept孩子开始传值,用bus属性emit transport事件 数据为content');
                    this.bus.$emit('transport',this.content);
                },
            },
            mounted:function(){
                console.log('accept孩子实例创建，监听transport事件');
                this.bus.$on('transport',msg =&gt;console.log('accept孩子接收到msg数据,数据为'+msg));
           },
            props:{
                msg: Number
            },
            template: '&lt;div @click=&quot;handleClick&quot;&gt;{{content}}&lt;/div&gt;'
        }
        new Vue({
            el:'#app',
            components:{
                sendchild : sendchild,
                acceptchild: acceptchild
            }
        })
    &lt;/script&gt;
  &lt;/body&gt;
</code></pre>
<p>使用插槽 slot  ——Vue 实现了一套内容分发的 API，将<slot>元素作为承载分发内容的出口<br>
子组件设置slot占位  父组件为这个slot填充内容</p>
<pre><code>&lt;div id='app'&gt;
        &lt;!-- child组件里面写的内容会默认插值到模板里的slot标签里 --&gt;
        &lt;child&gt;
            &lt;h1&gt;DELL&lt;/h1&gt;
        &lt;/child&gt;
    &lt;/div&gt;
    &lt;script&gt;
     Vue.component('child',{
         template: `
                &lt;div&gt;
                    &lt;p&gt;firstLine&lt;/p&gt;
                    &lt;slot&gt;slot标签里面为默认内容&lt;/slot&gt;
                &lt;/div&gt;
                `
     })
     new Vue({
         el: '#app'
     })
    &lt;/script&gt;
</code></pre>
<p>显示<br>
firstLine<br>
DELL<br>
tip：如果child组件无内容 即<child></child><br>
显示<br>
firstLine<br>
slot标签里面为默认内容</p>
<p>如果想有多个插槽 使用具名插槽</p>
<pre><code>  &lt;div id='app'&gt;
        &lt;!-- child组件里面写的内容会默认插值到模板里的slot标签里 --&gt;
        &lt;child&gt;
            &lt;header slot=&quot;header&quot;&gt;Header&lt;/header&gt;
            &lt;footer slot=&quot;footer&quot;&gt;Footer&lt;/footer&gt;
        &lt;/child&gt;
    &lt;/div&gt;
    &lt;script&gt;
     Vue.component('child',{
         template: `
                &lt;div&gt;
                     &lt;slot name='header'&gt;default Header&lt;/slot&gt;
                    &lt;div class=&quot;main&quot;&gt;Main&lt;/div&gt;
                    &lt;slot name='footer'&gt;default Footer&lt;/slot&gt;
                &lt;/div&gt;
                `
     })
     new Vue({
         el: '#app'
     })
    &lt;/script&gt;
</code></pre>
]]></content>
    </entry>
</feed>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://huyifu.github.io</id>
    <title>古月的blog</title>
    <updated>2021-05-07T08:47:48.421Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://huyifu.github.io"/>
    <link rel="self" href="https://huyifu.github.io/atom.xml"/>
    <subtitle>Nothing for nothing
</subtitle>
    <logo>https://huyifu.github.io/images/avatar.png</logo>
    <icon>https://huyifu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 古月的blog</rights>
    <entry>
        <title type="html"><![CDATA[intersectionObsever 实现瀑布流]]></title>
        <id>https://huyifu.github.io/post/intersectionobsever-shi-xian-pu-bu-liu/</id>
        <link href="https://huyifu.github.io/post/intersectionobsever-shi-xian-pu-bu-liu/">
        </link>
        <updated>2021-04-23T08:51:41.000Z</updated>
        <content type="html"><![CDATA[<p>引言：项目需要实现瀑布流和懒加载  使用这个交叉观察者API<br>
原因：使用传统的监听scroll会使得scroll事件密集 性能下降 ——只会触发少的次数 在元素开始出现视图或脱离视图   触发回调函数</p>
<h2 id="语法">语法</h2>
<h3 id="创建">创建</h3>
<p>var io = new IntersectionObserver(callback, option);<br>
IntersectionObserver是浏览器原生提供的构造函数，接受两个参数：callback是可见性变化时的回调函数，option是配置对象（该参数可选）。</p>
<pre><code>// 开始观察
io.observe(document.getElementById('example'));
// 停止观察
io.unobserve(element);
// 关闭观察器
io.disconnect();
上面代码中，observe的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。
io.observe(elementA);
io.observe(elementB);
</code></pre>
<p>回调函数会返回一个对象数组 ——观察了几个元素就有几个IntersectionObserverEntry对象</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[sql server]]></title>
        <id>https://huyifu.github.io/post/sql-server/</id>
        <link href="https://huyifu.github.io/post/sql-server/">
        </link>
        <updated>2021-04-18T06:58:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="创建表">创建表</h3>
<p>每列的数据类型<br>
大部分表有一个主键 主键由一列或多列组成</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Html 元素种类]]></title>
        <id>https://huyifu.github.io/post/html-yuan-su-chong-lei/</id>
        <link href="https://huyifu.github.io/post/html-yuan-su-chong-lei/">
        </link>
        <updated>2021-04-15T13:08:13.000Z</updated>
        <content type="html"><![CDATA[<p>引言：打好基础~  img行内元素 却可以设置宽高？</p>
<h2 id="三种类型-块状-行内内联-内联块状">三种类型： 块状 行内（内联）  内联块状</h2>
<ol>
<li>块状block<br>
块级元素特点：<br>
1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。<br>
2、元素的高度、宽度、行高以及顶和底边距都可设置。<br>
3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。<br>
有：div、p、h1~h6、ul、ol、li、dl、dt、dd、table、form、rticle、aside、footer、header、main、nav、section ......</li>
<li>内联inline<br>
内联元素特点：<br>
1、和其他元素都在一行上；<br>
2、元素的高度、宽度及顶部和底部边距不可设置；<br>
3、元素的宽度就是它包含的文字或图片的宽度，不可改变。<br>
有：</li>
</ol>
<pre><code>&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 在html中，&lt;span&gt;、&lt;a&gt;、&lt;label&gt;、&lt;strong&gt; 和&lt;em&gt;就是典型的内联元素（行内元素）（inline）元素。
</code></pre>
<ol start="3">
<li>内联块状 inline-block<br>
顾名思义 先是inline属性排列  内容再是block属性<br>
在CSS中通过display:inline-block对一个对象指定inline-block属性，简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。<br>
特点<br>
1 和其他元素在一行<br>
2 可以设置宽高 边距 等</li>
</ol>
<h3 id="此外还有另一种划分方式">此外还有另一种划分方式 ：</h3>
<p>因为所有块级都是可替换元素  所以这里讨论行内元素的替换元素与非替换元素</p>
<h2 id="替换元素和非替换元素">替换元素和非替换元素</h2>
<ol>
<li>替换元素（所有块级都是可替换元素）<br>
特征：可以设置宽高<br>
标签：img、input、iframe、video、embed、canvas、audio<br>
替换元素就是浏览器根据元素的标签和属性，来决定元素的具体显示内容。<br>
例如浏览器会根据<img>标签的src属性的值来读取图片信息并显示出来，而如果查看html代码，则看不到图片的实际内容；又例如根据<input>标签的type属性来决定是显示输入框，还是单选按钮等。</li>
<li>非替换元素<br>
特征：不可以设置宽高，宽高由内容决定<br>
标签：a、strong、span、code、label<br>
不可替换元素html 的大多数元素是不可替换元素，即其内容直接表现给用户端（例如浏览器）。<br>
例如： <p>段落的内容</p> 段落<p>是一个不可替换元素，文字“段落的内容”全被显示。</li>
</ol>
<h3 id="回到引言中-img-input-都是行内元素-但是实际使用中都不自觉的已经设置了宽高-而且生效了-因为这是替换元素可置换元素-可以设置宽高">回到引言中 img input 都是行内元素 但是实际使用中都不自觉的已经设置了宽高 而且生效了 因为这是替换元素（可置换元素）  可以设置宽高</h3>
<h2 id="总结">总结：</h2>
<ol>
<li>块级元素
<ol>
<li>替换（可置换）</li>
</ol>
</li>
<li>内联元素
<ol>
<li>替换（可置换）</li>
<li>非替换 （不可置换）</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BOM 学习]]></title>
        <id>https://huyifu.github.io/post/bom-xue-xi/</id>
        <link href="https://huyifu.github.io/post/bom-xue-xi/">
        </link>
        <updated>2021-04-14T11:55:34.000Z</updated>
        <content type="html"><![CDATA[<p>引言： 学习js三部分中的浏览器对象模型</p>
<h3 id="bom-对象浏览器对象模型">BOM 对象——浏览器对象模型</h3>
<p>浏览器对象模型，它是对一系列在浏览器环境中使用对象的统称，这些对象提供了访问浏览器的功能。</p>
<h3 id="bom有五大核心对象">bom有五大核心对象</h3>
<ol>
<li>window</li>
<li>location</li>
<li>navigator</li>
<li>screen</li>
<li>history</li>
</ol>
<h2 id="与dom关系">与DOM关系</h2>
<h3 id="window对象是bom对象的顶层对象">window对象是Bom对象的顶层对象</h3>
<h3 id="window对象包含">window对象包含</h3>
<ol>
<li>doucument对象</li>
<li>frames对象</li>
<li>location对象</li>
<li>navigator对象</li>
<li>screen对象</li>
<li>history对象<br>
而dom最根本的对象为document对象<br>
得出结论：</li>
</ol>
<h3 id="bom是包含dom的">BOM是包含DOM的</h3>
<p>接下来一一探究 window对象 frames对象 location对象 navigator对象 screen对象 history对象</p>
<h3 id="window对象">window对象</h3>
<p>bom的顶层对象，在浏览器中具有双重角色，1 js访问浏览器的一个接口 2 ECMAScript里的全局global对象</p>
<ul>
<li>所有在全局作用域声明的变量都会作为window对象的属性 但是直接定义的全局变量不可delete删除  因为使用var 添加的window属性名[[Configurable]] 值为false</li>
<li>窗口关系及框架 没搞框架都有自己的window对象 保存在frames中  top指向最高层的看框架，也就是浏览器窗口  ...</li>
<li>窗口位置 screenLeft  窗口相对于屏幕左边的位置  以及screenX （兼容问题） ...</li>
<li>窗口大小 页面视口大小 ： document.documentElement.clientWidth  or  document.body.clientWidth</li>
<li>导航的打开窗口   window.open(URL,frame Name) 第二个参数也可 _self _parent _top _blank</li>
<li>间歇调用 超时调用   setInterval  setTimeout</li>
<li>系统对话框 alert confirm prompt<br>
对于 setInterval  setTimeout</li>
</ul>
<h4 id="js是单线程语言这些方法看起来是异步多线程其实是在特定的时间快速执行-还是在单线程上">JS是单线程语言，这些方法看起来是异步多线程，其实是在特定的时间快速执行 （还是在单线程上）</h4>
<p>第二个参数最小标准为10 不足则自动补为10<br>
tip：屏幕频率一般60hz，每16.7ms刷新一次</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[rem JS 适配]]></title>
        <id>https://huyifu.github.io/post/rem-js-gua-pei/</id>
        <link href="https://huyifu.github.io/post/rem-js-gua-pei/">
        </link>
        <updated>2021-04-07T13:11:44.000Z</updated>
        <content type="html"><![CDATA[<p>JS如下:</p>
<pre><code>window.onload =function(){
    let htmlwidth=document.documentElement.clientWidth || document.body.clientWidth;//有些浏览器documentElement获取不到,那就使用后面的body
    console.log(htmlwidth);
    // 2.htmlDom
    let htmlDom=document.getElementsByTagName(&quot;html&quot;)[0]
    console.log(htmlDom);
    //3.设置根元素样式
    htmlDom.style.fontSize=htmlwidth/20+'px';//记住这个20是等份的意思,这样每一份是16px,即1rem=16px;
}
</code></pre>
<h3 id="现在把整个宽度为20rem份-但是出现了一个问题-出现缩放不能跟着改变-如果浏览器发生缩放-会出现一些问题">现在把整个宽度为20rem份 ，但是出现了一个问题 出现缩放不能跟着改变 如果浏览器发生缩放 会出现一些问题</h3>
<p>如果想随着页面缩放进行font-size的调整 需要用到window的监听函数<br>
EventTarget.addEventListener()；<br>
addEventListener()添加事件监听<br>
addEventListener(event, function, useCapture)<br>
（1）参数event必填，表示监听的事件，例如 click, resize等，不加前缀on的事件。<br>
（2）参数 function必填，表示事件触发后调用的函数，可以是外部定义函数，也可以是匿名函数。不带参数。<br>
（3）参数 useCapture选填，填true或者false，用于描述事件是冒泡还是捕获触发，true表示捕获，默认false表示冒泡。<br>
代码修改如下 现在是缩放等比的状态</p>
<pre><code>function gethtmlfontsize(){
    // 三个步骤:
    // 1.获取html的宽,
    let htmlwidth=document.documentElement.clientWidth || document.body.clientWidth;//有些浏览器documentElement获取不到,那就使用后面的body
    console.log(htmlwidth);
    
    // 2.htmlDom
    let htmlDom=document.getElementsByTagName(&quot;html&quot;)[0]
    console.log(htmlDom);

    //3.设置根元素样式
    htmlDom.style.fontSize=htmlwidth/20+'px';
}
// 调用一次
gethtmlfontsize();
// 添加监听事件(resize是监听的意思)
window.addEventListener('resize',gethtmlfontsize);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS px em rem及其适配方案]]></title>
        <id>https://huyifu.github.io/post/css-px-em-rem/</id>
        <link href="https://huyifu.github.io/post/css-px-em-rem/">
        </link>
        <updated>2021-04-06T13:02:02.000Z</updated>
        <content type="html"><![CDATA[<p>引言： 弄清px em rem font-size等等概念  并尝试用来进行移动端的适配</p>
<h2 id="px的概念">px的概念</h2>
<p>px为图像的最小单位。px是固定长度单位，不随其它元素的变化而变化<br>
px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。<br>
屏幕分辨率 即显示器屏幕所有的像素点之和（100 x 100） 横轴100px大小 纵轴100px大小 10000为屏幕分辨率</p>
<h3 id="此处就引出了一个问题当css都使用px作为距离的单位-不同设备的屏幕分辨率是不一致的-手机的屏幕分辨率小于电脑-在手机上打开的网页会出现问题">此处就引出了一个问题：当css都使用px作为距离的单位  不同设备的屏幕分辨率是不一致的  手机的屏幕分辨率小于电脑  在手机上打开的网页会出现问题</h3>
<h2 id="em的概念">em的概念</h2>
<p>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。一般浏览器字体大小默认为16px  即 1em=16px</p>
<ol>
<li>em的值并不是固定的；</li>
<li>em会继承父级元素的字体大小。<br>
来看下面的例子</li>
</ol>
<pre><code>.box4 {
  width: 5em;
  height: 5em;
  background-color: brown;
}
 .box3{
     width: 10em;
     height: 10em;
     background-color: rgb(54, 67, 122);
 }
 .box2{
     
     width: 15em;
     height: 15em;
     background-color:rgb(43, 39, 48);
 }
 .box1{
        width: 20em;
        height: 20em;
        background-color: blueviolet;
 }
</code></pre>
<pre><code>&lt;div class=&quot;box1&quot;&gt;
     &lt;div class=&quot;box2&quot;&gt;
       &lt;div class=&quot;box3&quot;&gt;
         &lt;div class=&quot;box4&quot;&gt;
         &lt;/div&gt;
       &lt;/div&gt;
     &lt;/div&gt;
   &lt;/div&gt;

</code></pre>
<p><img src="https://huyifu.github.io/post-images/1617765321700.png" alt="" loading="lazy"><br>
根元素html字体大小默认16px 则正方形div大小为 80 160 240 320 px<br>
当把box2 的font-size改为 20px<br>
结果box3 box4等比扩大了<br>
<img src="https://huyifu.github.io/post-images/1617765837522.png" alt="" loading="lazy"></p>
<h3 id="说明font-size的继承性-而因为em是根据当前字体的大小来确定的">说明font-size的继承性  而因为em是根据当前字体的大小来确定的</h3>
<p>div大小为 120px 200px 300px 320px<br>
em是相对当前对象中文字大小的长度单位，若当前对象中的文字大小未设置，就会从父元素中继承其大小，父元素也没有设置，就一直上溯，直到浏览器默认字体大小，然后其字体大小会继承给当前对象，归根结底，em一直是相对当前对象字体大小的，当前对象字体大小确定后，em就会确定下来（1em=当前对象字体大小px）。 ps：其实上溯也就是从根元素给子元素 子给孙 一直继承下来而已<br>
tip： 如果给当前font-size设置 em的话  会先继承父元素的font-size 然后成功设置好之后 （即em大小已经确定）再去给其他属性赋值<br>
若将上文box3 font-size改为 1.25em 则会继承box2的font-size 变成1.25倍  再给width height等属性赋值 至于box4则继续继承box3改变之后的这个font-size</p>
<h3 id="由于font-size存在这种继承性-em的大小往往需要计算-在某些情况下-设置了字体大小也会对子元素进行影响-使得使用复杂">由于font-size存在这种继承性 em的大小往往需要计算 在某些情况下 设置了字体大小也会对子元素进行影响 使得使用复杂</h3>
<h2 id="rem的概念">rem的概念</h2>
<p>rem是CSS3新增的一个相对单位（root em，根em）。使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。<br>
与em很像 只是相对的目标不一样 改成html根元素为目标后 不会再有使用em的父子层叠 使得font-size联动改变的情况 使用起来简单一些</p>
<h2 id="现在想要通过rem和媒体查询来进行移动端的适配">现在想要通过rem和媒体查询来进行移动端的适配</h2>
<p>先来了解一下基础概念</p>
<h2 id="minmax-width">min/max width</h2>
<p>max-width : 最大宽度 即如果元素width超过这个值则保持width为max-width</p>
<pre><code> .box1{
            max-width: 800px;
        }
     &lt;div class=&quot;box1&quot;&gt;一二三&lt;/div&gt;
     ```
     block独占一行 宽度为视窗宽度  如果宽度大于800px则元素width保持800px不变
min-width: 最小宽度 即如果元素width小于这个值则保持width为min-width


## 媒体查询
CSS媒体查询（CSS Media Queries）是CSS基本特性之一。它的作用就是让我们在相同的HTML基础上可以以不同的CSS实现适配各种终端的UI效果（比如，桌面端、iPad、双屏幕、折叠设备和移动手机等）。
媒体查询语法
媒体查询由一种媒体类型组成，并可包含一个或多个表达式，这些表达式可以解析为 true 或 false。
@media not|only mediatype and (expressions) {
  CSS-Code;
}
1. 如果不使用 not or  only  则mediatype 为可选 并且所有设备都可以 进行匹配
2. and为与符号 可以用and进行多个表达式的连接
3. 在表达式里为 媒体特性名称：媒体特性值 如 max-width: 900px  max-width 为特性名称 900px为具体的值 （视窗如果小于900px则为true）
### 媒体特性种类：
视窗和页面，显示媒体，颜色媒体，交互媒体特性等等。
此处主要用视窗和页面媒体特性来进行屏幕分辨率的分类
用到 width heigth orientation属性来处理
</code></pre>
<p>/* 智能手机 <em>/<br>
@media only screen and (max-width: 400px) { body { background-color: #F09A9D; } }<br>
/</em> 平板 <em>/<br>
@media only screen and (min-width: 401px) and (max-width: 960px) { body { background-color: #F5CF8E; } }<br>
/</em> PC、平板电脑 */<br>
@media only screen and (min-width: 961px) { body { background-color: #B2D6FF; } }</p>
<pre><code>上面三种情况 （tip：属性边界都包含在里面）
第一种 视窗比400px小 true
第二种 视窗大于等于401px 小于等于960px true
第三种 视窗大于等于961px true

### orientation （取向）
区分横屏竖屏
媒体特性值有两种
portrait：竖屏，屏幕视窗高度大于宽度
landscape：横屏，屏幕视窗宽度大于高度


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue学习]]></title>
        <id>https://huyifu.github.io/post/vue-xue-xi/</id>
        <link href="https://huyifu.github.io/post/vue-xue-xi/">
        </link>
        <updated>2021-04-05T10:14:41.000Z</updated>
        <content type="html"><![CDATA[<p>Vue的语法及其使用<br>
需要实例化</p>
<pre><code>var vm = new Vue({
  // 选项
})
 var vm = new Vue({
        el: '#vue_det', 进行与id为vue_det的元素进行绑定
        data: {    	//data定义属性
            site: &quot;菜鸟教程&quot;, 
            url: &quot;www.runoob.com&quot;,
            alexa: &quot;10000&quot;
        },
        methods: {  	//methods定义函数
            details: function() {
                return  this.site + &quot; - 学的不仅是技术，更是梦想！&quot;;
            }
        }
    })
    ```
html：
</code></pre>
<div id="vue_det">
    <h4>site : {{site}}</h4>
    <h4>url : {{url}}</h4>
    <h4>{{details()}}</h4>
</div>
```
通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：
```
<span v-once>这个将不会改变: {{ msg }}</span>
```
模板语法
使用 v-html 指令用于输出 html 代码：
```
 data: {
    message: '<h4>菜鸟教程</h4>'
  }
<pre><code>v-bind用于绑定数据和元素属性   v-bind:属性名=&quot; &quot;的格式简写成:属性名=&quot; &quot;
例如
</code></pre>
<p>&lt; a :class=&quot;data1&quot; :href=&quot;url&quot;&gt;click me</a><br>
data:{<br>
url:&quot;https://www.baidu.com&quot;,<br>
data1: {active:isActive} //此处为一个对象 也可以进行绑定<br>
}</p>
<pre><code>```
</code></pre>
<p>指令 (Directives) 是带有 v- 前缀的特殊 attribute。指令 attribute 的值预期是单个 JavaScript 表达式</p>
<p v-if="seen">现在你看到我了</p>
这里，v-if 指令将根据表达式 seen 的值的真假来插入/移除 <p> 元素。
<p>v-on 指令，它用于监听 DOM 事件：<br>
<a v-on:click="doSomething">...</a><br>
v-on:click =<br>
缩写<br>
@click =<br>
@[event]  =<br>
动态参数</p>
<p>计算属性  data里的computed 写入需要计算的表达式</p>
<pre><code>&lt;div id=&quot;example&quot;&gt;
  &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt;
  &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;
&lt;/div&gt;
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
</code></pre>
<p>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：<br>
v-bind:[attributeName]=&quot;url&quot;  即data中attributeName的值作为绑定的属性</p>
<h2 id="计算属性缓存-vs-方法">计算属性缓存 vs 方法</h2>
<p>vue 实例 中computed 与 methods 都可以基于某一个data进行表达式的运算</p>
<pre><code>methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('')
  }
}
</code></pre>
<p>与</p>
<pre><code>  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
</code></pre>
<h3 id="两者结果一致-但是计算属性是基于它们的响应式依赖进行缓存的">两者结果一致 但是计算属性是基于它们的响应式依赖进行缓存的</h3>
<p>意味着 如果所依赖的data没有进行更改 计算属性会立即返回之前的计算结果，而不必再次执行函数。  所有使用computed在某些时刻可以提高性能<br>
因为数据绑定 和依赖式的更新  可以不进行监听数据</p>
<pre><code>var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar'
  },
  computed: {
    fullName: function () {
      return this.firstName + ' ' + this.lastName
    }
  }
})
</code></pre>
<p>在firstName 或者 lastName 更改时候 fullName自动进行更改</p>
<p>computed  set 与get</p>
<pre><code> &lt;body&gt;
     &lt;div id=&quot;app&quot;&gt;
         {{fullName}}
     &lt;/div&gt;
    &lt;script&gt;
       var vm = new Vue({
           el: &quot;#app&quot;,
           data: {
               firstName:&quot;Ma&quot;,
               lastName:&quot;BinYan&quot;
           },
           computed:{
               fullName :{
                   get: function()
                   {return this.firstName+&quot; &quot;+this.lastName},
                  set : function(value)  //修改fullName的值时触发
                  {
                      var array = value.split(&quot; &quot;);
                       this.firstName=array[0];
                       this.lastName=array[1];
                   }
               }
           }
       })
    &lt;/script&gt;
  &lt;/body&gt;
</code></pre>
<p>侦听器<br>
虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p>
<p>绑定 HTML Class<br>
对象语法<br>
我们可以传给 v-bind:class 一个对象，以动态地切换 class：</p>
<div v-bind:class="{ active: isActive }"></div>
上面的语法表示 active 这个 class 存在与否将取决于数据 property isActive 的 truthiness。
<p>你可以在对象中传入更多字段来动态切换多个 class。此外，v-bind:class 指令也可以与普通的 class attribute 共存。当有如下模板：</p>
<div
  class="static"
  v-bind:class="{ active: isActive, 'text-danger': hasError }"
></div>
和如下 data：
<p>data: {<br>
isActive: true,<br>
hasError: false<br>
}<br>
结果渲染为：</p>
<pre><code>&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;

  &lt;style&gt;
   .styles{
      color: yellow;
  }
    &lt;/style&gt;
&lt;/head&gt;
    
  &lt;body&gt;
    &lt;div id=&quot;app&quot; &gt;
    &lt;span @click=&quot;handleClick&quot;
    :class=&quot;{styles: isActivated}&quot;&gt;XiaoMa&lt;/span&gt;
&lt;/div&gt;
     &lt;script&gt;
         var vm = new Vue({
             el:&quot;#app&quot;,
             data:{
                 isActivated : false
             },
             methods:{
              handleClick: function (){
                  this.isActivated=!this.isActivated;
              }
             }
         })
 &lt;/script&gt;
</code></pre>
<p>条件渲染<br>
v-if<br>
v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</p>
<h4 v-if="awesome">Vue is awesome!</h4>
也可以用 v-else 添加一个“else 块”：
<h4 v-if="awesome">Vue is awesome!</h4>
<h4 v-else>Oh no 😢</h4>
在 < template> 元素上使用 v-if 条件渲染分组
因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 < template> 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 < t emplate> 元素。
```
<template v-if="ok">
  <h1>Title</h1>
  <p>Paragraph 1</p>
  <p>Paragraph 2</p>
</template>
v-else-if 
<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Not A/B/C
</div>
```
<h3 id="vue-会尽可能高效地渲染元素通常会复用已有元素而不是从头开始渲染">Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。</h3>
<p>会使得某些元素直接复用 出现一些问题</p>
<pre><code>&lt;template v-if=&quot;loginType === 'username'&quot;&gt;
  &lt;label&gt;Username&lt;/label&gt;
  &lt;input placeholder=&quot;Enter your username&quot;&gt;
&lt;/template&gt;
&lt;template v-else&gt;
  &lt;label&gt;Email&lt;/label&gt;
  &lt;input placeholder=&quot;Enter your email address&quot;&gt;
&lt;/template&gt;
</code></pre>
<p>input里面的内容在切换时不会清除 因为vue在渲染时复用了另一个input<br>
解决方法—— 绑定key值<br>
:key =&quot;id&quot;  vue根据key来判断是不是相同的元素</p>
<p>v-show   保留有dom<br>
条件展示元素<br>
不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display。</p>
<h2 id="v-if-vs-v-show">v-if vs v-show</h2>
<p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>
v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<br>
相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。<br>
一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p>
<p>列表渲染<br>
在 v-for 里使用对象<br>
你也可以用 v-for 来遍历一个对象的 property。</p>
<pre><code>&lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt;
  &lt;li v-for=&quot;value in object&quot;&gt;
    {{ value }}
  &lt;/li&gt;
&lt;/ul&gt;
new Vue({
  el: '#v-for-object',
  data: {
    object: {
      title: 'How to do lists in Vue',
      author: 'Jane Doe',
      publishedAt: '2016-04-10'
    }
  }
})
</code></pre>
<p>结果：</p>
<p>你也可以提供第二个的参数为 property 名称 (也就是键名)：</p>
<div v-for="(value, name) in object">
  {{ name }}: {{ value }}
</div>
<p>还可以用第三个参数作为索引：</p>
<div v-for="(value, name, index) in object">
  {{ index }}. {{ name }}: {{ value }}
</div>
结果如下：
0.title: How to do lists in Vue,
1.author: Jane Doe,
2.publishedAt: 2016-04-10
<h2 id="遍历的特性">遍历的特性</h2>
<p>维护状态<br>
当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 track-by=&quot;$index&quot;。<br>
这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。<br>
为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute：</p>
<div v-for="item in items" v-bind:key="item.id">
  <!-- 内容 -->
</div>
建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。
<p>变更方法<br>
Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：<br>
push()<br>
pop()<br>
shift()<br>
unshift()<br>
splice()<br>
sort()<br>
reverse()<br>
tip：用数组下标可以来改变数据 但是不会触发视图更新</p>
<h2 id="使用ref获取dom">使用ref获取dom</h2>
<pre><code>&lt;body&gt;
    &lt;div id='app'&gt;
       &lt;div ref='hello' @click=&quot;handleClick&quot;&gt;
           click me
        此div绑定了一个ref hello
        在函数中使用this.$refs vue实例中所有的引用
        this.$refs.hello可以取到这个dom节点
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
  new Vue({
      el:'#app',
      methods: {
          handleClick : function(){
              alert(this.$refs.hello.innerHTML);
          }
      }

});
    &lt;/script&gt;
  &lt;/body&gt;

</code></pre>
<h2 id="组件的使用">组件的使用</h2>
<p>Vue.component('组件名称', {组件内容});<br>
在创建后 组件为可复用的vue实例<br>
组件作为自定义元素来使用：<br>
&lt;组件名&gt;&lt;/组件名&gt;</p>
<p>组件的注册<br>
Vue.componet 全局注册<br>
全局注册的组件可以用在其被注册之后的任何 (通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。<br>
局部注册<br>
var ComponentA = { /* ... <em>/ }<br>
var ComponentB = { /</em> ... <em>/ }<br>
var ComponentC = { /</em> ... */ }<br>
然后在 components 选项中定义你想要使用的组件：</p>
<pre><code>new Vue({
  el: '#app',
  components: {
    'component-a': ComponentA,
    'component-b': ComponentB
  }
})
</code></pre>
<p>对于 components 对象中的每个 property 来说，其 property 名就是自定义元素的名字，其 property 值就是这个组件的选项对象。</p>
<h3 id="tip局部组件的使用需要像上面那样声明-即局部组件中使用另一个需要声明">tip：局部组件的使用需要像上面那样声明  即局部组件中使用另一个需要声明</h3>
<p>var ComponentA = { /* ... */ }<br>
var ComponentB = {<br>
components: {<br>
'component-a': ComponentA<br>
},<br>
// ...<br>
}</p>
<h2 id="prop">Prop</h2>
<p>子组件设置props属性来接收父组件的数据<br>
单向数据流： 子组件不能改变父组件传来的值 父组件更新数据传给子组件的数据会进行更新<br>
如果需要更改并传给父组件可以：<br>
在子组件data中copy数据 并使用data中的数据进行传值</p>
<p>1 子局部组件创建  var a={}<br>
2 父组件在组件中声明 components:{ a : a}<br>
3 子组件在props属性中 声明好子组件需要接收到的数据 props:['data']<br>
4 在子组件调用时 利用props进行传值  <a :data= "需要传递的数据"></a><br>
5  子组件需要向父组件传值时 可以调用this.$emit(&quot;事件名&quot;,参数1) 来传值 触发自定义事件<br>
6  子组件上提前监听好了这个事件 在子组件触发这个事件开始调用处理函数 父组件里的方法进行处理<br>
7 处理完毕 父子组件相互传值成功</p>
<pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;
    &lt;title&gt;Model&lt;/title&gt;
    &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
 
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;p&gt;父子组件传值 子组件设置props属性接收数据&lt;/p&gt;
        &lt;counter :count=&quot;data1&quot; @change=&quot;handleChange&quot;&gt;&lt;/counter&gt;
        &lt;counter :count=&quot;data2&quot; @change=&quot;handleChange&quot;&gt;&lt;/counter&gt;
        &lt;p&gt;现在给父组件添加一个数据 值为两个counter的数字和 涉及子组件给父组件传值&lt;/p&gt;
        &lt;p&gt;涉及三步骤 子组件被点击触发自定义的change事件 然后父组件设置了监听属性监听了这个change事件 最后进行处理事件&lt;/p&gt;
        {{totalNum}}
    &lt;/div&gt;
    &lt;script&gt;
        var counter = {
            props:['count'],
            template:'&lt;div @click=&quot;handleClick&quot;&gt;{{number}}&lt;/div&gt;',
            methods:{
                handleClick:function(){
                    this.number++;
                    this.$emit('change',1);
                }
            },
            data:function(){
                return{
                    number: this.count
                }
            }
        }
       new Vue({
           el:'#app',
           components:{
               counter:counter
           },
            data: function(){
                return{
                    totalNum:0,
                    data1:0,
                    data2:0
                }
            },
            methods:{
                handleChange:function(value){
                  // alert(value);
                   this.totalNum+= value;
                }
            }
       }) 
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="tip-如果要子组件要传给父组件多个值">tip ： 如果要子组件要传给父组件多个值</h3>
<p>子组件： this.$emit( &quot;事件名&quot;, data1,data2)<br>
父组件： @事件名 = &quot;处理函数(arguments)&quot;  参数对象<br>
此时 data1为arguments[0]  data2为arguments[1] ...</p>
<h2 id="组件名">组件名</h2>
<p>遵循 W3C 规范中的自定义组件名 (字母全小写且必须包含一个连字符)。<br>
定义组件名的方式有两种：</p>
<h3 id="使用-kebab-case">使用 kebab-case</h3>
<p>Vue.component('my-component-name', { /* ... */ })<br>
当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 <my-component-name>。</p>
<h3 id="使用-pascalcase">使用 PascalCase</h3>
<p>Vue.component('MyComponentName', { /* ... */ })<br>
当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 <my-component-name> 和 <MyComponentName> 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。<br>
tip：最好选择一种全部使用</p>
<p>组件参数校验</p>
<pre><code>Vue.component('my-component', {
  props: {
    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: {
      type: String,
      required: true
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100
    },
    // 带有默认值的对象
    propE: {
      type: Object,
      // 对象或数组默认值必须从一个工厂函数获取
      default: function () {
        return { message: 'hello' }
      }
    },
    // 自定义验证函数  （返回一个布尔值）
    propF: {
      validator: function (value) {
        // 这个值必须匹配下列字符串中的一个
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
  }
})
</code></pre>
<h2 id="props特性与非props特性">props特性与非props特性</h2>
<ul>
<li>props特性：<br>
子组件声明了传递参数的接收<br>
传递的参数不会在dom标签中显示<br>
可以通过插值表达式或者通过this.content去取得该属性中的内容。</li>
<li>非props特性：<br>
子组件不声明从父组件接收而来的参数<br>
显示在子组件最外层DOM标签的HTML属性里面</li>
</ul>
<p>组件绑定原生事件<br>
&lt;child @handle=&quot;handleChildClick&quot;&gt;</child>  在组件上绑定事件为自定义事件<br>
template: '&lt;div @click=&quot;handleClick&quot;&gt;Click me</div>'  在模板里直接会被渲染 所以绑定原生事件  （一般在这个原生事件里可以this.$emit('handle') 触发另一个事件)<br>
代码如下：</p>
<pre><code>&lt;body&gt;
    &lt;div id=&quot;app&quot; &gt;
        &lt;child @handle=&quot;handleChildClick&quot;&gt;&lt;/child&gt;
  &lt;/div&gt;
     &lt;script&gt;
         var child = {
             template:  '&lt;div @click=&quot;handleClick&quot;&gt;Click me&lt;/div&gt;',
             methods:{
                 handleClick :function(){
                     alert('原生事件触发');
                     this.$emit('handle');
                 }
             }
         }
         new Vue({
             el:'#app',
            components:{
                child : child,
            },
            methods:{
                handleChildClick :function(){
                    alert('自定义事件触发');
                }
            }
         })
      &lt;/script&gt;
  &lt;/body&gt;
</code></pre>
<p>原生事件触发 -》 this.$emit -》 监听子组件的自定义事件接收到 -》 自定义事件触发</p>
<h2 id="直接监听子组件的原生事件">直接监听子组件的原生事件</h2>
<p>使用修饰符 .native<br>
代码如下：</p>
<pre><code>&lt;body&gt;
    &lt;div id=&quot;app&quot; &gt;
        &lt;child @click.native=&quot;handleChildClick&quot;&gt;&lt;/child&gt;
    &lt;/div&gt;
     &lt;script&gt;
         var child = {
             template:  '&lt;div&gt;Click me&lt;/div&gt;',
         }
         new Vue({
             el:'#app',
            components:{
                child : child,
            },
            methods:{
                handleChildClick :function(){
                    alert('利用修饰符直接触发原生事件');
                }
            }
         })
      &lt;/script&gt;
  &lt;/body&gt;
</code></pre>
<h2 id="非父子组件之间传值">非父子组件之间传值</h2>
<p>(Bus/总线/发布者订阅模式/观察者模式）<br>
在vue最顶部</p>
<ul>
<li>Vue.prototype.bus = new Vue();<br>
在Vue的prototype挂载了一个bus属性 这个属性是指向vue的实例 调用 Vue 或者new Vue时，每个组件都会有一个bus属性，因为以后不管是 Vue 的属性还是 Vue 的实例，都是通过 Vue 来创建的，而我在 Vue 的prototype上挂载了一个bus的属性。</li>
<li>this.bus.$emit('触发事件', data)  传递的实例</li>
<li>this.bus.$on('触发事件', msg =&gt; {console.log('回调函数执行 msg为传递的数据'})  接收的实例</li>
</ul>
<p>代码如下：</p>
<pre><code>&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;sendchild :msg=&quot;1&quot;&gt;&lt;/sendchild&gt;
        &lt;acceptchild :msg=&quot;2&quot;&gt;&lt;/acceptchild&gt;
    &lt;/div&gt;
    &lt;script&gt;
       Vue.prototype.bus = new Vue();
        var sendchild= {
            template: '&lt;div @click=&quot;handleClick&quot;&gt;{{content}}&lt;/div&gt;',
            data: function(){
                return {
                    content: this.msg
                }
            },
            methods:{
                handleClick:function (){
                    alert('send孩子开始传值,用bus属性 emit transport事件 数据为content');
                    this.bus.$emit('transport',this.content);
                },
            },
           mounted:function(){
                console.log('send孩子实例创建，监听transport事件');
                this.bus.$on('transport',msg =&gt;console.log('send孩子接收到msg数据,数据为'+msg));
           },
            props:{
                msg: Number
            },
        }
        var acceptchild= {
            data: function(){
                return {
                    content: this.msg
                }
            },
            methods:{
                handleClick:function (){
                    alert('accept孩子开始传值,用bus属性emit transport事件 数据为content');
                    this.bus.$emit('transport',this.content);
                },
            },
            mounted:function(){
                console.log('accept孩子实例创建，监听transport事件');
                this.bus.$on('transport',msg =&gt;console.log('accept孩子接收到msg数据,数据为'+msg));
           },
            props:{
                msg: Number
            },
            template: '&lt;div @click=&quot;handleClick&quot;&gt;{{content}}&lt;/div&gt;'
        }
        new Vue({
            el:'#app',
            components:{
                sendchild : sendchild,
                acceptchild: acceptchild
            }
        })
    &lt;/script&gt;
  &lt;/body&gt;
</code></pre>
<p>使用插槽 slot  ——Vue 实现了一套内容分发的 API，将<slot>元素作为承载分发内容的出口<br>
子组件设置slot占位  父组件为这个slot填充内容</p>
<pre><code>&lt;div id='app'&gt;
        &lt;!-- child组件里面写的内容会默认插值到模板里的slot标签里 --&gt;
        &lt;child&gt;
            &lt;h1&gt;DELL&lt;/h1&gt;
        &lt;/child&gt;
    &lt;/div&gt;
    &lt;script&gt;
     Vue.component('child',{
         template: `
                &lt;div&gt;
                    &lt;p&gt;firstLine&lt;/p&gt;
                    &lt;slot&gt;slot标签里面为默认内容&lt;/slot&gt;
                &lt;/div&gt;
                `
     })
     new Vue({
         el: '#app'
     })
    &lt;/script&gt;
</code></pre>
<p>显示<br>
firstLine<br>
DELL<br>
tip：如果child组件无内容 即<child></child><br>
显示<br>
firstLine<br>
slot标签里面为默认内容</p>
<p>如果想有多个插槽 使用具名插槽</p>
<pre><code>  &lt;div id='app'&gt;
        &lt;!-- child组件里面写的内容会默认插值到模板里的slot标签里 --&gt;
        &lt;child&gt;
            &lt;header slot=&quot;header&quot;&gt;Header&lt;/header&gt;
            &lt;footer slot=&quot;footer&quot;&gt;Footer&lt;/footer&gt;
        &lt;/child&gt;
    &lt;/div&gt;
    &lt;script&gt;
     Vue.component('child',{
         template: `
                &lt;div&gt;
                     &lt;slot name='header'&gt;default Header&lt;/slot&gt;
                    &lt;div class=&quot;main&quot;&gt;Main&lt;/div&gt;
                    &lt;slot name='footer'&gt;default Footer&lt;/slot&gt;
                &lt;/div&gt;
                `
     })
     new Vue({
         el: '#app'
     })
    &lt;/script&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Js 执行上下文（执行环境）]]></title>
        <id>https://huyifu.github.io/post/js-zhi-xing-shang-xia-wen-zhi-xing-huan-jing/</id>
        <link href="https://huyifu.github.io/post/js-zhi-xing-shang-xia-wen-zhi-xing-huan-jing/">
        </link>
        <updated>2021-03-30T16:13:19.000Z</updated>
        <content type="html"><![CDATA[<p>引言：在兜兜转转一圈后总算是大概理清了 执行环境 this 词法环境等等概念 如果之后学习又有新的看法和解释继续修改<br>
行文思路： 执行上下文 的类型 存储方式<br>
执行上下文的生命周期 和结构<br>
结构一 es3<br>
变量对象(variable object)，this指针(this value)，作用域链(scope chain) 三部分分别讲解在执行上下文在生命周期里的变化<br>
结构二 es6<br>
词法环境组件和变量环境组件   两部分分别讲解<br>
在执行上下文在生命周期里的变化<br>
总结：</p>
<h1 id="js是解释执行的语言">JS是解释执行的语言</h1>
<p>因此代码会通过先解析后执行的方式进行运行，而这个过程JS引擎会构造出一个抽象的环境 这个环境就是执行环境(Execution Context，也称为&quot;执行上下文&quot;)</p>
<h2 id="执行上下文有三种类型">执行上下文有三种类型</h2>
<ol>
<li>全局执行上下文： 这是默认的、最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1. 创建一个全局对象，在浏览器中这个全局对象就是 window 对象。2. 将 this 指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。</li>
<li>函数执行上下文： 每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都拥有自己的执行上下文，但是只有在函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。每当一个新的执行上下文被创建，它都会按照特定的顺序执行一系列步骤，具体过程将在本文后面讨论。</li>
<li>Eval 函数执行上下文： 运行在 eval 函数中的代码也获得了自己的执行上下文，但由于 Javascript 开发人员不常用 eval 函数，所以在这里不再讨论。</li>
</ol>
<h2 id="执行上下文的存储方式">执行上下文的存储方式</h2>
<p>每一个上下文在本质上都是一种作用域层级。每个代码段开始执行的时候都会创建一个新的上下文来运行它，并且在代码退出的时候销毁掉。而这种方式其实是一种堆栈的方式<br>
在JS中，是以栈(后进先出)这种数据结构存储执行上下文的，也就是我们所说的 执行栈。<br>
执行JS代码时，JS引擎首先会创建一个全局执行上下文，并压入栈底；之后每当 调用 一个函数时，都会为该函数创建一个函数执行上下文，并压入栈。<br>
之后引擎会执行栈顶的函数，函数执行结束后，该函数执行上下文从栈中弹出；再执行下一个函数，直到全部出栈。</p>
<pre><code>function A() {
  console.log('this is A')
  function B() {
    console.log('this is B')
  }
  B()
}
A()
</code></pre>
<p>执行上下文栈<br>
调用栈依次为：<br>
[ 全局环境 ]<br>
[ 全局环境，A 执行环境 ] A()，调用 A 函数，A 执行环境入栈<br>
[ 全局环境，A 执行环境，B 执行环境 ] A 函数执行时，遇到 B()， 调用 B 函数，B 入栈<br>
[ 全局环境，A 执行环境 ] B 执行结束，出栈<br>
[ 全局环境 ] A 执行结束出栈<br>
[全局环境退出] 所有代码执行完毕 全局环境出栈<br>
关于执行栈有以下特点：</p>
<ul>
<li>JavaScript执行在单线程上，所有的代码都是排队执行。</li>
<li>一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。</li>
<li>每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。</li>
<li>浏览器的JS执行引擎总是访问栈顶的执行上下文。</li>
<li>全局上下文只有唯一的一个，它在浏览器关闭时出栈。</li>
<li>关于递归函数——即多次调用自身的函数，需要特别注意：每次递归调用自身都会创建一个新的上下文。这使得 JavaScript 运行时能够追踪递归的层级以及从递归中得到的返回值，但这也意味着每次递归都会消耗内存来创建新的上下文。</li>
</ul>
<h2 id="创建执行上下文有两个阶段1-创建阶段-和-2-执行阶段-生命周期">创建执行上下文有两个阶段：1) 创建阶段 和 2) 执行阶段。（生命周期）</h2>
<p>ps：在执行上下文出栈会有垃圾回收机制，本文不做探讨<br>
在查询大量资料后：发现执行上下文的结构有两种</p>
<h3 id="1-es3-变量对象variable-objectthis指针this-value作用域链scope-chain">1 es3： 变量对象(variable object)，this指针(this value)，作用域链(scope chain)</h3>
<h3 id="2-es6-词法环境组件和变量环境组件-伴随着let等新内容而重新定义">2 es6： 词法环境组件和变量环境组件 （伴随着let等新内容而重新定义）</h3>
<p>先来探讨es3  其中闭包和提升的原理就在这里<br>
es3 执行上下文的生命周期<br>
创建阶段： 创建变量对象 建立作用域链 确定this指针指向<br>
指行阶段： 变量对象VO 变成活动对象 AO<br>
回收阶段： 执行上下文出栈等待垃圾回收机制</p>
<h3 id="变量对象">变量对象</h3>
<p>变量对象(variable object) 是与执行上下文相关的 数据作用域(scope of data) 。<br>
它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 和函数的形参</p>
<ul>
<li>全局上下文的变量对象 (VO === this === global)</li>
</ul>
<p>只有全局上下文的变量对象允许通过VO的属性名称来间接访问(因为在全局上下文里，全局对象自身就是变量对象，稍后会详细介绍)，在其它上下文中是不能直接访问VO对象的，因为它只是内部机制的一个实现。<br>
全局对象就是全局变量对象<br>
全局对象初始创建阶段将Math、String、Date、parseInt作为自身属性，等属性初始化，同样也可以有额外创建的其它对象作为属性（其可以指向到全局对象自身）。例如，在DOM中，全局对象的window属性就可以引用全局对象自身(当然，并不是所有的具体实现都是这样)：</p>
<pre><code>global = {
  Math: &lt;...&gt;,
  String: &lt;...&gt;
  ...
  ...
  window: global //引用自身
};
</code></pre>
<p>VO(globalContext) === global;</p>
<ul>
<li>函数上下文的变量对象</li>
</ul>
<p>在函数执行上下文中，VO是不能直接访问的，此时由活动对象(activation object,缩写为AO)扮演VO的角色。<br>
活动对象是在进入函数上下文时刻被创建的，它通过函数的arguments属性初始化。arguments属性的值是Arguments对象。<br>
Arguments对象是活动对象的一个属性，它包括如下属性：<br>
callee — 指向当前函数的引用<br>
length — 真正传递的参数个数<br>
properties-indexes (字符串类型的整数) 属性的值就是函数的参数值(按参数列表从左到右排列)。 properties-indexes内部元素的个数等于arguments.length. properties-indexes 的值和实际传递进来的参数之间是共享的。<br>
以下是例子供理解：</p>
<pre><code>function foo(x, y, z) {
  // 声明的函数参数数量arguments (x, y, z)
  alert(foo.length); // 3
  // 真正传进来的参数个数(only x, y)
  alert(arguments.length); // 2
  // 参数的callee是函数自身
  alert(arguments.callee === foo); // true
  // 参数共享
  alert(x === arguments[0]); // true
  alert(x); // 10
  arguments[0] = 20;
  alert(x); // 20
  x = 30;
  alert(arguments[0]); // 30
  // 不过，没有传进来的参数z，和参数的第3个索引值是不共享的
  z = 40;
  alert(arguments[2]); // undefined
  arguments[2] = 50;
  alert(z); // 40
}
foo(10, 20);
</code></pre>
<p>两种变量对象已经解释完毕<br>
执行上下文创建阶段结束后 现在在执行上下文之前 VO的值含有：<br>
函数的所有形参(如果我们是在函数执行上下文中)<br>
由名称和对应值组成的一个变量对象的属性被创建；没有传递对应参数的话，那么由名称和undefined值组成的一种变量对象的属性也将被创建。<br>
所有函数声明(FunctionDeclaration, FD)<br>
由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建；如果变量对象已经存在相同名称的属性，则完全替换这个属性。<br>
所有变量声明(var, VariableDeclaration)<br>
由名称和对应值（undefined）组成一个变量对象的属性被创建；如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。<br>
可以来看这个例子</p>
<pre><code>function outerFun (arg1, arg2) {
    var outerV1 = 1
    var outerV2 = 2
    function innerFun1 () {
        var innerV1 = 3;
        var innerV2 = 4;
        console.log('i am innerFun1...')
    }
    function innerFun2 () {
        console.log('i am innerFun2...')
    }
    function outerV2 () {
        return 'i am outerV2'
    }
}
outerFun(1);
</code></pre>
<p>此处VO内容有三部分</p>
<ol>
<li>arguments属性 即Arguments 对象<br>
arguments:  Arguments Object<br>
这个对象属性  有<br>
arguments.length: 1 只传值了一个<br>
arguments.callee: outerFun的地址<br>
arguments[@@iterator]<br>
返回一个新的Array 迭代器 对象，该对象包含参数中每个索引的值。</li>
<li>所有变量的声明：此时为undefinde<br>
outerV1: undefined<br>
outerV2: undefined</li>
<li>所有函数的声明： 值为该函数所在内存的地址<br>
innerFun1 : innerFun1 reference  （ innerFun1 引用）<br>
innerFun2 : innerFun2 reference  （ innerFun2 引用）</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node 框架 Express学习]]></title>
        <id>https://huyifu.github.io/post/node-kuang-jia-express-xue-xi/</id>
        <link href="https://huyifu.github.io/post/node-kuang-jia-express-xue-xi/">
        </link>
        <updated>2021-03-30T08:43:15.000Z</updated>
        <summary type="html"><![CDATA[<p>Express框架<br>
提供简洁路由定义方式<br>
对HTTP请求参数 简化处理<br>
支持模板引擎<br>
提供中间件 控制HTTP请求</p>
<p>中间件<br>
一堆方法 接收请求 对请求响应  也可以交给下一个中间件继续处理<br>
两个部分组成  中间件方法和请求处理函数<br>
app.get('请求路径','处理函数')   方法express提供</p>
<p>简单的应用 将.get请求分成两个中间件进行处理<br>
next 将请求的控制权交给下一个中间件<br>
//引入express框架</p>
<pre><code>const express = require('express');
const app = express();//创建服务器
app.get('/',(req,res,next) =&gt;{
    req.addname= &quot;在请求头添加的属性&quot;;
    next();
});
app.get('/',(req,res) =&gt;{
    res.send(req.addname);
});
app.listen(3000);
console.log(&quot;网站启动 端口3000&quot;);
</code></pre>
<p>app.use   匹配所有的请求  因此如果后续要继续处理 要使用next()<br>
app.use('/某一个请求路径',(req,res,next))  可以指定某一个路径匹配的所有请求</p>
<p>中间件的应用<br>
1对页面访问某路径进行登录拦截  1 use 进行判断 如果已经登录则放行next() 2 没有登录 返回没有登录的信息<br>
2 页面维护  直接放最前面进行拦截   不设置路径则匹配所有路径<br>
3 自定义404路径  放在最后面没有匹配的路径  不设置路径则匹配所有路径</p>
<p>错误处理中间件</p>
<pre><code> thorow new Error('发生了错误'); 
app.use( (err,req,res,next) =&gt;{
	//err 为手动抛出的Error对象
	res.status(500).send(err.message); //返回 err对象的错误信息属性
} )
</code></pre>
<p>捕获异步代码错误<br>
try catch块</p>
<pre><code>const promisify = require('util').promisify
const NewreadFile = promisify('fs.readFile') 改造读取文件成返回promise对象的异步函数
app.get('/', async (req,res,next) =&gt;{
     try {
   await NewreadFile('.');
}
catch (ex){
   next(ex);	
}
})
</code></pre>
<p>捕获到错误的话 程序不会因为这个错误而终止进行—— 健壮性</p>
<p>构建模块化路由<br>
express下的Router 路由对象<br>
为这个路由对象可以匹配请求路径</p>
<pre><code>const express = require('express');
const app = express();
//创建路由对象
const home = express.Router();
app.use('/home',home);
//创建二级路由
home.use('/index',(req,res)=&gt;{
    res.send(&quot;二级路由 /home/index！&quot;);
})
app.listen(3000);
</code></pre>
<p>其中home模块 可以写在别的js中 通过导入导出进行模块的使用<br>
在主index.js 中<br>
这样创建二级路由<br>
const xx = require('')<br>
app.use('/xx路径', xx);</p>
<p>Get参数<br>
在请求函数中 使用req.query 自动将请求参数获取并转化成对象的形式<br>
app.get('/index',(req,res)=&gt;{<br>
res.send(req.query);<br>
});</p>
<p>Post 请求参数获取<br>
使用借助第三包 body-parser<br>
const bodyParser = require('body-parser');<br>
而且需要在最开始对这个模块进行配置 默认<br>
app.use(bodyParser.urlencoded( { extended: false} );</p>
<pre><code>const bodyParser = require('body-parser');
const express = require('express');
const app = express();
app.use(bodyParser.urlencoded({ extended: false}));
app.post('/index',(req,res)=&gt;{
    res.send(req.body);
});
app.listen(3000);
</code></pre>
<p>路由参数 路由里面附带数据 ——  get传递和获取参数的另一种方式</p>
]]></summary>
        <content type="html"><![CDATA[<p>Express框架<br>
提供简洁路由定义方式<br>
对HTTP请求参数 简化处理<br>
支持模板引擎<br>
提供中间件 控制HTTP请求</p>
<p>中间件<br>
一堆方法 接收请求 对请求响应  也可以交给下一个中间件继续处理<br>
两个部分组成  中间件方法和请求处理函数<br>
app.get('请求路径','处理函数')   方法express提供</p>
<p>简单的应用 将.get请求分成两个中间件进行处理<br>
next 将请求的控制权交给下一个中间件<br>
//引入express框架</p>
<pre><code>const express = require('express');
const app = express();//创建服务器
app.get('/',(req,res,next) =&gt;{
    req.addname= &quot;在请求头添加的属性&quot;;
    next();
});
app.get('/',(req,res) =&gt;{
    res.send(req.addname);
});
app.listen(3000);
console.log(&quot;网站启动 端口3000&quot;);
</code></pre>
<p>app.use   匹配所有的请求  因此如果后续要继续处理 要使用next()<br>
app.use('/某一个请求路径',(req,res,next))  可以指定某一个路径匹配的所有请求</p>
<p>中间件的应用<br>
1对页面访问某路径进行登录拦截  1 use 进行判断 如果已经登录则放行next() 2 没有登录 返回没有登录的信息<br>
2 页面维护  直接放最前面进行拦截   不设置路径则匹配所有路径<br>
3 自定义404路径  放在最后面没有匹配的路径  不设置路径则匹配所有路径</p>
<p>错误处理中间件</p>
<pre><code> thorow new Error('发生了错误'); 
app.use( (err,req,res,next) =&gt;{
	//err 为手动抛出的Error对象
	res.status(500).send(err.message); //返回 err对象的错误信息属性
} )
</code></pre>
<p>捕获异步代码错误<br>
try catch块</p>
<pre><code>const promisify = require('util').promisify
const NewreadFile = promisify('fs.readFile') 改造读取文件成返回promise对象的异步函数
app.get('/', async (req,res,next) =&gt;{
     try {
   await NewreadFile('.');
}
catch (ex){
   next(ex);	
}
})
</code></pre>
<p>捕获到错误的话 程序不会因为这个错误而终止进行—— 健壮性</p>
<p>构建模块化路由<br>
express下的Router 路由对象<br>
为这个路由对象可以匹配请求路径</p>
<pre><code>const express = require('express');
const app = express();
//创建路由对象
const home = express.Router();
app.use('/home',home);
//创建二级路由
home.use('/index',(req,res)=&gt;{
    res.send(&quot;二级路由 /home/index！&quot;);
})
app.listen(3000);
</code></pre>
<p>其中home模块 可以写在别的js中 通过导入导出进行模块的使用<br>
在主index.js 中<br>
这样创建二级路由<br>
const xx = require('')<br>
app.use('/xx路径', xx);</p>
<p>Get参数<br>
在请求函数中 使用req.query 自动将请求参数获取并转化成对象的形式<br>
app.get('/index',(req,res)=&gt;{<br>
res.send(req.query);<br>
});</p>
<p>Post 请求参数获取<br>
使用借助第三包 body-parser<br>
const bodyParser = require('body-parser');<br>
而且需要在最开始对这个模块进行配置 默认<br>
app.use(bodyParser.urlencoded( { extended: false} );</p>
<pre><code>const bodyParser = require('body-parser');
const express = require('express');
const app = express();
app.use(bodyParser.urlencoded({ extended: false}));
app.post('/index',(req,res)=&gt;{
    res.send(req.body);
});
app.listen(3000);
</code></pre>
<p>路由参数 路由里面附带数据 ——  get传递和获取参数的另一种方式</p>
<!-- more -->
<p>app.get('/find/:id/:name', (req,res)=&gt; console.log(req.params)😉 req.params为对象<br>
tip：客户端访问find路径时必须带有id name参数 否则无法获取请求<br>
http://localhost:3000/find/111/name<br>
{id:111,name:name}</p>
<p>访问静态文件<br>
使用express.static 方法<br>
app.use(express.static('放置静态文件的目录'))  客户端可直接通过路径访问到</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS 箭头函数]]></title>
        <id>https://huyifu.github.io/post/js-jian-tou-han-shu/</id>
        <link href="https://huyifu.github.io/post/js-jian-tou-han-shu/">
        </link>
        <updated>2021-03-29T12:09:30.000Z</updated>
        <content type="html"><![CDATA[<p>引言：在学习nonde 回调函数时频繁出现箭头函数 此文来详细了解箭头函数深入的特性。</p>
<h3 id="箭头函数表达式的语法比函数表达式更简洁并且没有自己的thisargumentssupernewtarget-箭头函数表达式更适用于那些本来需要匿名函数的地方并且它不能用作构造函数-因为构造函数用this指向新构建的对象">箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super，new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。因为构造函数用this指向新构建的对象。</h3>
<p>五种基础表达形式</p>
<pre><code>1. (param1, param2, …, paramN) =&gt; { statements } //标准 参数1~N 执行statements
2. (param1, param2, …, paramN) =&gt; expression // 只有一个表达式 相当于 相当于：(param1, param2, …, paramN) =&gt;{ return expression; }
3. singleParam =&gt; { statements }  //只有一个参数可不写（）
4. () =&gt;{statements}  //无参数使用（） 应用1.
5.() =&gt; expression   //无参数使用（） 应用2.
</code></pre>
<p>此外还有其他表达形式</p>
<pre><code>//加括号的函数体返回对象字面量表达式：
params =&gt; ({foo: bar})
//支持剩余参数和默认参数
(param1, param2, ...rest) =&gt; { statements }
(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; {
statements }
//同样支持参数列表解构
let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c;
f();  // 6
</code></pre>
<h3 id="箭头函数没有单独的this箭头函数不会创建自己的this它只会从自己的作用域链的上一层继承this">箭头函数没有单独的this，箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。</h3>
<p>以下为用this时候出现的一些问题</p>
<pre><code>function Counter() {
  this.num = 0;
  this.timer = setInterval(function add() {
    this.num++;
    console.log(this.num);
  }, 1000);
}
var a = new Counter();
</code></pre>
<p>输出：<br>
NaN<br>
.. 1s一个<br>
this指向window对象  this理解另一篇进行深入探讨  此处出现问题<br>
当使用箭头函数改写</p>
<pre><code>function Counter() {
  this.num = 0;
  this.timer = setInterval(()=&gt;{
      this.num++;
      console.log(num);
  },1000)
}
var a = new Counter();
</code></pre>
<p>预期输出<br>
1<br>
2<br>
..</p>
<h3 id="通过call-apply调用箭头函数">通过call、apply调用箭头函数</h3>
<p>由于箭头函数没有自己的this指针，通过call()、apply()方法调用时，第一个参数会被忽略。（箭头函数中若用了this，这个this指向包裹箭头函数的第一个普通函数的 this。）</p>
<h3 id="不绑定arguments">不绑定arguments</h3>
<p>大多数情况下，使用剩余参数是相较于arguments对象的更好选择。</p>
<h3 id="箭头函数没有prototype属性">箭头函数没有prototype属性。</h3>
<pre><code>var Foo = () =&gt; {};
console.log(Foo.prototype); // undefined
</code></pre>
<h3 id="闭包">闭包</h3>
<pre><code>// 标准的闭包函数
function A(){
      var i=0;
      return function b(){
              return (++i);
      };
};
var v=A();
v();    //1
v();    //2
//箭头函数体的闭包（ i=0 是默认参数）
var Add = (i=0) =&gt; {return (() =&gt; (++i) )};
var v = Add();
v();           //1
v();           //2
//因为仅有一个返回，return 及括号（）也可以省略
var Add = (i=0)=&gt; ()=&gt; (++i);
</code></pre>
<h2 id="总结">总结：</h2>
<ul>
<li>没有 this</li>
<li>没有 arguments</li>
<li>不能使用 new 进行调用</li>
<li>它们也没有 super</li>
</ul>
]]></content>
    </entry>
</feed>
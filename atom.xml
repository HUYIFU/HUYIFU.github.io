<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://huyifu.github.io</id>
    <title>古月的blog</title>
    <updated>2021-03-24T12:48:06.020Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://huyifu.github.io"/>
    <link rel="self" href="https://huyifu.github.io/atom.xml"/>
    <subtitle>123455
</subtitle>
    <logo>https://huyifu.github.io/images/avatar.png</logo>
    <icon>https://huyifu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 古月的blog</rights>
    <entry>
        <title type="html"><![CDATA[Node.js 学习]]></title>
        <id>https://huyifu.github.io/post/nodejs-xue-xi/</id>
        <link href="https://huyifu.github.io/post/nodejs-xue-xi/">
        </link>
        <updated>2021-03-22T13:24:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="node三部分">node三部分</h1>
<p>引入required模块：我们可以使用require指令来载入Node.js模块。</p>
<p>创建服务器：服务器可以监听客户端的请求，类似于Apache 、Nginx等HTTP服务器。</p>
<p>接收请求与响应请求：服务器很容易创建，客户端可以使用浏览器或终端发送HTTP请求，服务器接收请求后返回响应数据。</p>
<h3 id="nvm和npm关系">nvm和npm关系</h3>
<p>nvm：nodejs 版本管理工具。<br>
也就是说：一个 nvm 可以管理很多 node 版本和 npm 版本。<br>
nodejs：在项目开发时的所需要的代码库<br>
npm：nodejs 包管理工具。<br>
在安装的 nodejs 的时候，npm 也会跟着一起安装，它是包管理工具。<br>
nvm 管理 nodejs 和 npm 的版本<br>
npm 可以管理 nodejs 的第三方插件</p>
<h3 id="使用模块化开发的原因">使用模块化开发的原因</h3>
<p>JS 文件依赖问题<br>
a.js-&gt;b.js-&gt;c.js  c.js无法单独使用<br>
命名冲突<br>
c.js num=1 a.js num=2</p>
<h3 id="node-模块化开发规范">node 模块化开发规范</h3>
<p>一个js文件就是一个模块 模块内部变量函数默认情况下在外部无法得到<br>
模块内部使用exports对象进行成员导出 使用require方法导入其他模块<br>
另一种方式<br>
module.exports.version = version;<br>
exports是module.exports的别名 指向引用关系 指向同一个导出对象<br>
当指向不同对象 导出对象是moudule.exports对象</p>
<h2 id="系统模块">系统模块</h2>
<p>系统模块 node运行环境提供的API<br>
PS: 回调函数 （err，doc） =&gt; {}   如果成功 err是NULL 不成功是一个对象</p>
<h3 id="fs-文件操作">fs 文件操作</h3>
<p>引入 const fs = require('fs')<br>
读取<br>
fs.readFile('文件路径/文件名称',['文件编码'],callback); 【】代表可选参数<br>
写入<br>
fs.writeFile('文件路径/文件名称','数据',callback);</p>
<h3 id="path-路径操作">path 路径操作</h3>
<p>路径拼接 不同操作系统路径分隔符不统一 windows / \  Linux /<br>
const path = require('path')<br>
const finalPath = path.join('a','b','c')<br>
finalPath -&gt;  a\b\c<br>
结合<br>
const fs = require('fs');<br>
const path = require('path');<br>
TIP 使用__dirname  （两个下划线）<br>
当前js文件当前文件夹的绝对路径<br>
因此路径可以表示为  path.join(__dirname, 'xx.js')   join 会自动添加<br>
fs.readFile()</p>
<p>TIP:</p>
<h3 id="相对路径和绝对路径">相对路径和绝对路径</h3>
<p>绝大部分使用绝对路径   因为相对路径是相对的命令行工具的当前工作目录<br>
读取文件 设置文件路径 绝对路径</p>
<h2 id="第三方模块">第三方模块</h2>
<p>三方模块 两种形式<br>
以js文件存在 提供API接口  -&gt; 具体功能<br>
命令行工具形式存在 辅助项目开发</p>
<h3 id="三方模块-nodemon-命令行工具">三方模块 nodemon 命令行工具</h3>
<p>cmd 可以执行 但是vs终端无法执行？？</p>
<h3 id="nrm">nrm</h3>
<p>npm下载地址切换工具<br>
npm默认下载地址 npmjs.com<br>
国内下载地址服务器同步 npm.taobao.org<br>
查询下载地址列表 nrm ls<br>
切换npm下载地址 nrm use 下载地址</p>
<p>TIP:<br>
clear 清屏   上箭头 上一次命令 下箭头 下一次命令<br>
ctrl C 终止操作</p>
<h3 id="gulp">Gulp</h3>
<p>基于node平台开发的前端构建工具<br>
将机械化操作变成命令</p>
<p>功能<br>
HTML CSS JS 压缩合并<br>
语法转换 es6 ..less..<br>
修改文件浏览器自动刷新<br>
使用</p>
<p>1使用npm install gulp下载gulp库文件<br>
（命令行当前文件下配置好了 node_modules文件夹和package-lock.json)<br>
2在项目根目录下建立gulpfile.js文件<br>
（命名固定了）<br>
3重构项目的文件夹结构 src目录放置源代码文件 dist目录放置构建后文件<br>
4在gulpfile.js文件中编写任务.<br>
5在命令行工具中执行gulp任务</p>
<p>方法<br>
gulp.src() 获取任务要处理的文件<br>
gulp.dest() 输出文件<br>
gulp.task() 建立gulp任务<br>
gulp.watch() 监考文件变化</p>
<p>gulp.task('任务的名称',() =&gt;{<br>
}) ;</p>
<p>gulp-cli  命名行工具<br>
执行任务  项目根目录 gulp 任务名称<br>
Gulp插件<br>
gulp-htmlmin: html 文件压缩</p>
<pre><code>// html压缩任务
// html文件中代码的压缩操作
// 抽取html文件中的公共代码
const htmlmin = require('gulp-htmlmin');
const fileinClude = require('gulp-file-include');
gulp.task('htmlmin',()=&gt;{
    //*. 所有的文件
    gulp.src('./src/*.html')
        //抽取放入common文件夹
        .pipe(fileinClude())
       //压缩
      .pipe(htmlmin({collapseWhitespace: true}))
      .pipe(gulp.dest('dist'));
});
</code></pre>
<p>@@include('./common/head.html')<br>
将公共代码引入进来<br>
gulp-csso :压缩css<br>
gulp-file-include 公共文件包含<br>
.....</p>
<p>构建任务<br>
TIP 当任务取名为defult gulp命令直接运行 gulp defult<br>
gulp.task('defult',['任务一名字','任务二名字'],....)</p>
<h3 id="packagejson">package.json</h3>
<p>（1）node_modules文件夹的问题<br>
文件夹以及文件过多过碎，当我们将项目整体拷贝给别人的时候,，传输速度会很慢很慢.<br>
复杂的模块依赖关系需要被记录，确保模块的版本和当前保持一致，否则会导致当前项目运行报错<br>
（2）package.json文件的作用<br>
项目描述文件，记录了当前项目信息，例如项目名称、版本、作者、github地址、当前项目依赖了哪些第三方模块等。<br>
使用npm init -y命令生成。  -y全填默认值<br>
（3）项目依赖<br>
在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖<br>
使用npm install 包名命令下载的文件会默认被添加到 package.json 文件的 dependencies 字段中<br>
{<br>
&quot;dependencies&quot;: {<br>
&quot;jquery&quot;: &quot;^3.3.1“<br>
}<br>
}<br>
（4）开发依赖<br>
在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖<br>
使用npm install 包名 --save-dev命令将包添加到package.json文件的devDependencies字段中<br>
{<br>
&quot;devDependencies&quot;: {<br>
&quot;gulp&quot;: &quot;^3.9.1“<br>
}<br>
}<br>
5）package-lock.json文件的作用<br>
锁定包的版本，确保再次下载时不会因为包版本不同而产生问题<br>
加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作</p>
<p>npm install --production 只安装项目依赖<br>
npm install  全部</p>
<p>TIP：<br>
package.json<br>
&quot;scripts&quot;:{<br>
&quot;命令别名&quot; : &quot;命令代码&quot;<br>
}<br>
cmd 敲入 npm run 别名   即可运行</p>
<h3 id="node-模块加载机制">Node 模块加载机制</h3>
<ol>
<li>当模块拥有路径但没有后缀<br>
require方法根据模块路径查找模块，如果是完整路径，直接引入模块。<br>
如果模块后缀省略，先找同名JS文件再找同名JS文件夹<br>
如果找到了同名文件夹，找文件夹中的index.js<br>
如果文件夹中没有index.js就会去当前文件夹中的package.json文件中查找main选项中的入口文件<br>
如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到</li>
<li>模块没有路径没有后缀<br>
假设它是系统模块<br>
node_moudules文件中<br>
同名js文件<br>
同名文件夹<br>
同名文件夹里面的index.js<br>
package.json main选项的入口文件</li>
</ol>
<h3 id="node全局对象">Node全局对象</h3>
<p>Node全局对象 global  ——浏览器全局对象 window<br>
global对象里 有<br>
console.log<br>
setTimeout<br>
...<br>
等等方法</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[伪类与伪元素]]></title>
        <id>https://huyifu.github.io/post/wei-lei-yu-wei-yuan-su/</id>
        <link href="https://huyifu.github.io/post/wei-lei-yu-wei-yuan-su/">
        </link>
        <updated>2021-03-18T13:50:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是伪类">什么是伪类？</h2>
<p>——伪类是选择器的一种，它用于选择处于特定状态的元素。<br>
伪类有很多种，它们都为我们提供了基于其特征无法访问或难以访问的特征来定位元素的方法。<br>
伪类的类型：</p>
<ol>
<li>动态伪类<br>
:hover :focus :link  :visited</li>
<li>基于状态的伪类<br>
:checked可以应用于复选框（）<br>
:fullscreen 定位当前以全屏模式显示的任何元素</li>
<li>结构伪类<br>
:first-child，:last-child</li>
<li>杂项伪类<br>
:not(x)选择与选择器x不匹配的元素   :lang(language-code) 选择哪些内容采用特定语言的元素</li>
</ol>
<h2 id="什么是伪元素">什么是伪元素？</h2>
<p>——伪元素用于创建一些不在文档树中的元素，并为其添加样式。<br>
ps:利用伪元素插入的dom 在dom结构中是看不到的 不过可以在css 中看到<br>
::before/::after/::first-letter/::first-line/::selection ........</p>
<h2 id="区别">区别：</h2>
<p>伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素。<br>
有没有创建一个文档树之外的元素。</p>
<p>元素指的是 HTML 文档中的标签，它是 DOM 树的一部分。而类是元素上的一个属性，是人为规定的当前元素的一个类别。</p>
<h1 id="总结">总结：</h1>
<ul>
<li>伪类与被标记的元素是一种包含关系，类添加到了这个元素上</li>
<li>伪元素与被被标记的元素是同级关系，css最终会作用在这个创造出的伪元素的位置上</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[居中方法和原理]]></title>
        <id>https://huyifu.github.io/post/ju-zhong-fang-fa-he-yuan-li/</id>
        <link href="https://huyifu.github.io/post/ju-zhong-fang-fa-he-yuan-li/">
        </link>
        <updated>2021-03-18T11:24:00.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浮动 清除浮动及其原理]]></title>
        <id>https://huyifu.github.io/post/fu-dong-qing-chu-fu-dong/</id>
        <link href="https://huyifu.github.io/post/fu-dong-qing-chu-fu-dong/">
        </link>
        <updated>2021-03-18T10:34:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="遇到父元素高度崩塌的问题">遇到父元素高度崩塌的问题</h1>
<ul>
<li>css标准文档流 默认状态 元素自动从左到右 从上往下的流式排列</li>
<li>浮动 float 会导致元素脱离文档流</li>
<li>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</li>
<li>由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</li>
<li>浮动会影响标准流的排列 其中导致父级元素高度坍塌问题<br>
例如 父元素包裹两个子div 一个左浮动 一个右浮动<br>
之后的与父元素同级的兄弟元素会直接占位<br>
父元素高度为0<br>
解决方法：</li>
</ul>
<h2 id="1-clearboth">1. clear：both</h2>
<p>clear 属性规定元素的哪一侧不允许其他浮动元素。<br>
在 CSS1 和 CSS2 中，这是通过自动为清除元素（即设置了 clear 属性的元素）增加上外边距实现的。在 CSS2.1 中，会在元素上外边距之上增加清除空间，而外边距本身并不改变。不论哪一种改变，最终结果都一样，如果声明为左边或右边清除，会使元素的上外边框边界刚好在该边上浮动元素的下外边距边界之下。<br>
应用：在内部末尾添加一个div 设置 clear：both   —— 会利用上margin把父元素撑开</p>
<h3 id="即设置clear属性的元素会有上margin大小为没有浮动元素为止">即设置clear属性的元素会有上margin大小为没有浮动元素为止</h3>
<h2 id="2-父级添加overflowhidden">2. 父级添加overflow：hidden</h2>
<p>实质上是应用了BFC一个特性 计算BFC高度时，浮动元素也参与计算<br>
那什么是BFC呢？<br>
BFC(Block formatting context)直译为&quot;块级格式化上下文&quot;。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。默认情况下只有根元素（即body）一个块级上下文。</p>
<h3 id="bfc的布局规则">BFC的布局规则</h3>
<ul>
<li>内部的Box会在垂直方向，一个接一个地放置。</li>
<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。</li>
<li>每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>
<li>BFC的区域不会与float box重叠。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。<br>
计算BFC的高度时，浮动元素也参与计算。</li>
</ul>
<h3 id="如何创建bfc">如何创建BFC</h3>
<ul>
<li>float的值不是none。</li>
<li>position的值不是static或者relative。</li>
<li>display的值是inline-block、table-cell、flex、table-caption或者inline-flex</li>
<li>overflow的值不是visible</li>
</ul>
<p>到这里已经可以解释为什么overflow hidden 能清除浮动了 ——把父元素创建成了BFC 计算高度考虑浮动元素<br>
同样的，可以设置float属性 但是父级元素的父级又得可能会有浮动引发的问题<br>
可以设置 display absolute等等</p>
<h2 id="3-使用after伪元素清除浮动">3. 使用after伪元素清除浮动</h2>
<pre><code>.clearfix:after{/*伪元素是行内元素 正常浏览器清除浮动方法*/
        content: &quot;&quot;;
        display: block;
        height: 0;
        clear:both;
        visibility: hidden;
    }
    .clearfix{
        *zoom: 1;/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/
    }
</code></pre>
<ul>
<li>
<p>在需要清除的元素添加 clearfix类<br>
after伪元素 内容空 clear:both  原理与1 相同</p>
</li>
<li>
<p>其中Zoom属性是IE浏览器的专有属性， 它可以设置或检索对象的缩放比例。<br>
当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。</p>
</li>
</ul>
<h2 id="总结清除浮动根本原理两大类-clearboth-设置为bfc元素">总结：清除浮动根本原理两大类 clear：both  设置为BFC元素</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Javascript]cssText使用]]></title>
        <id>https://huyifu.github.io/post/javascriptcsstext-shi-yong/</id>
        <link href="https://huyifu.github.io/post/javascriptcsstext-shi-yong/">
        </link>
        <updated>2021-03-15T13:33:07.000Z</updated>
        <content type="html"><![CDATA[<p>#引言<br>
再写小米官网时候 遇到了需要在js中添加样式的问题<br>
之前一直是用xxx.style.width(or height 等等) 想添加上边框时用不了<br>
border-top: 1px solid #ccc;<br>
看到了xxx.style.cssText 使用方法便头一次看到了新的css添加方法<br>
便使用</p>
<pre><code>dropDownbox[0].style.cssText = 'border-top: 1px solid #ccc;';
</code></pre>
<p>结果又有bug 搜索后总结使用方法如下：</p>
<ul>
<li>cssText，DOMString类型</li>
<li>cssText特性必须返回序列化的CSS规则。</li>
<li>当设置cssText特性时运行这些步骤：
<ol>
<li>解析其值。</li>
<li>如果解析失败则终止运行。</li>
<li>如果新对象的type并不匹配当前对象的type则抛出&quot;InvalidModificationError&quot;异常。</li>
<li>替换当前对象为新对象。<br>
——以上摘自<a href="https://segmentfault.com/a/1190000000703778">https://segmentfault.com/a/1190000000703778</a></li>
</ol>
</li>
</ul>
<h3 id="第四条会导致新对象覆盖目标元素之前所有的样式继承不算">第四条会导致新对象覆盖目标元素之前所有的样式（继承不算）</h3>
<p>例：<br>
#xxx{width:200px;height:300px;}</p>
<pre><code>var xxx-point = document.getElementById('xxx');
xxx-point.style.cssText = 'width:300px; ';
</code></pre>
<p>最终.xxx{width:300px;}</p>
<p>如果想单独添加某个css样式 方法如下:<br>
#xxx{width:200px;height:300px;}</p>
<pre><code>var xxx-point = document.getElementById('xxx');
var xxx_style = xxx-point.style.cssText;
xxx_style += 'border-top: 1px solid #ccc;';
xxx-point.style.cssText = xxx_style;
</code></pre>
<h3 id="ie678-返回全为大写而且最后没有分号">IE6/7/8 返回全为大写而且最后没有分号</h3>
<p>#xxx{width:200px;height:300px;}<br>
则cssText 为'WIDTH:200PX;HEIGHT:300PX'<br>
故若考虑 IE6/7/8 兼容则需</p>
<pre><code>var xxx-point = document.getElementById('xxx');
var xxx_style = xxx-point.style.cssText.toLowerCase(); //转化为小写
xxx_style  = 'border-top: 1px solid #ccc;'+xxx_style; //如果没有分号不影响
xxx-point.style.cssText = xxx_style;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[document.body.scrollTop与document.documentElement.scrollTop兼容]]></title>
        <id>https://huyifu.github.io/post/documentbodyscrolltop-yu-documentdocumentelementscrolltop-jian-rong/</id>
        <link href="https://huyifu.github.io/post/documentbodyscrolltop-yu-documentdocumentelementscrolltop-jian-rong/">
        </link>
        <updated>2021-03-13T05:04:57.000Z</updated>
        <content type="html"><![CDATA[<p>#scrollTop<br>
scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离</p>
<p>#获取当前页面的滚动条纵坐标位置<br>
使用document.documentElement.scrollTop;</p>
<p>#网页被卷去的高： document.body.scrollTop;<br>
document.body.scrollTop 可以获取到当前页面被卷去的高度。</p>
<p>#不同浏览器兼容性不同<br>
IE6/7/8：<br>
可以使用 document.documentElement.scrollTop；<br>
IE9及以上：<br>
可以使用window.pageYOffset或者document.documentElement.scrollTop<br>
Safari:<br>
safari： window.pageYOffset 与document.body.scrollTop都可以；<br>
Firefox:<br>
火狐等等相对标准些的浏览器就省心多了，直接用window.pageYOffset 或者 document.documentElement.scrollTop ；<br>
Chrome：<br>
谷歌浏览器只认识document.body.scrollTop;</p>
<p>#总结：<br>
两者同时存在时只有一个值生效 另一个值为0<br>
故 var sTop=document.body.scrollTop+document.documentElement.scrollTop;<br>
或 var sTop=document.body.scrollTop||document.documentElement.scrollTop;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css position属性]]></title>
        <id>https://huyifu.github.io/post/css-relative-he-absolute/</id>
        <link href="https://huyifu.github.io/post/css-relative-he-absolute/">
        </link>
        <updated>2021-03-07T02:07:41.000Z</updated>
        <content type="html"><![CDATA[<p>先来看W3教程 介绍的五个值<br>
absolute	<br>
生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。</p>
<p>元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定。</p>
<p>fixed	<br>
生成绝对定位的元素，相对于浏览器窗口进行定位。</p>
<p>元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定。</p>
<p>relative	<br>
生成相对定位的元素，相对于其正常位置进行定位。</p>
<p>因此，&quot;left:20&quot; 会向元素的 LEFT 位置添加 20 像素。</p>
<p>static	默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</p>
<p>inherit	规定应该从父元素继承 position 属性的值。</p>
<ul>
<li>left right 指的是距离left right 多少像素</li>
<li>float 与absolute 不能同时使用</li>
<li>文档流布局的概念</li>
<li>absolute是相对于最近的不为static position的祖先元素进行定位  如果没有则相对body进行定位</li>
<li>relative 原来的空间会被保留<br>
什么是文档流布局？<br>
将窗体自上而下分成一行行， 并在每行中按从左至右的顺序排放元素，即为文档流。  <br>
每个非浮动块级元素都独占一行， 浮动元素则按规定浮在行的一端。 若当前行容不下， 则另起新行再浮动。 内联元素也不会独占一行。 几乎所有元素(包括块级，内联和列表元素）均可生成子行， 用于摆放子元素。有三种情况将使得元素脱离文档流而存在，分别是 浮动，绝对定位， 固定定位。 但是在IE6中浮动元素也存在于文档流中。</li>
</ul>
<h2 id="absolute-与-relative">absolute 与 relative</h2>
<p>absolute属性的元素：元素从原来的静态（position=static）安排的位置被“挤出”平面空间，自己开始新的位置，形象地说是在其他平面上，原来的平面空间被其他元素占有。<br>
relative属性的元素：遵从静态（position=static）文档流安排，但可使用top、bottom、left、right属性进行位置偏移（不影响同级文档流的位置）。形象地说原来的位置还留着，但它可以随意移动穿插与不同位置而不影响其他元素的排布。<br>
两者的共同点是：都可以随意偏移原本文档位置而不影响同级元素的排布。<br>
不同点是：relative的空间被保留下来，而absolute的空间被占有了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css height width  auto和100% ]]></title>
        <id>https://huyifu.github.io/post/css-height-width-auto-he-100/</id>
        <link href="https://huyifu.github.io/post/css-height-width-auto-he-100/">
        </link>
        <updated>2021-03-06T04:21:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="两种盒子模型-w3c盒子模型-ie盒子模型">两种盒子模型  w3c盒子模型 IE盒子模型</h3>
<p>box-sizing ： content-box w3c盒子模型<br>
box-sizing ： border-box IE盒子模型<br>
可视width（height） = content + padding + border +margin</p>
<ul>
<li>w3c盒子模型 width（height） = content</li>
<li>IE盒子模型 width（height） = content + padding + border</li>
</ul>
<h3 id="width-height-100">width (height )100%</h3>
<p>height width百分数是相对于包含块的。<br>
如果没有显示声明包含块的height，百分数高度会重置为auto。  ——《css权威指南》</p>
<ul>
<li>%设定宽高是根据父级宽高来定</li>
<li>width height 没有设置 默认auto</li>
<li>auto 一侧定值 一侧auto 则auto为剩余空间 （类似float）</li>
<li>两侧如果均是auto 则平分空间</li>
</ul>
<h3 id="margin-0-auto-为何水平居中">margin 0 auto 为何水平居中？</h3>
<p>——两侧 auto左右平分空间</p>
<h3 id="auto实现垂直居中">auto实现垂直居中</h3>
<pre><code>position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
</code></pre>
<p>试验：</p>
<p>原理： 盒子四侧全部</p>
<p>未完。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6 let命令 和const命令]]></title>
        <id>https://huyifu.github.io/post/es6-let-ming-ling/</id>
        <link href="https://huyifu.github.io/post/es6-let-ming-ling/">
        </link>
        <updated>2021-03-04T11:43:43.000Z</updated>
        <content type="html"><![CDATA[<p><strong>let类似var 不过声明的变量只在let命令下的代码块生效</strong></p>
<pre><code>var a = [];
for (var i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10  a为函数数组 var 在（）创建的变量 会存在于循环外部的执行环境中 故输出10
for (let i = 0; i &lt; 10; i++) {
    a[i] = function () {
      console.log(i);
    };
  }
a[6](); // 6  let 块级作用域 每一轮i变量重新声明 并由于js引擎内部记忆上一轮的值 计算后赋值
</code></pre>
<blockquote>
<p>for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
</blockquote>
<p>以下为代码实践证明</p>
<pre><code>for (let i = 0; i &lt; 5; i++) {
    i++; //let不声明i 开始影响（）里声明的i变量 子作用域影响父作用域
    console.log(i);
  }
//输出1 3 5
  for (let i = 0; i &lt; 5; i++) {
    let i=10; //let声明i 单独的子作用域 
    console.log(i);
  }
//输出5遍10
</code></pre>
<p><strong>var存在变量提升  let不存在</strong><br>
变量提升</p>
<ul>
<li>var关键字声明的变量，无论实际声明的位置在何处，都会被视为声明在函数的顶部（如果声明不在任意函数内，则视为在全局作用域的顶部）</li>
<li>JavaScript引擎的工作方式是，先预解析代码， 获取所有被声明的变量和函数声明，然后再一行一行地运行，这就使所有变量声明的语句，都会被提升到代码的头部，这就是变量提升</li>
</ul>
<pre><code>// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
</code></pre>
<p><strong>暂时性死区</strong><br>
用let声明变量之前，该变量不可用</p>
<ul>
<li>typeof 不是百分百不报错 ——</li>
</ul>
<pre><code>typeof x; //ReferenceError
let x;
</code></pre>
<ul>
<li>let与var</li>
</ul>
<pre><code>var  x = x;//不报错
let   x = x;//报错
</code></pre>
<p><strong>const</strong></p>
<ul>
<li>声明常量（不变） 所以后必须马上赋值</li>
<li>块级作用域有效</li>
<li>暂时性死区</li>
<li>不可重复声明</li>
<li>对象冻结，应该使用Object.freeze方法。<br>
保证常量值不改变本质是<strong>防止变量所指向内存的地址内数据进行更改</strong><br>
简单的数据类型可以保证不改变<br>
而对于复合型（数组和对象）则只能保证变量存放的指针不变 指向的数据结构内部无法控制</li>
</ul>
<pre><code>const a = [];
a.push('Hello'); // 可执行
a.length = 0;    // 可执行
a = ['Dave'];    // 报错
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[路径 相对和绝对]]></title>
        <id>https://huyifu.github.io/post/lu-jing-xiang-dui-he-jue-dui/</id>
        <link href="https://huyifu.github.io/post/lu-jing-xiang-dui-he-jue-dui/">
        </link>
        <updated>2021-03-03T12:28:44.000Z</updated>
        <content type="html"><![CDATA[<p><strong>绝对路径</strong><br>
从根目录为起点到你想到到达的目录<br>
<strong>相对路径</strong><br>
以一个基准点(自身)为起点到达你想到达的目录<br>
/ 根目录(基准点的最上层目录) 即windows系统下某个盘<br>
./当前目录  ../上一级目录  (相对的)</p>
<p>例子<br>
c:/website/web/xz/index.html<br>
c:/website/img/images/photo.jpg<br>
在index.html中导入photo.jpg<br>
绝对路径： src=&quot;c:/website/img/images/photo.jpg&quot; (本电脑)<br>
相对路径 :   src=&quot;../../img/images/photo.jpg&quot; (只要保持相对位置就可以使用)</p>
]]></content>
    </entry>
</feed>
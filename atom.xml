<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://huyifu.github.io</id>
    <title>古月的blog</title>
    <updated>2021-03-21T13:48:06.602Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://huyifu.github.io"/>
    <link rel="self" href="https://huyifu.github.io/atom.xml"/>
    <subtitle>123455
</subtitle>
    <logo>https://huyifu.github.io/images/avatar.png</logo>
    <icon>https://huyifu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 古月的blog</rights>
    <entry>
        <title type="html"><![CDATA[伪类与伪元素]]></title>
        <id>https://huyifu.github.io/post/wei-lei-yu-wei-yuan-su/</id>
        <link href="https://huyifu.github.io/post/wei-lei-yu-wei-yuan-su/">
        </link>
        <updated>2021-03-18T13:50:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是伪类">什么是伪类？</h2>
<p>——伪类是选择器的一种，它用于选择处于特定状态的元素。<br>
伪类有很多种，它们都为我们提供了基于其特征无法访问或难以访问的特征来定位元素的方法。<br>
伪类的类型：</p>
<ol>
<li>动态伪类<br>
:hover :focus :link  :visited</li>
<li>基于状态的伪类<br>
:checked可以应用于复选框（）<br>
:fullscreen 定位当前以全屏模式显示的任何元素</li>
<li>结构伪类<br>
:first-child，:last-child</li>
<li>杂项伪类<br>
:not(x)选择与选择器x不匹配的元素   :lang(language-code) 选择哪些内容采用特定语言的元素</li>
</ol>
<h2 id="什么是伪元素">什么是伪元素？</h2>
<p>——伪元素用于创建一些不在文档树中的元素，并为其添加样式。<br>
ps:利用伪元素插入的dom 在dom结构中是看不到的 不过可以在css 中看到<br>
::before/::after/::first-letter/::first-line/::selection ........</p>
<h2 id="区别">区别：</h2>
<p>伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素。<br>
有没有创建一个文档树之外的元素。</p>
<p>元素指的是 HTML 文档中的标签，它是 DOM 树的一部分。而类是元素上的一个属性，是人为规定的当前元素的一个类别。</p>
<h1 id="总结">总结：</h1>
<ul>
<li>伪类与被标记的元素是一种包含关系，类添加到了这个元素上</li>
<li>伪元素与被被标记的元素是同级关系，css最终会作用在这个创造出的伪元素的位置上</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[居中方法和原理]]></title>
        <id>https://huyifu.github.io/post/ju-zhong-fang-fa-he-yuan-li/</id>
        <link href="https://huyifu.github.io/post/ju-zhong-fang-fa-he-yuan-li/">
        </link>
        <updated>2021-03-18T11:24:00.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浮动 清除浮动及其原理]]></title>
        <id>https://huyifu.github.io/post/fu-dong-qing-chu-fu-dong/</id>
        <link href="https://huyifu.github.io/post/fu-dong-qing-chu-fu-dong/">
        </link>
        <updated>2021-03-18T10:34:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="遇到父元素高度崩塌的问题">遇到父元素高度崩塌的问题</h1>
<ul>
<li>css标准文档流 默认状态 元素自动从左到右 从上往下的流式排列</li>
<li>浮动 float 会导致元素脱离文档流</li>
<li>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</li>
<li>由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</li>
<li>浮动会影响标准流的排列 其中导致父级元素高度坍塌问题<br>
例如 父元素包裹两个子div 一个左浮动 一个右浮动<br>
之后的与父元素同级的兄弟元素会直接占位<br>
父元素高度为0<br>
解决方法：</li>
</ul>
<h2 id="1-clearboth">1. clear：both</h2>
<p>clear 属性规定元素的哪一侧不允许其他浮动元素。<br>
在 CSS1 和 CSS2 中，这是通过自动为清除元素（即设置了 clear 属性的元素）增加上外边距实现的。在 CSS2.1 中，会在元素上外边距之上增加清除空间，而外边距本身并不改变。不论哪一种改变，最终结果都一样，如果声明为左边或右边清除，会使元素的上外边框边界刚好在该边上浮动元素的下外边距边界之下。<br>
应用：在内部末尾添加一个div 设置 clear：both   —— 会利用上margin把父元素撑开</p>
<h3 id="即设置clear属性的元素会有上margin大小为没有浮动元素为止">即设置clear属性的元素会有上margin大小为没有浮动元素为止</h3>
<h2 id="2-父级添加overflowhidden">2. 父级添加overflow：hidden</h2>
<p>实质上是应用了BFC一个特性 计算BFC高度时，浮动元素也参与计算<br>
那什么是BFC呢？<br>
BFC(Block formatting context)直译为&quot;块级格式化上下文&quot;。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。默认情况下只有根元素（即body）一个块级上下文。</p>
<h3 id="bfc的布局规则">BFC的布局规则</h3>
<ul>
<li>内部的Box会在垂直方向，一个接一个地放置。</li>
<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。</li>
<li>每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>
<li>BFC的区域不会与float box重叠。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。<br>
计算BFC的高度时，浮动元素也参与计算。</li>
</ul>
<h3 id="如何创建bfc">如何创建BFC</h3>
<ul>
<li>float的值不是none。</li>
<li>position的值不是static或者relative。</li>
<li>display的值是inline-block、table-cell、flex、table-caption或者inline-flex</li>
<li>overflow的值不是visible</li>
</ul>
<p>到这里已经可以解释为什么overflow hidden 能清除浮动了 ——把父元素创建成了BFC 计算高度考虑浮动元素<br>
同样的，可以设置float属性 但是父级元素的父级又得可能会有浮动引发的问题<br>
可以设置 display absolute等等</p>
<h2 id="3-使用after伪元素清除浮动">3. 使用after伪元素清除浮动</h2>
<pre><code>.clearfix:after{/*伪元素是行内元素 正常浏览器清除浮动方法*/
        content: &quot;&quot;;
        display: block;
        height: 0;
        clear:both;
        visibility: hidden;
    }
    .clearfix{
        *zoom: 1;/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/
    }
</code></pre>
<ul>
<li>
<p>在需要清除的元素添加 clearfix类<br>
after伪元素 内容空 clear:both  原理与1 相同</p>
</li>
<li>
<p>其中Zoom属性是IE浏览器的专有属性， 它可以设置或检索对象的缩放比例。<br>
当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。</p>
</li>
</ul>
<h2 id="总结清除浮动根本原理两大类-clearboth-设置为bfc元素">总结：清除浮动根本原理两大类 clear：both  设置为BFC元素</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Javascript]cssText使用]]></title>
        <id>https://huyifu.github.io/post/javascriptcsstext-shi-yong/</id>
        <link href="https://huyifu.github.io/post/javascriptcsstext-shi-yong/">
        </link>
        <updated>2021-03-15T13:33:07.000Z</updated>
        <content type="html"><![CDATA[<p>#引言<br>
再写小米官网时候 遇到了需要在js中添加样式的问题<br>
之前一直是用xxx.style.width(or height 等等) 想添加上边框时用不了<br>
border-top: 1px solid #ccc;<br>
看到了xxx.style.cssText 使用方法便头一次看到了新的css添加方法<br>
便使用</p>
<pre><code>dropDownbox[0].style.cssText = 'border-top: 1px solid #ccc;';
</code></pre>
<p>结果又有bug 搜索后总结使用方法如下：</p>
<ul>
<li>cssText，DOMString类型</li>
<li>cssText特性必须返回序列化的CSS规则。</li>
<li>当设置cssText特性时运行这些步骤：
<ol>
<li>解析其值。</li>
<li>如果解析失败则终止运行。</li>
<li>如果新对象的type并不匹配当前对象的type则抛出&quot;InvalidModificationError&quot;异常。</li>
<li>替换当前对象为新对象。<br>
——以上摘自<a href="https://segmentfault.com/a/1190000000703778">https://segmentfault.com/a/1190000000703778</a></li>
</ol>
</li>
</ul>
<h3 id="第四条会导致新对象覆盖目标元素之前所有的样式继承不算">第四条会导致新对象覆盖目标元素之前所有的样式（继承不算）</h3>
<p>例：<br>
#xxx{width:200px;height:300px;}</p>
<pre><code>var xxx-point = document.getElementById('xxx');
xxx-point.style.cssText = 'width:300px; ';
</code></pre>
<p>最终.xxx{width:300px;}</p>
<p>如果想单独添加某个css样式 方法如下:<br>
#xxx{width:200px;height:300px;}</p>
<pre><code>var xxx-point = document.getElementById('xxx');
var xxx_style = xxx-point.style.cssText;
xxx_style += 'border-top: 1px solid #ccc;';
xxx-point.style.cssText = xxx_style;
</code></pre>
<h3 id="ie678-返回全为大写而且最后没有分号">IE6/7/8 返回全为大写而且最后没有分号</h3>
<p>#xxx{width:200px;height:300px;}<br>
则cssText 为'WIDTH:200PX;HEIGHT:300PX'<br>
故若考虑 IE6/7/8 兼容则需</p>
<pre><code>var xxx-point = document.getElementById('xxx');
var xxx_style = xxx-point.style.cssText.toLowerCase(); //转化为小写
xxx_style  = 'border-top: 1px solid #ccc;'+xxx_style; //如果没有分号不影响
xxx-point.style.cssText = xxx_style;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[document.body.scrollTop与document.documentElement.scrollTop兼容]]></title>
        <id>https://huyifu.github.io/post/documentbodyscrolltop-yu-documentdocumentelementscrolltop-jian-rong/</id>
        <link href="https://huyifu.github.io/post/documentbodyscrolltop-yu-documentdocumentelementscrolltop-jian-rong/">
        </link>
        <updated>2021-03-13T05:04:57.000Z</updated>
        <content type="html"><![CDATA[<p>#scrollTop<br>
scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离</p>
<p>#获取当前页面的滚动条纵坐标位置<br>
使用document.documentElement.scrollTop;</p>
<p>#网页被卷去的高： document.body.scrollTop;<br>
document.body.scrollTop 可以获取到当前页面被卷去的高度。</p>
<p>#不同浏览器兼容性不同<br>
IE6/7/8：<br>
可以使用 document.documentElement.scrollTop；<br>
IE9及以上：<br>
可以使用window.pageYOffset或者document.documentElement.scrollTop<br>
Safari:<br>
safari： window.pageYOffset 与document.body.scrollTop都可以；<br>
Firefox:<br>
火狐等等相对标准些的浏览器就省心多了，直接用window.pageYOffset 或者 document.documentElement.scrollTop ；<br>
Chrome：<br>
谷歌浏览器只认识document.body.scrollTop;</p>
<p>#总结：<br>
两者同时存在时只有一个值生效 另一个值为0<br>
故 var sTop=document.body.scrollTop+document.documentElement.scrollTop;<br>
或 var sTop=document.body.scrollTop||document.documentElement.scrollTop;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css position属性]]></title>
        <id>https://huyifu.github.io/post/css-relative-he-absolute/</id>
        <link href="https://huyifu.github.io/post/css-relative-he-absolute/">
        </link>
        <updated>2021-03-07T02:07:41.000Z</updated>
        <content type="html"><![CDATA[<p>先来看W3教程 介绍的五个值<br>
absolute	<br>
生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。</p>
<p>元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定。</p>
<p>fixed	<br>
生成绝对定位的元素，相对于浏览器窗口进行定位。</p>
<p>元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定。</p>
<p>relative	<br>
生成相对定位的元素，相对于其正常位置进行定位。</p>
<p>因此，&quot;left:20&quot; 会向元素的 LEFT 位置添加 20 像素。</p>
<p>static	默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</p>
<p>inherit	规定应该从父元素继承 position 属性的值。</p>
<ul>
<li>left right 指的是距离left right 多少像素</li>
<li>float 与absolute 不能同时使用</li>
<li>文档流布局的概念</li>
<li>absolute是相对于最近的不为static position的祖先元素进行定位  如果没有则相对body进行定位</li>
<li>relative 原来的空间会被保留<br>
什么是文档流布局？<br>
将窗体自上而下分成一行行， 并在每行中按从左至右的顺序排放元素，即为文档流。  <br>
每个非浮动块级元素都独占一行， 浮动元素则按规定浮在行的一端。 若当前行容不下， 则另起新行再浮动。 内联元素也不会独占一行。 几乎所有元素(包括块级，内联和列表元素）均可生成子行， 用于摆放子元素。有三种情况将使得元素脱离文档流而存在，分别是 浮动，绝对定位， 固定定位。 但是在IE6中浮动元素也存在于文档流中。</li>
</ul>
<h2 id="absolute-与-relative">absolute 与 relative</h2>
<p>absolute属性的元素：元素从原来的静态（position=static）安排的位置被“挤出”平面空间，自己开始新的位置，形象地说是在其他平面上，原来的平面空间被其他元素占有。<br>
relative属性的元素：遵从静态（position=static）文档流安排，但可使用top、bottom、left、right属性进行位置偏移（不影响同级文档流的位置）。形象地说原来的位置还留着，但它可以随意移动穿插与不同位置而不影响其他元素的排布。<br>
两者的共同点是：都可以随意偏移原本文档位置而不影响同级元素的排布。<br>
不同点是：relative的空间被保留下来，而absolute的空间被占有了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css height width  auto和100% ]]></title>
        <id>https://huyifu.github.io/post/css-height-width-auto-he-100/</id>
        <link href="https://huyifu.github.io/post/css-height-width-auto-he-100/">
        </link>
        <updated>2021-03-06T04:21:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="两种盒子模型-w3c盒子模型-ie盒子模型">两种盒子模型  w3c盒子模型 IE盒子模型</h3>
<p>box-sizing ： content-box w3c盒子模型<br>
box-sizing ： border-box IE盒子模型<br>
可视width（height） = content + padding + border +margin</p>
<ul>
<li>w3c盒子模型 width（height） = content</li>
<li>IE盒子模型 width（height） = content + padding + border</li>
</ul>
<h3 id="width-height-100">width (height )100%</h3>
<p>height width百分数是相对于包含块的。<br>
如果没有显示声明包含块的height，百分数高度会重置为auto。  ——《css权威指南》</p>
<ul>
<li>%设定宽高是根据父级宽高来定</li>
<li>width height 没有设置 默认auto</li>
<li>auto 一侧定值 一侧auto 则auto为剩余空间 （类似float）</li>
<li>两侧如果均是auto 则平分空间</li>
</ul>
<h3 id="margin-0-auto-为何水平居中">margin 0 auto 为何水平居中？</h3>
<p>——两侧 auto左右平分空间</p>
<h3 id="auto实现垂直居中">auto实现垂直居中</h3>
<pre><code>position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
</code></pre>
<p>试验：</p>
<p>原理： 盒子四侧全部</p>
<p>未完。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6 let命令 和const命令]]></title>
        <id>https://huyifu.github.io/post/es6-let-ming-ling/</id>
        <link href="https://huyifu.github.io/post/es6-let-ming-ling/">
        </link>
        <updated>2021-03-04T11:43:43.000Z</updated>
        <content type="html"><![CDATA[<p><strong>let类似var 不过声明的变量只在let命令下的代码块生效</strong></p>
<pre><code>var a = [];
for (var i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10  a为函数数组 var 在（）创建的变量 会存在于循环外部的执行环境中 故输出10
for (let i = 0; i &lt; 10; i++) {
    a[i] = function () {
      console.log(i);
    };
  }
a[6](); // 6  let 块级作用域 每一轮i变量重新声明 并由于js引擎内部记忆上一轮的值 计算后赋值
</code></pre>
<blockquote>
<p>for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
</blockquote>
<p>以下为代码实践证明</p>
<pre><code>for (let i = 0; i &lt; 5; i++) {
    i++; //let不声明i 开始影响（）里声明的i变量 子作用域影响父作用域
    console.log(i);
  }
//输出1 3 5
  for (let i = 0; i &lt; 5; i++) {
    let i=10; //let声明i 单独的子作用域 
    console.log(i);
  }
//输出5遍10
</code></pre>
<p><strong>var存在变量提升  let不存在</strong><br>
变量提升</p>
<ul>
<li>var关键字声明的变量，无论实际声明的位置在何处，都会被视为声明在函数的顶部（如果声明不在任意函数内，则视为在全局作用域的顶部）</li>
<li>JavaScript引擎的工作方式是，先预解析代码， 获取所有被声明的变量和函数声明，然后再一行一行地运行，这就使所有变量声明的语句，都会被提升到代码的头部，这就是变量提升</li>
</ul>
<pre><code>// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
</code></pre>
<p><strong>暂时性死区</strong><br>
用let声明变量之前，该变量不可用</p>
<ul>
<li>typeof 不是百分百不报错 ——</li>
</ul>
<pre><code>typeof x; //ReferenceError
let x;
</code></pre>
<ul>
<li>let与var</li>
</ul>
<pre><code>var  x = x;//不报错
let   x = x;//报错
</code></pre>
<p><strong>const</strong></p>
<ul>
<li>声明常量（不变） 所以后必须马上赋值</li>
<li>块级作用域有效</li>
<li>暂时性死区</li>
<li>不可重复声明</li>
<li>对象冻结，应该使用Object.freeze方法。<br>
保证常量值不改变本质是<strong>防止变量所指向内存的地址内数据进行更改</strong><br>
简单的数据类型可以保证不改变<br>
而对于复合型（数组和对象）则只能保证变量存放的指针不变 指向的数据结构内部无法控制</li>
</ul>
<pre><code>const a = [];
a.push('Hello'); // 可执行
a.length = 0;    // 可执行
a = ['Dave'];    // 报错
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[路径 相对和绝对]]></title>
        <id>https://huyifu.github.io/post/lu-jing-xiang-dui-he-jue-dui/</id>
        <link href="https://huyifu.github.io/post/lu-jing-xiang-dui-he-jue-dui/">
        </link>
        <updated>2021-03-03T12:28:44.000Z</updated>
        <content type="html"><![CDATA[<p><strong>绝对路径</strong><br>
从根目录为起点到你想到到达的目录<br>
<strong>相对路径</strong><br>
以一个基准点(自身)为起点到达你想到达的目录<br>
/ 根目录(基准点的最上层目录) 即windows系统下某个盘<br>
./当前目录  ../上一级目录  (相对的)</p>
<p>例子<br>
c:/website/web/xz/index.html<br>
c:/website/img/images/photo.jpg<br>
在index.html中导入photo.jpg<br>
绝对路径： src=&quot;c:/website/img/images/photo.jpg&quot; (本电脑)<br>
相对路径 :   src=&quot;../../img/images/photo.jpg&quot; (只要保持相对位置就可以使用)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[更换主题使用markdown语法]]></title>
        <id>https://huyifu.github.io/post/geng-huan-zhu-ti-shi-yong-markdown-yu-fa/</id>
        <link href="https://huyifu.github.io/post/geng-huan-zhu-ti-shi-yong-markdown-yu-fa/">
        </link>
        <updated>2021-03-03T07:11:31.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="一级标题">一级标题</h1>
<h2 id="二级标题">二级标题</h2>
<p>markdown段落直接<br>
换行</p>
<p>第二段？？<br>
换行==两个空格以上加换行</p>
<p><strong>加粗</strong> <em>斜体</em></p>
<blockquote>
<p>引用</p>
<blockquote>
<p>引用的嵌套</p>
</blockquote>
</blockquote>
<p>有序列表</p>
<ol>
<li>
<p>first item</p>
</li>
<li>
<p>second item</p>
<ol>
<li>a</li>
<li>b
<ol>
<li>三层</li>
<li>嵌套</li>
</ol>
</li>
<li>c</li>
</ol>
</li>
<li>
<p>d</p>
<pre><code>         &lt;html&gt;
   &lt;head&gt;
     &lt;title&gt;代码块&lt;/title&gt;
   &lt;/head&gt;
</code></pre>
</li>
<li>
<p>e</p>
</li>
</ol>
<p>无序列表</p>
<ul>
<li>first item</li>
<li>second item
<ul>
<li>二层</li>
<li>嵌套</li>
</ul>
<blockquote>
<p>四个空格</p>
</blockquote>
</li>
<li>third item</li>
</ul>
<p>分隔线</p>
<hr>
<p>分隔线</p>
<p>链接<br>
<a href="www.hao123.com">链接显示文本</a><br>
网址加链接&lt;&gt;<br>
<a href="https://markdown.com.cn">https://markdown.com.cn</a></p>
<p>图片<br>
<img src="%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5" alt="图片alt" title="图片title" loading="lazy"></p>
<p>This is a regular paragraph.</p>
<table>
    <tr>
        <td>Foo</td>
    </tr>
</table>
<p>This is another regular paragraph.</p>
]]></content>
    </entry>
</feed>
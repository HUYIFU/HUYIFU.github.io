<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://huyifu.github.io</id>
    <title>古月的blog</title>
    <updated>2021-03-27T08:04:39.742Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://huyifu.github.io"/>
    <link rel="self" href="https://huyifu.github.io/atom.xml"/>
    <subtitle>123455
</subtitle>
    <logo>https://huyifu.github.io/images/avatar.png</logo>
    <icon>https://huyifu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 古月的blog</rights>
    <entry>
        <title type="html"><![CDATA[Node.js 学习]]></title>
        <id>https://huyifu.github.io/post/nodejs-xue-xi/</id>
        <link href="https://huyifu.github.io/post/nodejs-xue-xi/">
        </link>
        <updated>2021-03-22T13:24:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="node三部分">node三部分</h1>
<p>引入required模块：我们可以使用require指令来载入Node.js模块。</p>
<p>创建服务器：服务器可以监听客户端的请求，类似于Apache 、Nginx等HTTP服务器。</p>
<p>接收请求与响应请求：服务器很容易创建，客户端可以使用浏览器或终端发送HTTP请求，服务器接收请求后返回响应数据。</p>
<h3 id="nvm和npm关系">nvm和npm关系</h3>
<p>nvm：nodejs 版本管理工具。<br>
也就是说：一个 nvm 可以管理很多 node 版本和 npm 版本。<br>
nodejs：在项目开发时的所需要的代码库<br>
npm：nodejs 包管理工具。<br>
在安装的 nodejs 的时候，npm 也会跟着一起安装，它是包管理工具。<br>
nvm 管理 nodejs 和 npm 的版本<br>
npm 可以管理 nodejs 的第三方插件</p>
<h3 id="使用模块化开发的原因">使用模块化开发的原因</h3>
<p>JS 文件依赖问题<br>
a.js-&gt;b.js-&gt;c.js  c.js无法单独使用<br>
命名冲突<br>
c.js num=1 a.js num=2</p>
<h3 id="node-模块化开发规范">node 模块化开发规范</h3>
<p>一个js文件就是一个模块 模块内部变量函数默认情况下在外部无法得到<br>
模块内部使用exports对象进行成员导出 使用require方法导入其他模块<br>
另一种方式<br>
module.exports.version = version;<br>
exports是module.exports的别名 指向引用关系 指向同一个导出对象<br>
当指向不同对象 导出对象是moudule.exports对象</p>
<h2 id="系统模块">系统模块</h2>
<p>系统模块 node运行环境提供的API<br>
PS: 回调函数 （err，doc） =&gt; {}   如果成功 err是NULL 不成功是一个对象</p>
<h3 id="fs-文件操作">fs 文件操作</h3>
<p>引入 const fs = require('fs')<br>
读取<br>
fs.readFile('文件路径/文件名称',['文件编码'],callback); 【】代表可选参数<br>
写入<br>
fs.writeFile('文件路径/文件名称','数据',callback);</p>
<h3 id="path-路径操作">path 路径操作</h3>
<p>路径拼接 不同操作系统路径分隔符不统一 windows / \  Linux /<br>
const path = require('path')<br>
const finalPath = path.join('a','b','c')<br>
finalPath -&gt;  a\b\c<br>
结合<br>
const fs = require('fs');<br>
const path = require('path');<br>
TIP 使用__dirname  （两个下划线）<br>
当前js文件当前文件夹的绝对路径<br>
因此路径可以表示为  path.join(__dirname, 'xx.js')   join 会自动添加<br>
fs.readFile()</p>
<p>TIP:</p>
<h3 id="相对路径和绝对路径">相对路径和绝对路径</h3>
<p>绝大部分使用绝对路径   因为相对路径是相对的命令行工具的当前工作目录<br>
读取文件 设置文件路径 绝对路径</p>
<h2 id="第三方模块">第三方模块</h2>
<p>三方模块 两种形式<br>
以js文件存在 提供API接口  -&gt; 具体功能<br>
命令行工具形式存在 辅助项目开发</p>
<h3 id="三方模块-nodemon-命令行工具">三方模块 nodemon 命令行工具</h3>
<p>cmd 可以执行 但是vs终端无法执行？？</p>
<h3 id="nrm">nrm</h3>
<p>npm下载地址切换工具<br>
npm默认下载地址 npmjs.com<br>
国内下载地址服务器同步 npm.taobao.org<br>
查询下载地址列表 nrm ls<br>
切换npm下载地址 nrm use 下载地址</p>
<p>TIP:<br>
clear 清屏   上箭头 上一次命令 下箭头 下一次命令<br>
ctrl C 终止操作</p>
<h3 id="gulp">Gulp</h3>
<p>基于node平台开发的前端构建工具<br>
将机械化操作变成命令</p>
<p>功能<br>
HTML CSS JS 压缩合并<br>
语法转换 es6 ..less..<br>
修改文件浏览器自动刷新<br>
使用</p>
<p>1使用npm install gulp下载gulp库文件<br>
（命令行当前文件下配置好了 node_modules文件夹和package-lock.json)<br>
2在项目根目录下建立gulpfile.js文件<br>
（命名固定了）<br>
3重构项目的文件夹结构 src目录放置源代码文件 dist目录放置构建后文件<br>
4在gulpfile.js文件中编写任务.<br>
5在命令行工具中执行gulp任务</p>
<p>方法<br>
gulp.src() 获取任务要处理的文件<br>
gulp.dest() 输出文件<br>
gulp.task() 建立gulp任务<br>
gulp.watch() 监考文件变化</p>
<p>gulp.task('任务的名称',() =&gt;{<br>
}) ;</p>
<p>gulp-cli  命名行工具<br>
执行任务  项目根目录 gulp 任务名称<br>
Gulp插件<br>
gulp-htmlmin: html 文件压缩</p>
<pre><code>// html压缩任务
// html文件中代码的压缩操作
// 抽取html文件中的公共代码
const htmlmin = require('gulp-htmlmin');
const fileinClude = require('gulp-file-include');
gulp.task('htmlmin',()=&gt;{
    //*. 所有的文件
    gulp.src('./src/*.html')
        //抽取放入common文件夹
        .pipe(fileinClude())
       //压缩
      .pipe(htmlmin({collapseWhitespace: true}))
      .pipe(gulp.dest('dist'));
});
</code></pre>
<p>@@include('./common/head.html')<br>
将公共代码引入进来<br>
gulp-csso :压缩css<br>
gulp-file-include 公共文件包含<br>
.....</p>
<p>构建任务<br>
TIP 当任务取名为defult gulp命令直接运行 gulp defult<br>
gulp.task('defult',['任务一名字','任务二名字'],....)</p>
<h3 id="packagejson">package.json</h3>
<p>（1）node_modules文件夹的问题<br>
文件夹以及文件过多过碎，当我们将项目整体拷贝给别人的时候,，传输速度会很慢很慢.<br>
复杂的模块依赖关系需要被记录，确保模块的版本和当前保持一致，否则会导致当前项目运行报错<br>
（2）package.json文件的作用<br>
项目描述文件，记录了当前项目信息，例如项目名称、版本、作者、github地址、当前项目依赖了哪些第三方模块等。<br>
使用npm init -y命令生成。  -y全填默认值<br>
（3）项目依赖<br>
在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖<br>
使用npm install 包名命令下载的文件会默认被添加到 package.json 文件的 dependencies 字段中<br>
{<br>
&quot;dependencies&quot;: {<br>
&quot;jquery&quot;: &quot;^3.3.1“<br>
}<br>
}<br>
（4）开发依赖<br>
在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖<br>
使用npm install 包名 --save-dev命令将包添加到package.json文件的devDependencies字段中<br>
{<br>
&quot;devDependencies&quot;: {<br>
&quot;gulp&quot;: &quot;^3.9.1“<br>
}<br>
}<br>
5）package-lock.json文件的作用<br>
锁定包的版本，确保再次下载时不会因为包版本不同而产生问题<br>
加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作</p>
<p>npm install --production 只安装项目依赖<br>
npm install  全部</p>
<p>TIP：<br>
package.json<br>
&quot;scripts&quot;:{<br>
&quot;命令别名&quot; : &quot;命令代码&quot;<br>
}<br>
cmd 敲入 npm run 别名   即可运行</p>
<h3 id="node-模块加载机制">Node 模块加载机制</h3>
<ol>
<li>当模块拥有路径但没有后缀<br>
require方法根据模块路径查找模块，如果是完整路径，直接引入模块。<br>
如果模块后缀省略，先找同名JS文件再找同名JS文件夹<br>
如果找到了同名文件夹，找文件夹中的index.js<br>
如果文件夹中没有index.js就会去当前文件夹中的package.json文件中查找main选项中的入口文件<br>
如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到</li>
<li>模块没有路径没有后缀<br>
假设它是系统模块<br>
node_moudules文件中<br>
同名js文件<br>
同名文件夹<br>
同名文件夹里面的index.js<br>
package.json main选项的入口文件</li>
</ol>
<h3 id="node全局对象">Node全局对象</h3>
<p>Node全局对象 global  ——浏览器全局对象 window<br>
global对象里 有<br>
console.log<br>
setTimeout<br>
...<br>
等等方法</p>
<h2 id="服务器开发">服务器开发</h2>
<p>###（1）服务器端基础概念<br>
网站的组成<br>
网站应用程序主要分为两大部分：客户端和服务器端。<br>
客户端：在浏览器中运行的部分，就是用户看到并与之交互的界面程序。使用HTML、CSS、JavaScript构建。<br>
服务器端：在服务器中运行的部分，负责存储数据和处理应用逻辑。</p>
<p>Node网站服务器</p>
<p>能够提供网站访问服务的机器就是网站服务器，它能够接收客户端的请求，能够对请求做出响应。</p>
<p>IP地址<br>
互联网中设备的唯一标识。<br>
IP是Internet Protocol Address的简写，代表互联网协议地址.</p>
<p>域名<br>
由于IP地址难于记忆，所以产生了域名的概念，所谓域名就是平时上网所使用的网址。<br>
http://www.baidu.com =&gt; http://124.165.219.100/ (乱写的)<br>
虽然在地址栏中输入的是网址, 但是最终还是会将域名转换为ip才能访问到指定的网站服务器。</p>
<p>端口<br>
端口是计算机与外界通讯交流的出口，用来区分服务器电脑中提供的不同的服务。</p>
<p>URL</p>
<p>统一资源定位符，又叫URL（Uniform Resource Locator），是专为标识Internet网上资源位置而设的一种编址方式，我们平时所说的网页地址指的即是URL。</p>
<p>URL的组成</p>
<p>传输协议://服务器IP或域名:端口/资源所在位置标识<br>
tip：默认80端口 没有设置端口自动设置80端口<br>
https://me.csdn.net/wuyxinu</p>
<p>http：超文本传输协议，提供了一种发布和接收HTML页面的方法。</p>
<p>开发过程中客户端和服务器端说明</p>
<p>在开发阶段，客户端和服务器端使用同一台电脑，即开发人员电脑。</p>
<p>本机域名：localhost<br>
本地IP ：127.0.0.1<br>
###（2）创建web服务器</p>
<p>// 引用系统模块<br>
const http = require('http');<br>
// 创建web服务器<br>
const app = http.createServer();<br>
// 当客户端发送请求的时候<br>
req 请求  res返回</p>
<pre><code> app.on('request', (req, res) =&gt; {
        //  响应
       res.end('&lt;h1&gt;hi, user&lt;/h1&gt;');
 });
  // 监听3000端口
 app.listen(3000);
 console.log('服务器已启动，监听3000端口，请访问 localhost:3000')
</code></pre>
<h3 id="3http协议">(3)HTTP协议</h3>
<p>（1）HTTP协议的概念<br>
超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）规定了如何从网站服务器传输超文本到本地浏览器，它基于客户端服务器架构工作，是客户端（用户）和服务器端（网站）请求和应答的标准。<br>
（2）报文<br>
在HTTP请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，并且要遵守规定好的格式。<br>
（3）请求报文<br>
TIP: 控制台 Network 可以看到请求和相应相关信息<br>
请求方式 （Request Method）<br>
GET 请求数据<br>
POST 发送数据<br>
请求地址 （Request URL）<br>
app.on('request', (req, res) =&gt; {<br>
req.headers  // 获取请求报文<br>
req.url      // 获取请求地址<br>
req.method   // 获取请求方法<br>
});<br>
locallhost 请求<br>
favicon.ico 请求<br>
都为GET方式  浏览器访问服务器 GET默认方式请求？</p>
<pre><code> &lt;form method=&quot;post&quot; action=&quot;http://localhost:3000&quot;&gt;
    &lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt;
    &lt;/form&gt;
</code></pre>
<p>设置 post请求 提交跳转到服务器 方式POST</p>
<p>req.url  /index  /homepage ....<br>
同时/favicon.ico 请求地址同样存在<br>
默认 url '/'</p>
<p>req.headers['accept']  取值accept<br>
(4)响应报文<br>
1 HTTP状态码<br>
200 请求成功<br>
404 请求的资源没有被找到<br>
500 服务器端有错误<br>
400 客户端请求语法有错误</p>
<p>response.writeHead(statusCode, [reasonPhrase], [headers])<br>
2 内容类型<br>
text/html<br>
text/css<br>
application/javascript<br>
..</p>
<p>GET 请求参数<br>
http://localhost:3000/?name=xx&amp;age=20  （键值对）</p>
<p>内置模块<br>
url 模块 用于处理url地址<br>
url.parse（url地址，true）;<br>
parse对象里<br>
query 查询参数对象<br>
pathname  路径字符串<br>
第一个参数 解析的地址 第二个参数 是否将查询参数解析成对象<br>
应用 let params = url.parse(req.url,true).query;<br>
http://localhost:3000/?name=xx&amp;age=20  （键值对）<br>
此时 params {name:xx,age:20} 对象<br>
可以取得值 params.name  -&gt;xx ...</p>
<h3 id="server_getjs">server_GET.js</h3>
<pre><code>let http = require('http');
let url = require('url');
//创建服务器
let server = http.createServer();
//为server对象添加监听事件 事件名称为request
server.on('request', (req,res) =&gt;{
    res.writeHead(200,{
        'content-type': 'text/html;charset=utf8'
    });
    //测试http://localhost:3000/homepage?name=huyifu&amp;age=20
  let {query, pathname} = url.parse(req.url,true);
  console.log(query);
  console.log(pathname);
  //parse已经被弃用但是还能使用
  /* 还没学习怎么使用 url需要完整IP地址
  const NewUrl = new URL(req.url);
    console.log(req.url);*/
   if (pathname == '/homepage' || pathname == '/')
    res.end('&lt;h1&gt;欢迎来到首页&lt;/h1&gt;');
    else if (pathname == '/personPage')
    res.end('&lt;h1&gt;欢迎来到个人主页&lt;/h1&gt;');
    else
    res.end('Not Found');
});
//监听3000端口
server.listen(3000);
console.log('服务器已启动，监听3000端口，本地可访问');
</code></pre>
<p>使用模块querystring  处理请求参数模块<br>
方法 querystring.parse 转为对象</p>
<p>post 参数是通过事件的方式接受的<br>
POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。<br>
data 当请求参数传递时候触发data事件<br>
end 当参数传递完成时候触发end事件</p>
<h3 id="server_postjs">server_POST.js</h3>
<pre><code>let http = require('http');
let url = require('url');
let querystring = require('querystring');
var util = require('util');
http.createServer(function(req, res){
    // 定义了一个post变量，用于暂存请求体的信息
    var post = '';     
    // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中
    req.on('data', function(chunk){    
        post += chunk;
    });
    // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。
    req.on('end', function(){    
        post = querystring.parse(post);
        res.end(util.inspect(post));
    });
    res.writeHead(200, {'Content-Type': 'text/html; charset=utf8'});
    res.end('ok!');
}).listen(3000);

console.log('服务器已启动，监听3000端口，本地可访问');
</code></pre>
<p>静态资源<br>
服务器不需要任何处理的资源  像图片 文件等等<br>
动态资源<br>
相同的请求地址不同的响应资源  需要服务器进行处理</p>
<h2 id="静态资源的获取">静态资源的获取</h2>
<p>app.js<br>
需要做到在服务器上请求路径后响应对应的静态资源访问 如一个html页面<br>
（项目根目录下放public文件 里面是css js html文件）<br>
如访问http://localhost:3000/index.html?key=0<br>
1 引入模块<br>
http 服务器 url 服务器上获取请求路径 path 对路径进行处理 fs 对文件读取来进行 服务器的响应-&gt;指html文件<br>
2 服务器对象设置监听对象 在回调函数里进行处理<br>
3 获取请求路径<br>
4 将请求路径转变为服务器访问静态资源的绝对路径<br>
5 通过这个绝对路径进行读取 并响应</p>
<p>遇到的问题<br>
1.所有中文乱码2.所有图片加载不出 3需要将url '/'也导进首页 '/index'<br>
原因：<br>
编码格式没设置 导致乱码<br>
在响应的html中 进行对css .js .jpj .png 等等资源再次请求    但是文件格式没有设置 导致错误<br>
解决方法<br>
在html  head区加入<meta charset="UTF-8"><br>
引入mime模块 对请求路径解析出资源的格式 并根据格式在res.writeHead上添加上状态码和格式<br>
mime.getType(path)<br>
对url进行parse成对象 里面的pathname进行分析<br>
pathname = pathname =='/' ? '/index.html' : pathname  三元运算符进行转换</p>
<p>app.js 代码如下</p>
<pre><code>const http = require('http');
const url = require('url');
const path = require('path');
const fs = require('fs');
const mime = require('mime');
var times=1;
/*1 引入模块
http 服务器 url 服务器上获取请求路径 path 对路径进行处理 fs 对文件读取来进行 服务器的响应-&gt;指html文件
2 服务器对象设置监听对象 在回调函数里进行处理
3 获取请求路径 
4 将请求路径转变为服务器访问静态资源的绝对路径
5 通过这个绝对路径进行读取 并响应*/
//http://localhost:3000/index.html?key=0
let app = http.createServer();
app.on('request',(req,res)=&gt;{
    let request_path = req.url;
    let url_obj=url.parse(request_path,true);
    let pathname=url_obj.pathname;
    pathname = pathname  == '/' ? '/index.html':pathname;
    let realPath = path.join(__dirname,'仿写小米',pathname);
    let type = mime.getType(realPath);
    console.log(times+'次:'+realPath);
    times++;
    fs.readFile(realPath,(err,data)=&gt;{
         if (err) //若读取失败err是一个对象 bool值为true
         {
            console.log('文件读取失败,错误是：'+err);
            res.writeHead(404,{'content-type':'text/html;charset=utf8'});
            res.end('文件读取失败');
            return;
         }
            res.writeHead(200,{'content-type': type});
            res.end(data);
            //console.log(data);
    });
   //res.end('ok');
});
app.listen(3000);
console.log(&quot;服务器已经启动 3000端口&quot;);
</code></pre>
<h2 id="同步与异步">同步与异步</h2>
<p>同步API 只有当API执行完成后 才能继续执行下一个API<br>
异步API 当前API的执行不会阻塞后续代码的执行</p>
<pre><code>function getMsg (callback){
    setTimeout(function(){
        callback({
            msg: 'hello'
        });
    },2000);
}
getMsg(function (data){
    console.log(data);
});
</code></pre>
<p>1 定义了getMsg函数 参数为callback函数<br>
2 在下处执行了getMsg函数 参数为函数 声明了callback函数<br>
3 在getMsg函数里 异步API setTimeout函数 2s后执行<br>
4 此时调用callback函数 参数为一个对象<br>
5 执行callback函数 console.log 这个对象 属性msg值为 'hello'字符串</p>
<h3 id="代码执行顺序">代码执行顺序</h3>
<p>分为 同步代码执行区 异步代码执行区 回调函数队列<br>
首先会将代码分区域  同步代码执行和回调函数都是自上而下先后<br>
异步代码执行区则无法确定顺序 先执行完成的先进行回调函数执行<br>
执行顺序为先执行完所有的同步代码<br>
然后进行异步代码执行区    之后执行回调函数<br>
经典例子</p>
<pre><code>for (var i = 0; i &lt;= 5; i++) {
    setTimeout(function() {
        console.log( i );
    }, i*1000);
     console.log( ' i : ' , i );
}
console.log( i );
</code></pre>
<p>输出<br>
i:0<br>
i:1<br>
i:2<br>
i:3<br>
i:4<br>
i:5<br>
6<br>
6 0s后 之上都是瞬间输出<br>
6 1s后<br>
6 2s后<br>
6 3s后<br>
6 4s后<br>
6 5s后</p>
<p>此时还有闭包问题 将var改成let</p>
<pre><code>for (var i = 0; i &lt;= 5; i++) {
    setTimeout(function() {
        console.log( i );
    }, i*1000);
     console.log( ' i : ' , i );
}
console.log( i );
</code></pre>
<p>输出<br>
i:0<br>
i:1<br>
i:2<br>
i:3<br>
i:4<br>
i:5<br>
6<br>
0 0s后 之上都是瞬间输出<br>
1 1s后<br>
2 2s后<br>
3 3s后<br>
4 4s后<br>
5 5s后<br>
这两个例子 可以根据上文的代码执行顺序进行解释<br>
先执行同步区所有代码 然后进行异步区代码</p>
<p>node js 异步API<br>
fs<br>
事件处理函数<br>
...</p>
<p>异步API后面代码的执行依赖当前异步API的执行结果 需要确定好执行顺序<br>
在回调函数里调用回调函数<br>
导致问题 回调地狱  不易维护修改</p>
<h2 id="解决方法-promise">解决方法 Promise</h2>
<h2 id="promisejs">Promise.js</h2>
<pre><code>const fs = require('fs');
/* 回调地狱 不易维护
fs.readFile('./1.text','utf8',(err,result1)=&gt;{
     console.log(result1);
     fs.readFile('./2.text','utf8',(err,result2)=&gt;{
        console.log(result2);
        fs.readFile('./3.text','utf8',(err,result3)=&gt;{
            console.log(result3);
       });
   });
});
*/
function file1(){
    return new Promise((resolve,reject)=&gt;{
        fs.readFile('./1.text','utf8',(err,result)=&gt;{
             if (err)
             reject(err);
             else
             resolve(result);
        })
    });
}
function file2(){
    return new Promise((resolve,reject)=&gt;{
        fs.readFile('./2.text','utf8',(err,result)=&gt;{
             if (err)
             reject(err);
             else
             resolve(result);
        })
    });
}
function file3(){
    return new Promise((resolve,reject)=&gt;{
        fs.readFile('./3.text','utf8',(err,result)=&gt;{
             if (err)
             reject(err);
             else
             resolve(result);
        })
    });
}
//函数return promise对象 可以链式调用
file1().then((r1)=&gt;{
    console.log(r1);
    return file2(); //此时return f2的promise对象
})
.then((r2)=&gt;{
    console.log(r2);
    return file3();
})
.then((r3)=&gt;{
    console.log(r3);
})
</code></pre>
<h2 id="异步函数-在promise对象上进行封装">异步函数 在promise对象上进行封装</h2>
<p>是终极解决方案 使得异步代码写成同步的形式 让代码不再有回调函数的嵌套<br>
async<br>
1 在普通函数定义的前面加上async关键字 普通函数就变成了异步函数<br>
2 异步函数默认的返回值是promise对象<br>
3 异步函数内部使用throw进行错误抛出  return返回data (resolve)<br>
4 then方法   catch方法<br>
await<br>
1 只能写在异步函数中<br>
2 await promise  后面只能写promise对象<br>
3 await 暂停异步函数向下执行 直到promise对象返回结果</p>
<p>应用  fs.readFile 由于无法返回promise对象 无法使用await关键字<br>
解决方法<br>
引入util 模块的promisify方法<br>
此方法接收 需要改造的函数作为参数<br>
const fs = require('fs');<br>
const util = require('util');<br>
const NewReadFile = (util.promisify)(fs.readFile); //改造返回新的方法</p>
<h2 id="asyncfunctionjs">asyncFunction.js</h2>
<pre><code>/*async function fn(){
    return 'success and DATA:...';
    throw 'error!';
}
fn().then(data=&gt;console.log(data));
//fn().catch(error=&gt;console.log(error));
*/
const fs = require('fs');
const util = require('util');
const NewReadFile = (util.promisify)(fs.readFile); //改造返回新的方法

async function run(){
  let r1= await NewReadFile('./1.text','utf8');
  let r2= await NewReadFile('./2.text','utf8');
  let r3= await NewReadFile('./3.text','utf8');
  console.log(r1);
  console.log(r2);
  console.log(r3);
}
run();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[伪类与伪元素]]></title>
        <id>https://huyifu.github.io/post/wei-lei-yu-wei-yuan-su/</id>
        <link href="https://huyifu.github.io/post/wei-lei-yu-wei-yuan-su/">
        </link>
        <updated>2021-03-18T13:50:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是伪类">什么是伪类？</h2>
<p>——伪类是选择器的一种，它用于选择处于特定状态的元素。<br>
伪类有很多种，它们都为我们提供了基于其特征无法访问或难以访问的特征来定位元素的方法。<br>
伪类的类型：</p>
<ol>
<li>动态伪类<br>
:hover :focus :link  :visited</li>
<li>基于状态的伪类<br>
:checked可以应用于复选框（）<br>
:fullscreen 定位当前以全屏模式显示的任何元素</li>
<li>结构伪类<br>
:first-child，:last-child</li>
<li>杂项伪类<br>
:not(x)选择与选择器x不匹配的元素   :lang(language-code) 选择哪些内容采用特定语言的元素</li>
</ol>
<h2 id="什么是伪元素">什么是伪元素？</h2>
<p>——伪元素用于创建一些不在文档树中的元素，并为其添加样式。<br>
ps:利用伪元素插入的dom 在dom结构中是看不到的 不过可以在css 中看到<br>
::before/::after/::first-letter/::first-line/::selection ........</p>
<h2 id="区别">区别：</h2>
<p>伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素。<br>
有没有创建一个文档树之外的元素。</p>
<p>元素指的是 HTML 文档中的标签，它是 DOM 树的一部分。而类是元素上的一个属性，是人为规定的当前元素的一个类别。</p>
<h1 id="总结">总结：</h1>
<ul>
<li>伪类与被标记的元素是一种包含关系，类添加到了这个元素上</li>
<li>伪元素与被被标记的元素是同级关系，css最终会作用在这个创造出的伪元素的位置上</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[居中方法和原理]]></title>
        <id>https://huyifu.github.io/post/ju-zhong-fang-fa-he-yuan-li/</id>
        <link href="https://huyifu.github.io/post/ju-zhong-fang-fa-he-yuan-li/">
        </link>
        <updated>2021-03-18T11:24:00.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浮动 清除浮动及其原理]]></title>
        <id>https://huyifu.github.io/post/fu-dong-qing-chu-fu-dong/</id>
        <link href="https://huyifu.github.io/post/fu-dong-qing-chu-fu-dong/">
        </link>
        <updated>2021-03-18T10:34:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="遇到父元素高度崩塌的问题">遇到父元素高度崩塌的问题</h1>
<ul>
<li>css标准文档流 默认状态 元素自动从左到右 从上往下的流式排列</li>
<li>浮动 float 会导致元素脱离文档流</li>
<li>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</li>
<li>由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</li>
<li>浮动会影响标准流的排列 其中导致父级元素高度坍塌问题<br>
例如 父元素包裹两个子div 一个左浮动 一个右浮动<br>
之后的与父元素同级的兄弟元素会直接占位<br>
父元素高度为0<br>
解决方法：</li>
</ul>
<h2 id="1-clearboth">1. clear：both</h2>
<p>clear 属性规定元素的哪一侧不允许其他浮动元素。<br>
在 CSS1 和 CSS2 中，这是通过自动为清除元素（即设置了 clear 属性的元素）增加上外边距实现的。在 CSS2.1 中，会在元素上外边距之上增加清除空间，而外边距本身并不改变。不论哪一种改变，最终结果都一样，如果声明为左边或右边清除，会使元素的上外边框边界刚好在该边上浮动元素的下外边距边界之下。<br>
应用：在内部末尾添加一个div 设置 clear：both   —— 会利用上margin把父元素撑开</p>
<h3 id="即设置clear属性的元素会有上margin大小为没有浮动元素为止">即设置clear属性的元素会有上margin大小为没有浮动元素为止</h3>
<h2 id="2-父级添加overflowhidden">2. 父级添加overflow：hidden</h2>
<p>实质上是应用了BFC一个特性 计算BFC高度时，浮动元素也参与计算<br>
那什么是BFC呢？<br>
BFC(Block formatting context)直译为&quot;块级格式化上下文&quot;。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。默认情况下只有根元素（即body）一个块级上下文。</p>
<h3 id="bfc的布局规则">BFC的布局规则</h3>
<ul>
<li>内部的Box会在垂直方向，一个接一个地放置。</li>
<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。</li>
<li>每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>
<li>BFC的区域不会与float box重叠。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。<br>
计算BFC的高度时，浮动元素也参与计算。</li>
</ul>
<h3 id="如何创建bfc">如何创建BFC</h3>
<ul>
<li>float的值不是none。</li>
<li>position的值不是static或者relative。</li>
<li>display的值是inline-block、table-cell、flex、table-caption或者inline-flex</li>
<li>overflow的值不是visible</li>
</ul>
<p>到这里已经可以解释为什么overflow hidden 能清除浮动了 ——把父元素创建成了BFC 计算高度考虑浮动元素<br>
同样的，可以设置float属性 但是父级元素的父级又得可能会有浮动引发的问题<br>
可以设置 display absolute等等</p>
<h2 id="3-使用after伪元素清除浮动">3. 使用after伪元素清除浮动</h2>
<pre><code>.clearfix:after{/*伪元素是行内元素 正常浏览器清除浮动方法*/
        content: &quot;&quot;;
        display: block;
        height: 0;
        clear:both;
        visibility: hidden;
    }
    .clearfix{
        *zoom: 1;/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/
    }
</code></pre>
<ul>
<li>
<p>在需要清除的元素添加 clearfix类<br>
after伪元素 内容空 clear:both  原理与1 相同</p>
</li>
<li>
<p>其中Zoom属性是IE浏览器的专有属性， 它可以设置或检索对象的缩放比例。<br>
当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。</p>
</li>
</ul>
<h2 id="总结清除浮动根本原理两大类-clearboth-设置为bfc元素">总结：清除浮动根本原理两大类 clear：both  设置为BFC元素</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Javascript]cssText使用]]></title>
        <id>https://huyifu.github.io/post/javascriptcsstext-shi-yong/</id>
        <link href="https://huyifu.github.io/post/javascriptcsstext-shi-yong/">
        </link>
        <updated>2021-03-15T13:33:07.000Z</updated>
        <content type="html"><![CDATA[<p>#引言<br>
再写小米官网时候 遇到了需要在js中添加样式的问题<br>
之前一直是用xxx.style.width(or height 等等) 想添加上边框时用不了<br>
border-top: 1px solid #ccc;<br>
看到了xxx.style.cssText 使用方法便头一次看到了新的css添加方法<br>
便使用</p>
<pre><code>dropDownbox[0].style.cssText = 'border-top: 1px solid #ccc;';
</code></pre>
<p>结果又有bug 搜索后总结使用方法如下：</p>
<ul>
<li>cssText，DOMString类型</li>
<li>cssText特性必须返回序列化的CSS规则。</li>
<li>当设置cssText特性时运行这些步骤：
<ol>
<li>解析其值。</li>
<li>如果解析失败则终止运行。</li>
<li>如果新对象的type并不匹配当前对象的type则抛出&quot;InvalidModificationError&quot;异常。</li>
<li>替换当前对象为新对象。<br>
——以上摘自<a href="https://segmentfault.com/a/1190000000703778">https://segmentfault.com/a/1190000000703778</a></li>
</ol>
</li>
</ul>
<h3 id="第四条会导致新对象覆盖目标元素之前所有的样式继承不算">第四条会导致新对象覆盖目标元素之前所有的样式（继承不算）</h3>
<p>例：<br>
#xxx{width:200px;height:300px;}</p>
<pre><code>var xxx-point = document.getElementById('xxx');
xxx-point.style.cssText = 'width:300px; ';
</code></pre>
<p>最终.xxx{width:300px;}</p>
<p>如果想单独添加某个css样式 方法如下:<br>
#xxx{width:200px;height:300px;}</p>
<pre><code>var xxx-point = document.getElementById('xxx');
var xxx_style = xxx-point.style.cssText;
xxx_style += 'border-top: 1px solid #ccc;';
xxx-point.style.cssText = xxx_style;
</code></pre>
<h3 id="ie678-返回全为大写而且最后没有分号">IE6/7/8 返回全为大写而且最后没有分号</h3>
<p>#xxx{width:200px;height:300px;}<br>
则cssText 为'WIDTH:200PX;HEIGHT:300PX'<br>
故若考虑 IE6/7/8 兼容则需</p>
<pre><code>var xxx-point = document.getElementById('xxx');
var xxx_style = xxx-point.style.cssText.toLowerCase(); //转化为小写
xxx_style  = 'border-top: 1px solid #ccc;'+xxx_style; //如果没有分号不影响
xxx-point.style.cssText = xxx_style;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[document.body.scrollTop与document.documentElement.scrollTop兼容]]></title>
        <id>https://huyifu.github.io/post/documentbodyscrolltop-yu-documentdocumentelementscrolltop-jian-rong/</id>
        <link href="https://huyifu.github.io/post/documentbodyscrolltop-yu-documentdocumentelementscrolltop-jian-rong/">
        </link>
        <updated>2021-03-13T05:04:57.000Z</updated>
        <content type="html"><![CDATA[<p>#scrollTop<br>
scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离</p>
<p>#获取当前页面的滚动条纵坐标位置<br>
使用document.documentElement.scrollTop;</p>
<p>#网页被卷去的高： document.body.scrollTop;<br>
document.body.scrollTop 可以获取到当前页面被卷去的高度。</p>
<p>#不同浏览器兼容性不同<br>
IE6/7/8：<br>
可以使用 document.documentElement.scrollTop；<br>
IE9及以上：<br>
可以使用window.pageYOffset或者document.documentElement.scrollTop<br>
Safari:<br>
safari： window.pageYOffset 与document.body.scrollTop都可以；<br>
Firefox:<br>
火狐等等相对标准些的浏览器就省心多了，直接用window.pageYOffset 或者 document.documentElement.scrollTop ；<br>
Chrome：<br>
谷歌浏览器只认识document.body.scrollTop;</p>
<p>#总结：<br>
两者同时存在时只有一个值生效 另一个值为0<br>
故 var sTop=document.body.scrollTop+document.documentElement.scrollTop;<br>
或 var sTop=document.body.scrollTop||document.documentElement.scrollTop;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css position属性]]></title>
        <id>https://huyifu.github.io/post/css-relative-he-absolute/</id>
        <link href="https://huyifu.github.io/post/css-relative-he-absolute/">
        </link>
        <updated>2021-03-07T02:07:41.000Z</updated>
        <content type="html"><![CDATA[<p>先来看W3教程 介绍的五个值<br>
absolute	<br>
生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。</p>
<p>元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定。</p>
<p>fixed	<br>
生成绝对定位的元素，相对于浏览器窗口进行定位。</p>
<p>元素的位置通过 &quot;left&quot;, &quot;top&quot;, &quot;right&quot; 以及 &quot;bottom&quot; 属性进行规定。</p>
<p>relative	<br>
生成相对定位的元素，相对于其正常位置进行定位。</p>
<p>因此，&quot;left:20&quot; 会向元素的 LEFT 位置添加 20 像素。</p>
<p>static	默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</p>
<p>inherit	规定应该从父元素继承 position 属性的值。</p>
<ul>
<li>left right 指的是距离left right 多少像素</li>
<li>float 与absolute 不能同时使用</li>
<li>文档流布局的概念</li>
<li>absolute是相对于最近的不为static position的祖先元素进行定位  如果没有则相对body进行定位</li>
<li>relative 原来的空间会被保留<br>
什么是文档流布局？<br>
将窗体自上而下分成一行行， 并在每行中按从左至右的顺序排放元素，即为文档流。  <br>
每个非浮动块级元素都独占一行， 浮动元素则按规定浮在行的一端。 若当前行容不下， 则另起新行再浮动。 内联元素也不会独占一行。 几乎所有元素(包括块级，内联和列表元素）均可生成子行， 用于摆放子元素。有三种情况将使得元素脱离文档流而存在，分别是 浮动，绝对定位， 固定定位。 但是在IE6中浮动元素也存在于文档流中。</li>
</ul>
<h2 id="absolute-与-relative">absolute 与 relative</h2>
<p>absolute属性的元素：元素从原来的静态（position=static）安排的位置被“挤出”平面空间，自己开始新的位置，形象地说是在其他平面上，原来的平面空间被其他元素占有。<br>
relative属性的元素：遵从静态（position=static）文档流安排，但可使用top、bottom、left、right属性进行位置偏移（不影响同级文档流的位置）。形象地说原来的位置还留着，但它可以随意移动穿插与不同位置而不影响其他元素的排布。<br>
两者的共同点是：都可以随意偏移原本文档位置而不影响同级元素的排布。<br>
不同点是：relative的空间被保留下来，而absolute的空间被占有了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css height width  auto和100% ]]></title>
        <id>https://huyifu.github.io/post/css-height-width-auto-he-100/</id>
        <link href="https://huyifu.github.io/post/css-height-width-auto-he-100/">
        </link>
        <updated>2021-03-06T04:21:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="两种盒子模型-w3c盒子模型-ie盒子模型">两种盒子模型  w3c盒子模型 IE盒子模型</h3>
<p>box-sizing ： content-box w3c盒子模型<br>
box-sizing ： border-box IE盒子模型<br>
可视width（height） = content + padding + border +margin</p>
<ul>
<li>w3c盒子模型 width（height） = content</li>
<li>IE盒子模型 width（height） = content + padding + border</li>
</ul>
<h3 id="width-height-100">width (height )100%</h3>
<p>height width百分数是相对于包含块的。<br>
如果没有显示声明包含块的height，百分数高度会重置为auto。  ——《css权威指南》</p>
<ul>
<li>%设定宽高是根据父级宽高来定</li>
<li>width height 没有设置 默认auto</li>
<li>auto 一侧定值 一侧auto 则auto为剩余空间 （类似float）</li>
<li>两侧如果均是auto 则平分空间</li>
</ul>
<h3 id="margin-0-auto-为何水平居中">margin 0 auto 为何水平居中？</h3>
<p>——两侧 auto左右平分空间</p>
<h3 id="auto实现垂直居中">auto实现垂直居中</h3>
<pre><code>position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
</code></pre>
<p>试验：</p>
<p>原理： 盒子四侧全部</p>
<p>未完。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6 let命令 和const命令]]></title>
        <id>https://huyifu.github.io/post/es6-let-ming-ling/</id>
        <link href="https://huyifu.github.io/post/es6-let-ming-ling/">
        </link>
        <updated>2021-03-04T11:43:43.000Z</updated>
        <content type="html"><![CDATA[<p><strong>let类似var 不过声明的变量只在let命令下的代码块生效</strong></p>
<pre><code>var a = [];
for (var i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10  a为函数数组 var 在（）创建的变量 会存在于循环外部的执行环境中 故输出10
for (let i = 0; i &lt; 10; i++) {
    a[i] = function () {
      console.log(i);
    };
  }
a[6](); // 6  let 块级作用域 每一轮i变量重新声明 并由于js引擎内部记忆上一轮的值 计算后赋值
</code></pre>
<blockquote>
<p>for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
</blockquote>
<p>以下为代码实践证明</p>
<pre><code>for (let i = 0; i &lt; 5; i++) {
    i++; //let不声明i 开始影响（）里声明的i变量 子作用域影响父作用域
    console.log(i);
  }
//输出1 3 5
  for (let i = 0; i &lt; 5; i++) {
    let i=10; //let声明i 单独的子作用域 
    console.log(i);
  }
//输出5遍10
</code></pre>
<p><strong>var存在变量提升  let不存在</strong><br>
变量提升</p>
<ul>
<li>var关键字声明的变量，无论实际声明的位置在何处，都会被视为声明在函数的顶部（如果声明不在任意函数内，则视为在全局作用域的顶部）</li>
<li>JavaScript引擎的工作方式是，先预解析代码， 获取所有被声明的变量和函数声明，然后再一行一行地运行，这就使所有变量声明的语句，都会被提升到代码的头部，这就是变量提升</li>
</ul>
<pre><code>// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
</code></pre>
<p><strong>暂时性死区</strong><br>
用let声明变量之前，该变量不可用</p>
<ul>
<li>typeof 不是百分百不报错 ——</li>
</ul>
<pre><code>typeof x; //ReferenceError
let x;
</code></pre>
<ul>
<li>let与var</li>
</ul>
<pre><code>var  x = x;//不报错
let   x = x;//报错
</code></pre>
<p><strong>const</strong></p>
<ul>
<li>声明常量（不变） 所以后必须马上赋值</li>
<li>块级作用域有效</li>
<li>暂时性死区</li>
<li>不可重复声明</li>
<li>对象冻结，应该使用Object.freeze方法。<br>
保证常量值不改变本质是<strong>防止变量所指向内存的地址内数据进行更改</strong><br>
简单的数据类型可以保证不改变<br>
而对于复合型（数组和对象）则只能保证变量存放的指针不变 指向的数据结构内部无法控制</li>
</ul>
<pre><code>const a = [];
a.push('Hello'); // 可执行
a.length = 0;    // 可执行
a = ['Dave'];    // 报错
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[路径 相对和绝对]]></title>
        <id>https://huyifu.github.io/post/lu-jing-xiang-dui-he-jue-dui/</id>
        <link href="https://huyifu.github.io/post/lu-jing-xiang-dui-he-jue-dui/">
        </link>
        <updated>2021-03-03T12:28:44.000Z</updated>
        <content type="html"><![CDATA[<p><strong>绝对路径</strong><br>
从根目录为起点到你想到到达的目录<br>
<strong>相对路径</strong><br>
以一个基准点(自身)为起点到达你想到达的目录<br>
/ 根目录(基准点的最上层目录) 即windows系统下某个盘<br>
./当前目录  ../上一级目录  (相对的)</p>
<p>例子<br>
c:/website/web/xz/index.html<br>
c:/website/img/images/photo.jpg<br>
在index.html中导入photo.jpg<br>
绝对路径： src=&quot;c:/website/img/images/photo.jpg&quot; (本电脑)<br>
相对路径 :   src=&quot;../../img/images/photo.jpg&quot; (只要保持相对位置就可以使用)</p>
]]></content>
    </entry>
</feed>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://huyifu.github.io</id>
    <title>古月的blog</title>
    <updated>2021-03-30T00:07:19.840Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://huyifu.github.io"/>
    <link rel="self" href="https://huyifu.github.io/atom.xml"/>
    <subtitle>Nothing for nothing
</subtitle>
    <logo>https://huyifu.github.io/images/avatar.png</logo>
    <icon>https://huyifu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 古月的blog</rights>
    <entry>
        <title type="html"><![CDATA[JS 箭头函数]]></title>
        <id>https://huyifu.github.io/post/js-jian-tou-han-shu/</id>
        <link href="https://huyifu.github.io/post/js-jian-tou-han-shu/">
        </link>
        <updated>2021-03-29T12:09:30.000Z</updated>
        <content type="html"><![CDATA[<p>引言：在学习nonde 回调函数时频繁出现箭头函数 此文来详细了解箭头函数深入的特性。</p>
<h3 id="箭头函数表达式的语法比函数表达式更简洁并且没有自己的thisargumentssupernewtarget-箭头函数表达式更适用于那些本来需要匿名函数的地方并且它不能用作构造函数-因为构造函数用this指向新构建的对象">箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super，new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。因为构造函数用this指向新构建的对象。</h3>
<p>五种基础表达形式</p>
<pre><code>1. (param1, param2, …, paramN) =&gt; { statements } //标准 参数1~N 执行statements
2. (param1, param2, …, paramN) =&gt; expression // 只有一个表达式 相当于 相当于：(param1, param2, …, paramN) =&gt;{ return expression; }
3. singleParam =&gt; { statements }  //只有一个参数可不写（）
4. () =&gt;{statements}  //无参数使用（） 应用1.
5.() =&gt; expression   //无参数使用（） 应用2.
</code></pre>
<p>此外还有其他表达形式</p>
<pre><code>//加括号的函数体返回对象字面量表达式：
params =&gt; ({foo: bar})
//支持剩余参数和默认参数
(param1, param2, ...rest) =&gt; { statements }
(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; {
statements }
//同样支持参数列表解构
let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c;
f();  // 6
</code></pre>
<h3 id="箭头函数没有单独的this箭头函数不会创建自己的this它只会从自己的作用域链的上一层继承this">箭头函数没有单独的this，箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。</h3>
<p>以下为用this时候出现的一些问题</p>
<pre><code>function Counter() {
  this.num = 0;
  this.timer = setInterval(function add() {
    this.num++;
    console.log(this.num);
  }, 1000);
}
var a = new Counter();
</code></pre>
<p>输出：<br>
NaN<br>
.. 1s一个<br>
this指向window对象  this理解另一篇进行深入探讨  此处出现问题<br>
当使用箭头函数改写</p>
<pre><code>function Counter() {
  this.num = 0;
  this.timer = setInterval(()=&gt;{
      this.num++;
      console.log(num);
  },1000)
}
var a = new Counter();
</code></pre>
<p>预期输出<br>
1<br>
2<br>
..</p>
<h3 id="通过call-apply调用箭头函数">通过call、apply调用箭头函数</h3>
<p>由于箭头函数没有自己的this指针，通过call()、apply()方法调用时，第一个参数会被忽略。（箭头函数中若用了this，这个this指向包裹箭头函数的第一个普通函数的 this。）</p>
<h3 id="不绑定arguments">不绑定arguments</h3>
<p>大多数情况下，使用剩余参数是相较于arguments对象的更好选择。</p>
<h3 id="箭头函数没有prototype属性">箭头函数没有prototype属性。</h3>
<pre><code>var Foo = () =&gt; {};
console.log(Foo.prototype); // undefined
</code></pre>
<h3 id="闭包">闭包</h3>
<pre><code>// 标准的闭包函数
function A(){
      var i=0;
      return function b(){
              return (++i);
      };
};
var v=A();
v();    //1
v();    //2
//箭头函数体的闭包（ i=0 是默认参数）
var Add = (i=0) =&gt; {return (() =&gt; (++i) )};
var v = Add();
v();           //1
v();           //2
//因为仅有一个返回，return 及括号（）也可以省略
var Add = (i=0)=&gt; ()=&gt; (++i);
</code></pre>
<h2 id="总结">总结：</h2>
<ul>
<li>没有 this</li>
<li>没有 arguments</li>
<li>不能使用 new 进行调用</li>
<li>它们也没有 super</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS 回调函数]]></title>
        <id>https://huyifu.github.io/post/js-hui-diao-han-shu/</id>
        <link href="https://huyifu.github.io/post/js-hui-diao-han-shu/">
        </link>
        <updated>2021-03-29T11:06:11.000Z</updated>
        <content type="html"><![CDATA[<p>引言：在学习node中，开始大量的使用异步化编程 而异步函数与回调函数有着紧密的连接 此文来深入回调函数</p>
<h2 id="回调函数概念">回调函数概念</h2>
<p>A callback is a function that is passed as an argument to another function and is executed after its parent function has completed.</p>
<h3 id="四级水平翻译-回调函数是一个通过作为另一个函数的参数并且在父函数已经完成后执行的函数">四级水平翻译： 回调函数是一个通过作为另一个函数的参数并且在父函数已经完成后执行的函数🤧</h3>
<h3 id="自己的话来讲-回调函数是一个函数的参数并且在这个函数里可以调用这个回调函数至于这个回调函数什么时候调用-有的是可以指定调用-有的是满足特殊要求后系统自动调用">自己的话来讲： 回调函数是一个函数的参数，并且在这个函数里可以调用这个回调函数，至于这个回调函数什么时候调用 有的是可以指定调用 有的是满足特殊要求后系统自动调用</h3>
<p>以下是回调函数的一些例子 每个都有相关的理解<br>
例子一</p>
<pre><code>function addSqua(num1, num2, callback){
  var sum = num1 + num2;
  return callback(sum);
}
function squa(num){
  return num*num;
}
let num = addSqua(1, 2, squa);    
console.log(num);
//输出9  
</code></pre>
<p>以上定义了 addSqua函数 第三个参数是callback  调用时候将squa函数传值给了callback<br>
并且 在return前调用了squa函数   其实是两层函数<br>
例子二</p>
<pre><code>function doSomething(msg, callback){
    alert(msg);
    if(typeof callback == &quot;function&quot;) 
    callback();
 } 
doSomething(&quot;回调函数&quot;, function(){
    alert(&quot;匿名函数实现回调!&quot;);
 }); 
</code></pre>
<p>声明函数 doSomething  参数msg  第二个参数callback的声明在下面调用 doSometing 的时候进行<br>
这个匿名函数传值给了callback</p>
<p>例子三</p>
<pre><code>setTimeout({
  console.log(”代码执行区“);
},ms)
</code></pre>
<p>setTimeout 典型的回调函数 此处在ms毫秒后 系统自动调用这个函数 当然第一个参数也可以写成指向要执行函数的变量. 前两个例子都是自己调用.<br>
例子四（看Promise时候极具迷惑 三行代码分析起来却很多...）</p>
<pre><code>function delay(ms) {
  return new Promise(resolve =&gt; setTimeout(resolve, ms));
}
delay(3000).then(() =&gt; alert('runs after 3 seconds'));
</code></pre>
<p>delay声明区<br>
首先声明delay函数带一个参数ms<br>
返回的是一个Promise对象 其中声明了第一个参数resolve 调用setTiomeout函数的声明<br>
接收两个参数 一个是延迟ms后发生发生的resolve函数 另一个指定延迟时间<br>
delay调用区<br>
调用delay(3000) 此时将3000传值给ms 返回一个Promise对象 .then() 开始调用setTimeout函数<br>
3s后  resolve回调函数执行  箭头函数调用  无参数执行alert('runs after 3 seconds')；</p>
<h2 id="总结">总结：</h2>
<p>回调函数不是立即执行 它需要在合适的时间进行执行  与异步的理念吻合  异步：同时执行多个工作 但不能确定每个工作具体完成的时间，一般是完成单个工作后采用回调函数来进行下一步的处理。<br>
以上在主函数中的声明中 回调函数以参数形式存在  至于回调函数具体是什么函数 看传入的值来决定<br>
而它的被调用执行的时机 1自己调用 2系统调用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Es6中的Promise对象 ]]></title>
        <id>https://huyifu.github.io/post/es6-zhong-de-promise-dui-xiang/</id>
        <link href="https://huyifu.github.io/post/es6-zhong-de-promise-dui-xiang/">
        </link>
        <updated>2021-03-29T11:05:19.000Z</updated>
        <summary type="html"><![CDATA[<p>1</p>
]]></summary>
        <content type="html"><![CDATA[<p>1</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS this的指向]]></title>
        <id>https://huyifu.github.io/post/js-this-de-zhi-xiang/</id>
        <link href="https://huyifu.github.io/post/js-this-de-zhi-xiang/">
        </link>
        <updated>2021-03-29T01:11:11.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="this只在调用时才能确定this指向的对象在声明时无法确定">this只在调用时才能确定this指向的对象，在声明时无法确定</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MongoDB]]></title>
        <id>https://huyifu.github.io/post/mongodb/</id>
        <link href="https://huyifu.github.io/post/mongodb/">
        </link>
        <updated>2021-03-29T01:10:48.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Node.js 学习]]></title>
        <id>https://huyifu.github.io/post/nodejs-xue-xi/</id>
        <link href="https://huyifu.github.io/post/nodejs-xue-xi/">
        </link>
        <updated>2021-03-22T13:24:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="node三部分">node三部分</h1>
<p>引入required模块：我们可以使用require指令来载入Node.js模块。</p>
<p>创建服务器：服务器可以监听客户端的请求，类似于Apache 、Nginx等HTTP服务器。</p>
<p>接收请求与响应请求：服务器很容易创建，客户端可以使用浏览器或终端发送HTTP请求，服务器接收请求后返回响应数据。</p>
<h3 id="nvm和npm关系">nvm和npm关系</h3>
<p>nvm：nodejs 版本管理工具。<br>
也就是说：一个 nvm 可以管理很多 node 版本和 npm 版本。<br>
nodejs：在项目开发时的所需要的代码库<br>
npm：nodejs 包管理工具。<br>
在安装的 nodejs 的时候，npm 也会跟着一起安装，它是包管理工具。<br>
nvm 管理 nodejs 和 npm 的版本<br>
npm 可以管理 nodejs 的第三方插件</p>
<h3 id="使用模块化开发的原因">使用模块化开发的原因</h3>
<p>JS 文件依赖问题<br>
a.js-&gt;b.js-&gt;c.js  c.js无法单独使用<br>
命名冲突<br>
c.js num=1 a.js num=2</p>
<h3 id="node-模块化开发规范">node 模块化开发规范</h3>
<p>一个js文件就是一个模块 模块内部变量函数默认情况下在外部无法得到<br>
模块内部使用exports对象进行成员导出 使用require方法导入其他模块<br>
另一种方式<br>
module.exports.version = version;<br>
exports是module.exports的别名 指向引用关系 指向同一个导出对象<br>
当指向不同对象 导出对象是moudule.exports对象</p>
<h2 id="系统模块">系统模块</h2>
<p>系统模块 node运行环境提供的API<br>
PS: 回调函数 （err，doc） =&gt; {}   如果成功 err是NULL 不成功是一个对象</p>
<h3 id="fs-文件操作">fs 文件操作</h3>
<p>引入 const fs = require('fs')<br>
读取<br>
fs.readFile('文件路径/文件名称',['文件编码'],callback); 【】代表可选参数<br>
写入<br>
fs.writeFile('文件路径/文件名称','数据',callback);</p>
<h3 id="path-路径操作">path 路径操作</h3>
<p>路径拼接 不同操作系统路径分隔符不统一 windows / \  Linux /<br>
const path = require('path')<br>
const finalPath = path.join('a','b','c')<br>
finalPath -&gt;  a\b\c<br>
结合<br>
const fs = require('fs');<br>
const path = require('path');<br>
TIP 使用__dirname  （两个下划线）<br>
当前js文件当前文件夹的绝对路径<br>
因此路径可以表示为  path.join(__dirname, 'xx.js')   join 会自动添加<br>
fs.readFile()</p>
<p>TIP:</p>
<h3 id="相对路径和绝对路径">相对路径和绝对路径</h3>
<p>绝大部分使用绝对路径   因为相对路径是相对的命令行工具的当前工作目录<br>
读取文件 设置文件路径 绝对路径</p>
<h2 id="第三方模块">第三方模块</h2>
<p>三方模块 两种形式<br>
以js文件存在 提供API接口  -&gt; 具体功能<br>
命令行工具形式存在 辅助项目开发</p>
<h3 id="三方模块-nodemon-命令行工具">三方模块 nodemon 命令行工具</h3>
<p>cmd 可以执行 但是vs终端无法执行？？</p>
<h3 id="nrm">nrm</h3>
<p>npm下载地址切换工具<br>
npm默认下载地址 npmjs.com<br>
国内下载地址服务器同步 npm.taobao.org<br>
查询下载地址列表 nrm ls<br>
切换npm下载地址 nrm use 下载地址</p>
<p>TIP:<br>
clear 清屏   上箭头 上一次命令 下箭头 下一次命令<br>
ctrl C 终止操作</p>
<h3 id="gulp">Gulp</h3>
<p>基于node平台开发的前端构建工具<br>
将机械化操作变成命令</p>
<p>功能<br>
HTML CSS JS 压缩合并<br>
语法转换 es6 ..less..<br>
修改文件浏览器自动刷新<br>
使用</p>
<p>1使用npm install gulp下载gulp库文件<br>
（命令行当前文件下配置好了 node_modules文件夹和package-lock.json)<br>
2在项目根目录下建立gulpfile.js文件<br>
（命名固定了）<br>
3重构项目的文件夹结构 src目录放置源代码文件 dist目录放置构建后文件<br>
4在gulpfile.js文件中编写任务.<br>
5在命令行工具中执行gulp任务</p>
<p>方法<br>
gulp.src() 获取任务要处理的文件<br>
gulp.dest() 输出文件<br>
gulp.task() 建立gulp任务<br>
gulp.watch() 监考文件变化</p>
<p>gulp.task('任务的名称',() =&gt;{<br>
}) ;</p>
<p>gulp-cli  命名行工具<br>
执行任务  项目根目录 gulp 任务名称<br>
Gulp插件<br>
gulp-htmlmin: html 文件压缩</p>
<pre><code>// html压缩任务
// html文件中代码的压缩操作
// 抽取html文件中的公共代码
const htmlmin = require('gulp-htmlmin');
const fileinClude = require('gulp-file-include');
gulp.task('htmlmin',()=&gt;{
    //*. 所有的文件
    gulp.src('./src/*.html')
        //抽取放入common文件夹
        .pipe(fileinClude())
       //压缩
      .pipe(htmlmin({collapseWhitespace: true}))
      .pipe(gulp.dest('dist'));
});
</code></pre>
<p>@@include('./common/head.html')<br>
将公共代码引入进来<br>
gulp-csso :压缩css<br>
gulp-file-include 公共文件包含<br>
.....</p>
<p>构建任务<br>
TIP 当任务取名为defult gulp命令直接运行 gulp defult<br>
gulp.task('defult',['任务一名字','任务二名字'],....)</p>
<h3 id="packagejson">package.json</h3>
<p>（1）node_modules文件夹的问题<br>
文件夹以及文件过多过碎，当我们将项目整体拷贝给别人的时候,，传输速度会很慢很慢.<br>
复杂的模块依赖关系需要被记录，确保模块的版本和当前保持一致，否则会导致当前项目运行报错<br>
（2）package.json文件的作用<br>
项目描述文件，记录了当前项目信息，例如项目名称、版本、作者、github地址、当前项目依赖了哪些第三方模块等。<br>
使用npm init -y命令生成。  -y全填默认值<br>
（3）项目依赖<br>
在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖<br>
使用npm install 包名命令下载的文件会默认被添加到 package.json 文件的 dependencies 字段中<br>
{<br>
&quot;dependencies&quot;: {<br>
&quot;jquery&quot;: &quot;^3.3.1“<br>
}<br>
}<br>
（4）开发依赖<br>
在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖<br>
使用npm install 包名 --save-dev命令将包添加到package.json文件的devDependencies字段中<br>
{<br>
&quot;devDependencies&quot;: {<br>
&quot;gulp&quot;: &quot;^3.9.1“<br>
}<br>
}<br>
5）package-lock.json文件的作用<br>
锁定包的版本，确保再次下载时不会因为包版本不同而产生问题<br>
加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作</p>
<p>npm install --production 只安装项目依赖<br>
npm install  全部</p>
<p>TIP：<br>
package.json<br>
&quot;scripts&quot;:{<br>
&quot;命令别名&quot; : &quot;命令代码&quot;<br>
}<br>
cmd 敲入 npm run 别名   即可运行</p>
<h3 id="node-模块加载机制">Node 模块加载机制</h3>
<ol>
<li>当模块拥有路径但没有后缀<br>
require方法根据模块路径查找模块，如果是完整路径，直接引入模块。<br>
如果模块后缀省略，先找同名JS文件再找同名JS文件夹<br>
如果找到了同名文件夹，找文件夹中的index.js<br>
如果文件夹中没有index.js就会去当前文件夹中的package.json文件中查找main选项中的入口文件<br>
如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到</li>
<li>模块没有路径没有后缀<br>
假设它是系统模块<br>
node_moudules文件中<br>
同名js文件<br>
同名文件夹<br>
同名文件夹里面的index.js<br>
package.json main选项的入口文件</li>
</ol>
<h3 id="node全局对象">Node全局对象</h3>
<p>Node全局对象 global  ——浏览器全局对象 window<br>
global对象里 有<br>
console.log<br>
setTimeout<br>
...<br>
等等方法</p>
<h2 id="服务器开发">服务器开发</h2>
<p>###（1）服务器端基础概念<br>
网站的组成<br>
网站应用程序主要分为两大部分：客户端和服务器端。<br>
客户端：在浏览器中运行的部分，就是用户看到并与之交互的界面程序。使用HTML、CSS、JavaScript构建。<br>
服务器端：在服务器中运行的部分，负责存储数据和处理应用逻辑。</p>
<p>Node网站服务器</p>
<p>能够提供网站访问服务的机器就是网站服务器，它能够接收客户端的请求，能够对请求做出响应。</p>
<p>IP地址<br>
互联网中设备的唯一标识。<br>
IP是Internet Protocol Address的简写，代表互联网协议地址.</p>
<p>域名<br>
由于IP地址难于记忆，所以产生了域名的概念，所谓域名就是平时上网所使用的网址。<br>
http://www.baidu.com =&gt; http://124.165.219.100/ (乱写的)<br>
虽然在地址栏中输入的是网址, 但是最终还是会将域名转换为ip才能访问到指定的网站服务器。</p>
<p>端口<br>
端口是计算机与外界通讯交流的出口，用来区分服务器电脑中提供的不同的服务。</p>
<p>URL</p>
<p>统一资源定位符，又叫URL（Uniform Resource Locator），是专为标识Internet网上资源位置而设的一种编址方式，我们平时所说的网页地址指的即是URL。</p>
<p>URL的组成</p>
<p>传输协议://服务器IP或域名:端口/资源所在位置标识<br>
tip：默认80端口 没有设置端口自动设置80端口<br>
https://me.csdn.net/wuyxinu</p>
<p>http：超文本传输协议，提供了一种发布和接收HTML页面的方法。</p>
<p>开发过程中客户端和服务器端说明</p>
<p>在开发阶段，客户端和服务器端使用同一台电脑，即开发人员电脑。</p>
<p>本机域名：localhost<br>
本地IP ：127.0.0.1<br>
###（2）创建web服务器</p>
<p>// 引用系统模块<br>
const http = require('http');<br>
// 创建web服务器<br>
const app = http.createServer();<br>
// 当客户端发送请求的时候<br>
req 请求  res返回</p>
<pre><code> app.on('request', (req, res) =&gt; {
        //  响应
       res.end('&lt;h1&gt;hi, user&lt;/h1&gt;');
 });
  // 监听3000端口
 app.listen(3000);
 console.log('服务器已启动，监听3000端口，请访问 localhost:3000')
</code></pre>
<h3 id="3http协议">(3)HTTP协议</h3>
<p>（1）HTTP协议的概念<br>
超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）规定了如何从网站服务器传输超文本到本地浏览器，它基于客户端服务器架构工作，是客户端（用户）和服务器端（网站）请求和应答的标准。<br>
（2）报文<br>
在HTTP请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，并且要遵守规定好的格式。<br>
（3）请求报文<br>
TIP: 控制台 Network 可以看到请求和相应相关信息<br>
请求方式 （Request Method）<br>
GET 请求数据<br>
POST 发送数据<br>
请求地址 （Request URL）<br>
app.on('request', (req, res) =&gt; {<br>
req.headers  // 获取请求报文<br>
req.url      // 获取请求地址<br>
req.method   // 获取请求方法<br>
});<br>
locallhost 请求<br>
favicon.ico 请求<br>
都为GET方式  浏览器访问服务器 GET默认方式请求？</p>
<pre><code> &lt;form method=&quot;post&quot; action=&quot;http://localhost:3000&quot;&gt;
    &lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt;
    &lt;/form&gt;
</code></pre>
<p>设置 post请求 提交跳转到服务器 方式POST</p>
<p>req.url  /index  /homepage ....<br>
同时/favicon.ico 请求地址同样存在<br>
默认 url '/'</p>
<p>req.headers['accept']  取值accept<br>
(4)响应报文<br>
1 HTTP状态码<br>
200 请求成功<br>
404 请求的资源没有被找到<br>
500 服务器端有错误<br>
400 客户端请求语法有错误</p>
<p>response.writeHead(statusCode, [reasonPhrase], [headers])<br>
2 内容类型<br>
text/html<br>
text/css<br>
application/javascript<br>
..</p>
<p>GET 请求参数<br>
http://localhost:3000/?name=xx&amp;age=20  （键值对）</p>
<p>内置模块<br>
url 模块 用于处理url地址<br>
url.parse（url地址，true）;<br>
parse对象里<br>
query 查询参数对象<br>
pathname  路径字符串<br>
第一个参数 解析的地址 第二个参数 是否将查询参数解析成对象<br>
应用 let params = url.parse(req.url,true).query;<br>
http://localhost:3000/?name=xx&amp;age=20  （键值对）<br>
此时 params {name:xx,age:20} 对象<br>
可以取得值 params.name  -&gt;xx ...</p>
<h3 id="server_getjs">server_GET.js</h3>
<pre><code>let http = require('http');
let url = require('url');
//创建服务器
let server = http.createServer();
//为server对象添加监听事件 事件名称为request
server.on('request', (req,res) =&gt;{
    res.writeHead(200,{
        'content-type': 'text/html;charset=utf8'
    });
    //测试http://localhost:3000/homepage?name=huyifu&amp;age=20
  let {query, pathname} = url.parse(req.url,true);
  console.log(query);
  console.log(pathname);
  //parse已经被弃用但是还能使用
  /* 还没学习怎么使用 url需要完整IP地址
  const NewUrl = new URL(req.url);
    console.log(req.url);*/
   if (pathname == '/homepage' || pathname == '/')
    res.end('&lt;h1&gt;欢迎来到首页&lt;/h1&gt;');
    else if (pathname == '/personPage')
    res.end('&lt;h1&gt;欢迎来到个人主页&lt;/h1&gt;');
    else
    res.end('Not Found');
});
//监听3000端口
server.listen(3000);
console.log('服务器已启动，监听3000端口，本地可访问');
</code></pre>
<p>使用模块querystring  处理请求参数模块<br>
方法 querystring.parse 转为对象</p>
<p>post 参数是通过事件的方式接受的<br>
POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。<br>
data 当请求参数传递时候触发data事件<br>
end 当参数传递完成时候触发end事件</p>
<h3 id="server_postjs">server_POST.js</h3>
<pre><code>let http = require('http');
let url = require('url');
let querystring = require('querystring');
var util = require('util');
http.createServer(function(req, res){
    // 定义了一个post变量，用于暂存请求体的信息
    var post = '';     
    // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中
    req.on('data', function(chunk){    
        post += chunk;
    });
    // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。
    req.on('end', function(){    
        post = querystring.parse(post);
        res.end(util.inspect(post));
    });
    res.writeHead(200, {'Content-Type': 'text/html; charset=utf8'});
    res.end('ok!');
}).listen(3000);

console.log('服务器已启动，监听3000端口，本地可访问');
</code></pre>
<p>静态资源<br>
服务器不需要任何处理的资源  像图片 文件等等<br>
动态资源<br>
相同的请求地址不同的响应资源  需要服务器进行处理</p>
<h2 id="静态资源的获取">静态资源的获取</h2>
<p>app.js<br>
需要做到在服务器上请求路径后响应对应的静态资源访问 如一个html页面<br>
（项目根目录下放public文件 里面是css js html文件）<br>
如访问http://localhost:3000/index.html?key=0<br>
1 引入模块<br>
http 服务器 url 服务器上获取请求路径 path 对路径进行处理 fs 对文件读取来进行 服务器的响应-&gt;指html文件<br>
2 服务器对象设置监听对象 在回调函数里进行处理<br>
3 获取请求路径<br>
4 将请求路径转变为服务器访问静态资源的绝对路径<br>
5 通过这个绝对路径进行读取 并响应</p>
<p>遇到的问题<br>
1.所有中文乱码2.所有图片加载不出 3需要将url '/'也导进首页 '/index'<br>
原因：<br>
编码格式没设置 导致乱码<br>
在响应的html中 进行对css .js .jpj .png 等等资源再次请求    但是文件格式没有设置 导致错误<br>
解决方法<br>
在html  head区加入<meta charset="UTF-8"><br>
引入mime模块 对请求路径解析出资源的格式 并根据格式在res.writeHead上添加上状态码和格式<br>
mime.getType(path)<br>
对url进行parse成对象 里面的pathname进行分析<br>
pathname = pathname =='/' ? '/index.html' : pathname  三元运算符进行转换</p>
<p>app.js 代码如下</p>
<pre><code>const http = require('http');
const url = require('url');
const path = require('path');
const fs = require('fs');
const mime = require('mime');
var times=1;
/*1 引入模块
http 服务器 url 服务器上获取请求路径 path 对路径进行处理 fs 对文件读取来进行 服务器的响应-&gt;指html文件
2 服务器对象设置监听对象 在回调函数里进行处理
3 获取请求路径 
4 将请求路径转变为服务器访问静态资源的绝对路径
5 通过这个绝对路径进行读取 并响应*/
//http://localhost:3000/index.html?key=0
let app = http.createServer();
app.on('request',(req,res)=&gt;{
    let request_path = req.url;
    let url_obj=url.parse(request_path,true);
    let pathname=url_obj.pathname;
    pathname = pathname  == '/' ? '/index.html':pathname;
    let realPath = path.join(__dirname,'仿写小米',pathname);
    let type = mime.getType(realPath);
    console.log(times+'次:'+realPath);
    times++;
    fs.readFile(realPath,(err,data)=&gt;{
         if (err) //若读取失败err是一个对象 bool值为true
         {
            console.log('文件读取失败,错误是：'+err);
            res.writeHead(404,{'content-type':'text/html;charset=utf8'});
            res.end('文件读取失败');
            return;
         }
            res.writeHead(200,{'content-type': type});
            res.end(data);
            //console.log(data);
    });
   //res.end('ok');
});
app.listen(3000);
console.log(&quot;服务器已经启动 3000端口&quot;);
</code></pre>
<h2 id="同步与异步">同步与异步</h2>
<p>同步API 只有当API执行完成后 才能继续执行下一个API<br>
异步API 当前API的执行不会阻塞后续代码的执行</p>
<pre><code>function getMsg (callback){
    setTimeout(function(){
        callback({
            msg: 'hello'
        });
    },2000);
}
getMsg(function (data){
    console.log(data);
});
</code></pre>
<p>1 定义了getMsg函数 参数为callback函数<br>
2 在下处执行了getMsg函数 参数为函数 声明了callback函数<br>
3 在getMsg函数里 异步API setTimeout函数 2s后执行<br>
4 此时调用callback函数 参数为一个对象<br>
5 执行callback函数 console.log 这个对象 属性msg值为 'hello'字符串</p>
<h3 id="代码执行顺序">代码执行顺序</h3>
<p>分为 同步代码执行区 异步代码执行区 回调函数队列<br>
首先会将代码分区域  同步代码执行和回调函数都是自上而下先后<br>
异步代码执行区则无法确定顺序 先执行完成的先进行回调函数执行<br>
执行顺序为先执行完所有的同步代码<br>
然后进行异步代码执行区    之后执行回调函数<br>
经典例子</p>
<pre><code>for (var i = 0; i &lt;= 5; i++) {
    setTimeout(function() {
        console.log( i );
    }, i*1000);
     console.log( ' i : ' , i );
}
console.log( i );
</code></pre>
<p>输出<br>
i:0<br>
i:1<br>
i:2<br>
i:3<br>
i:4<br>
i:5<br>
6<br>
6 0s后 之上都是瞬间输出<br>
6 1s后<br>
6 2s后<br>
6 3s后<br>
6 4s后<br>
6 5s后</p>
<p>此时还有闭包问题 将var改成let</p>
<pre><code>for (var i = 0; i &lt;= 5; i++) {
    setTimeout(function() {
        console.log( i );
    }, i*1000);
     console.log( ' i : ' , i );
}
console.log( i );
</code></pre>
<p>输出<br>
i:0<br>
i:1<br>
i:2<br>
i:3<br>
i:4<br>
i:5<br>
6<br>
0 0s后 之上都是瞬间输出<br>
1 1s后<br>
2 2s后<br>
3 3s后<br>
4 4s后<br>
5 5s后<br>
这两个例子 可以根据上文的代码执行顺序进行解释<br>
先执行同步区所有代码 然后进行异步区代码</p>
<p>node js 异步API<br>
fs<br>
事件处理函数<br>
...</p>
<p>异步API后面代码的执行依赖当前异步API的执行结果 需要确定好执行顺序<br>
在回调函数里调用回调函数<br>
导致问题 回调地狱  不易维护修改</p>
<h2 id="解决方法-promise">解决方法 Promise</h2>
<h2 id="promisejs">Promise.js</h2>
<pre><code>const fs = require('fs');
/* 回调地狱 不易维护
fs.readFile('./1.text','utf8',(err,result1)=&gt;{
     console.log(result1);
     fs.readFile('./2.text','utf8',(err,result2)=&gt;{
        console.log(result2);
        fs.readFile('./3.text','utf8',(err,result3)=&gt;{
            console.log(result3);
       });
   });
});
*/
function file1(){
    return new Promise((resolve,reject)=&gt;{
        fs.readFile('./1.text','utf8',(err,result)=&gt;{
             if (err)
             reject(err);
             else
             resolve(result);
        })
    });
}
function file2(){
    return new Promise((resolve,reject)=&gt;{
        fs.readFile('./2.text','utf8',(err,result)=&gt;{
             if (err)
             reject(err);
             else
             resolve(result);
        })
    });
}
function file3(){
    return new Promise((resolve,reject)=&gt;{
        fs.readFile('./3.text','utf8',(err,result)=&gt;{
             if (err)
             reject(err);
             else
             resolve(result);
        })
    });
}
//函数return promise对象 可以链式调用
file1().then((r1)=&gt;{
    console.log(r1);
    return file2(); //此时return f2的promise对象
})
.then((r2)=&gt;{
    console.log(r2);
    return file3();
})
.then((r3)=&gt;{
    console.log(r3);
})
</code></pre>
<h2 id="异步函数-在promise对象上进行封装">异步函数 在promise对象上进行封装</h2>
<p>是终极解决方案 使得异步代码写成同步的形式 让代码不再有回调函数的嵌套<br>
async<br>
1 在普通函数定义的前面加上async关键字 普通函数就变成了异步函数<br>
2 异步函数默认的返回值是promise对象<br>
3 异步函数内部使用throw进行错误抛出  return返回data (resolve)<br>
4 then方法   catch方法<br>
await<br>
1 只能写在异步函数中<br>
2 await promise  后面只能写promise对象<br>
3 await 暂停异步函数向下执行 直到promise对象返回结果</p>
<p>应用  fs.readFile 由于无法返回promise对象 无法使用await关键字<br>
解决方法<br>
引入util 模块的promisify方法<br>
此方法接收 需要改造的函数作为参数<br>
const fs = require('fs');<br>
const util = require('util');<br>
const NewReadFile = (util.promisify)(fs.readFile); //改造返回新的方法</p>
<h2 id="asyncfunctionjs">asyncFunction.js</h2>
<pre><code>/*async function fn(){
    return 'success and DATA:...';
    throw 'error!';
}
fn().then(data=&gt;console.log(data));
//fn().catch(error=&gt;console.log(error));
*/
const fs = require('fs');
const util = require('util');
const NewReadFile = (util.promisify)(fs.readFile); //改造返回新的方法

async function run(){
  let r1= await NewReadFile('./1.text','utf8');
  let r2= await NewReadFile('./2.text','utf8');
  let r3= await NewReadFile('./3.text','utf8');
  console.log(r1);
  console.log(r2);
  console.log(r3);
}
run();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[伪类与伪元素]]></title>
        <id>https://huyifu.github.io/post/wei-lei-yu-wei-yuan-su/</id>
        <link href="https://huyifu.github.io/post/wei-lei-yu-wei-yuan-su/">
        </link>
        <updated>2021-03-18T13:50:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是伪类">什么是伪类？</h2>
<p>——伪类是选择器的一种，它用于选择处于特定状态的元素。<br>
伪类有很多种，它们都为我们提供了基于其特征无法访问或难以访问的特征来定位元素的方法。<br>
伪类的类型：</p>
<ol>
<li>动态伪类<br>
:hover :focus :link  :visited</li>
<li>基于状态的伪类<br>
:checked可以应用于复选框（）<br>
:fullscreen 定位当前以全屏模式显示的任何元素</li>
<li>结构伪类<br>
:first-child，:last-child</li>
<li>杂项伪类<br>
:not(x)选择与选择器x不匹配的元素   :lang(language-code) 选择哪些内容采用特定语言的元素</li>
</ol>
<h2 id="什么是伪元素">什么是伪元素？</h2>
<p>——伪元素用于创建一些不在文档树中的元素，并为其添加样式。<br>
ps:利用伪元素插入的dom 在dom结构中是看不到的 不过可以在css 中看到<br>
::before/::after/::first-letter/::first-line/::selection ........</p>
<h2 id="区别">区别：</h2>
<p>伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素。<br>
有没有创建一个文档树之外的元素。</p>
<p>元素指的是 HTML 文档中的标签，它是 DOM 树的一部分。而类是元素上的一个属性，是人为规定的当前元素的一个类别。</p>
<h1 id="总结">总结：</h1>
<ul>
<li>伪类与被标记的元素是一种包含关系，类添加到了这个元素上</li>
<li>伪元素与被被标记的元素是同级关系，css最终会作用在这个创造出的伪元素的位置上</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[居中方法和原理]]></title>
        <id>https://huyifu.github.io/post/ju-zhong-fang-fa-he-yuan-li/</id>
        <link href="https://huyifu.github.io/post/ju-zhong-fang-fa-he-yuan-li/">
        </link>
        <updated>2021-03-18T11:24:00.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浮动 清除浮动及其原理]]></title>
        <id>https://huyifu.github.io/post/fu-dong-qing-chu-fu-dong/</id>
        <link href="https://huyifu.github.io/post/fu-dong-qing-chu-fu-dong/">
        </link>
        <updated>2021-03-18T10:34:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="遇到父元素高度崩塌的问题">遇到父元素高度崩塌的问题</h1>
<ul>
<li>css标准文档流 默认状态 元素自动从左到右 从上往下的流式排列</li>
<li>浮动 float 会导致元素脱离文档流</li>
<li>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</li>
<li>由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</li>
<li>浮动会影响标准流的排列 其中导致父级元素高度坍塌问题<br>
例如 父元素包裹两个子div 一个左浮动 一个右浮动<br>
之后的与父元素同级的兄弟元素会直接占位<br>
父元素高度为0<br>
解决方法：</li>
</ul>
<h2 id="1-clearboth">1. clear：both</h2>
<p>clear 属性规定元素的哪一侧不允许其他浮动元素。<br>
在 CSS1 和 CSS2 中，这是通过自动为清除元素（即设置了 clear 属性的元素）增加上外边距实现的。在 CSS2.1 中，会在元素上外边距之上增加清除空间，而外边距本身并不改变。不论哪一种改变，最终结果都一样，如果声明为左边或右边清除，会使元素的上外边框边界刚好在该边上浮动元素的下外边距边界之下。<br>
应用：在内部末尾添加一个div 设置 clear：both   —— 会利用上margin把父元素撑开</p>
<h3 id="即设置clear属性的元素会有上margin大小为没有浮动元素为止">即设置clear属性的元素会有上margin大小为没有浮动元素为止</h3>
<h2 id="2-父级添加overflowhidden">2. 父级添加overflow：hidden</h2>
<p>实质上是应用了BFC一个特性 计算BFC高度时，浮动元素也参与计算<br>
那什么是BFC呢？<br>
BFC(Block formatting context)直译为&quot;块级格式化上下文&quot;。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。默认情况下只有根元素（即body）一个块级上下文。</p>
<h3 id="bfc的布局规则">BFC的布局规则</h3>
<ul>
<li>内部的Box会在垂直方向，一个接一个地放置。</li>
<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。</li>
<li>每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>
<li>BFC的区域不会与float box重叠。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。<br>
计算BFC的高度时，浮动元素也参与计算。</li>
</ul>
<h3 id="如何创建bfc">如何创建BFC</h3>
<ul>
<li>float的值不是none。</li>
<li>position的值不是static或者relative。</li>
<li>display的值是inline-block、table-cell、flex、table-caption或者inline-flex</li>
<li>overflow的值不是visible</li>
</ul>
<p>到这里已经可以解释为什么overflow hidden 能清除浮动了 ——把父元素创建成了BFC 计算高度考虑浮动元素<br>
同样的，可以设置float属性 但是父级元素的父级又得可能会有浮动引发的问题<br>
可以设置 display absolute等等</p>
<h2 id="3-使用after伪元素清除浮动">3. 使用after伪元素清除浮动</h2>
<pre><code>.clearfix:after{/*伪元素是行内元素 正常浏览器清除浮动方法*/
        content: &quot;&quot;;
        display: block;
        height: 0;
        clear:both;
        visibility: hidden;
    }
    .clearfix{
        *zoom: 1;/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/
    }
</code></pre>
<ul>
<li>
<p>在需要清除的元素添加 clearfix类<br>
after伪元素 内容空 clear:both  原理与1 相同</p>
</li>
<li>
<p>其中Zoom属性是IE浏览器的专有属性， 它可以设置或检索对象的缩放比例。<br>
当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。</p>
</li>
</ul>
<h2 id="总结清除浮动根本原理两大类-clearboth-设置为bfc元素">总结：清除浮动根本原理两大类 clear：both  设置为BFC元素</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Javascript]cssText使用]]></title>
        <id>https://huyifu.github.io/post/javascriptcsstext-shi-yong/</id>
        <link href="https://huyifu.github.io/post/javascriptcsstext-shi-yong/">
        </link>
        <updated>2021-03-15T13:33:07.000Z</updated>
        <content type="html"><![CDATA[<p>#引言<br>
再写小米官网时候 遇到了需要在js中添加样式的问题<br>
之前一直是用xxx.style.width(or height 等等) 想添加上边框时用不了<br>
border-top: 1px solid #ccc;<br>
看到了xxx.style.cssText 使用方法便头一次看到了新的css添加方法<br>
便使用</p>
<pre><code>dropDownbox[0].style.cssText = 'border-top: 1px solid #ccc;';
</code></pre>
<p>结果又有bug 搜索后总结使用方法如下：</p>
<ul>
<li>cssText，DOMString类型</li>
<li>cssText特性必须返回序列化的CSS规则。</li>
<li>当设置cssText特性时运行这些步骤：
<ol>
<li>解析其值。</li>
<li>如果解析失败则终止运行。</li>
<li>如果新对象的type并不匹配当前对象的type则抛出&quot;InvalidModificationError&quot;异常。</li>
<li>替换当前对象为新对象。<br>
——以上摘自<a href="https://segmentfault.com/a/1190000000703778">https://segmentfault.com/a/1190000000703778</a></li>
</ol>
</li>
</ul>
<h3 id="第四条会导致新对象覆盖目标元素之前所有的样式继承不算">第四条会导致新对象覆盖目标元素之前所有的样式（继承不算）</h3>
<p>例：<br>
#xxx{width:200px;height:300px;}</p>
<pre><code>var xxx-point = document.getElementById('xxx');
xxx-point.style.cssText = 'width:300px; ';
</code></pre>
<p>最终.xxx{width:300px;}</p>
<p>如果想单独添加某个css样式 方法如下:<br>
#xxx{width:200px;height:300px;}</p>
<pre><code>var xxx-point = document.getElementById('xxx');
var xxx_style = xxx-point.style.cssText;
xxx_style += 'border-top: 1px solid #ccc;';
xxx-point.style.cssText = xxx_style;
</code></pre>
<h3 id="ie678-返回全为大写而且最后没有分号">IE6/7/8 返回全为大写而且最后没有分号</h3>
<p>#xxx{width:200px;height:300px;}<br>
则cssText 为'WIDTH:200PX;HEIGHT:300PX'<br>
故若考虑 IE6/7/8 兼容则需</p>
<pre><code>var xxx-point = document.getElementById('xxx');
var xxx_style = xxx-point.style.cssText.toLowerCase(); //转化为小写
xxx_style  = 'border-top: 1px solid #ccc;'+xxx_style; //如果没有分号不影响
xxx-point.style.cssText = xxx_style;
</code></pre>
]]></content>
    </entry>
</feed>